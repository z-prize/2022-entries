#![allow(
    non_camel_case_types,
    non_upper_case_globals,
    non_snake_case,
    deref_nullptr,
    improper_ctypes
)]
/* automatically generated by rust-bindgen 0.58.1 */

pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CUDA_VERSION: u32 = 11040;
pub const CU_IPC_HANDLE_SIZE: u32 = 64;
pub const CU_MEMHOSTALLOC_PORTABLE: u32 = 1;
pub const CU_MEMHOSTALLOC_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTALLOC_WRITECOMBINED: u32 = 4;
pub const CU_MEMHOSTREGISTER_PORTABLE: u32 = 1;
pub const CU_MEMHOSTREGISTER_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTREGISTER_IOMEMORY: u32 = 4;
pub const CU_MEMHOSTREGISTER_READ_ONLY: u32 = 8;
pub const CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL: u32 = 1;
pub const CUDA_EXTERNAL_MEMORY_DEDICATED: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC: u32 = 2;
pub const CUDA_NVSCISYNC_ATTR_SIGNAL: u32 = 1;
pub const CUDA_NVSCISYNC_ATTR_WAIT: u32 = 2;
pub const CU_MEM_CREATE_USAGE_TILE_POOL: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC: u32 = 2;
pub const CUDA_ARRAY3D_LAYERED: u32 = 1;
pub const CUDA_ARRAY3D_2DARRAY: u32 = 1;
pub const CUDA_ARRAY3D_SURFACE_LDST: u32 = 2;
pub const CUDA_ARRAY3D_CUBEMAP: u32 = 4;
pub const CUDA_ARRAY3D_TEXTURE_GATHER: u32 = 8;
pub const CUDA_ARRAY3D_DEPTH_TEXTURE: u32 = 16;
pub const CUDA_ARRAY3D_COLOR_ATTACHMENT: u32 = 32;
pub const CUDA_ARRAY3D_SPARSE: u32 = 64;
pub const CU_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const CU_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const CU_TRSF_SRGB: u32 = 16;
pub const CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION: u32 = 32;
pub const CU_PARAM_TR_DEFAULT: i32 = -1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type cuuint32_t = u32;
pub type cuuint64_t = u64;
pub type CUdeviceptr_v2 = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUtexref_st {
    _unused: [u8; 0],
}
pub type CUtexref = *mut CUtexref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUsurfref_st {
    _unused: [u8; 0],
}
pub type CUsurfref = *mut CUsurfref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
pub type CUtexObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUtexObject = CUtexObject_v1;
pub type CUsurfObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUsurfObject = CUsurfObject_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type CUmemoryPool = *mut CUmemPoolHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type CUuserObject = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUuuid_st>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUuuid_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type CUuuid = CUuuid_st;
#[doc = " CUDA IPC event handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUipcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUipcEventHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUipcEventHandle_v1 = CUipcEventHandle_st;
pub type CUipcEventHandle = CUipcEventHandle_v1;
#[doc = " CUDA IPC mem handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUipcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUipcMemHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUipcMemHandle_v1 = CUipcMemHandle_st;
pub type CUipcMemHandle = CUipcMemHandle_v1;
#[doc = "< Automatically enable peer access between remote devices as needed"]
pub const CUipcMem_flags_enum_CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS: CUipcMem_flags_enum = 1;
#[doc = " CUDA Ipc Mem Flags"]
pub type CUipcMem_flags_enum = ::std::os::raw::c_uint;
pub use self::CUipcMem_flags_enum as CUipcMem_flags;
#[doc = "< Memory can be accessed by any stream on any device"]
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_GLOBAL: CUmemAttach_flags_enum = 1;
#[doc = "< Memory cannot be accessed by any stream on any device"]
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_HOST: CUmemAttach_flags_enum = 2;
#[doc = "< Memory can only be accessed by a single stream on the associated device"]
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_SINGLE: CUmemAttach_flags_enum = 4;
#[doc = " CUDA Mem Attach Flags"]
pub type CUmemAttach_flags_enum = ::std::os::raw::c_uint;
pub use self::CUmemAttach_flags_enum as CUmemAttach_flags;
#[doc = "< Automatic scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_AUTO: CUctx_flags_enum = 0;
#[doc = "< Set spin as default scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_SPIN: CUctx_flags_enum = 1;
#[doc = "< Set yield as default scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_YIELD: CUctx_flags_enum = 2;
#[doc = "< Set blocking synchronization as default scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_BLOCKING_SYNC: CUctx_flags_enum = 4;
#[doc = "< Set blocking synchronization as default scheduling"]
#[doc = "  \\deprecated This flag was deprecated as of CUDA 4.0"]
#[doc = "  and was replaced with ::CU_CTX_SCHED_BLOCKING_SYNC."]
pub const CUctx_flags_enum_CU_CTX_BLOCKING_SYNC: CUctx_flags_enum = 4;
pub const CUctx_flags_enum_CU_CTX_SCHED_MASK: CUctx_flags_enum = 7;
#[doc = "< \\deprecated This flag was deprecated as of CUDA 11.0"]
#[doc = "  and it no longer has any effect. All contexts"]
#[doc = "  as of CUDA 3.2 behave as though the flag is enabled."]
pub const CUctx_flags_enum_CU_CTX_MAP_HOST: CUctx_flags_enum = 8;
#[doc = "< Keep local memory allocation after launch"]
pub const CUctx_flags_enum_CU_CTX_LMEM_RESIZE_TO_MAX: CUctx_flags_enum = 16;
pub const CUctx_flags_enum_CU_CTX_FLAGS_MASK: CUctx_flags_enum = 31;
#[doc = " Context creation flags"]
pub type CUctx_flags_enum = ::std::os::raw::c_uint;
pub use self::CUctx_flags_enum as CUctx_flags;
#[doc = "< Default stream flag"]
pub const CUstream_flags_enum_CU_STREAM_DEFAULT: CUstream_flags_enum = 0;
#[doc = "< Stream does not synchronize with stream 0 (the NULL stream)"]
pub const CUstream_flags_enum_CU_STREAM_NON_BLOCKING: CUstream_flags_enum = 1;
#[doc = " Stream creation flags"]
pub type CUstream_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstream_flags_enum as CUstream_flags;
#[doc = "< Default event flag"]
pub const CUevent_flags_enum_CU_EVENT_DEFAULT: CUevent_flags_enum = 0;
#[doc = "< Event uses blocking synchronization"]
pub const CUevent_flags_enum_CU_EVENT_BLOCKING_SYNC: CUevent_flags_enum = 1;
#[doc = "< Event will not record timing data"]
pub const CUevent_flags_enum_CU_EVENT_DISABLE_TIMING: CUevent_flags_enum = 2;
#[doc = "< Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must be set"]
pub const CUevent_flags_enum_CU_EVENT_INTERPROCESS: CUevent_flags_enum = 4;
#[doc = " Event creation flags"]
pub type CUevent_flags_enum = ::std::os::raw::c_uint;
pub use self::CUevent_flags_enum as CUevent_flags;
#[doc = "< Default event record flag"]
pub const CUevent_record_flags_enum_CU_EVENT_RECORD_DEFAULT: CUevent_record_flags_enum = 0;
#[doc = "< When using stream capture, create an event record node"]
#[doc = "  instead of the default behavior.  This flag is invalid"]
#[doc = "  when used outside of capture."]
pub const CUevent_record_flags_enum_CU_EVENT_RECORD_EXTERNAL: CUevent_record_flags_enum = 1;
#[doc = " Event record flags"]
pub type CUevent_record_flags_enum = ::std::os::raw::c_uint;
pub use self::CUevent_record_flags_enum as CUevent_record_flags;
#[doc = "< Default event wait flag"]
pub const CUevent_wait_flags_enum_CU_EVENT_WAIT_DEFAULT: CUevent_wait_flags_enum = 0;
#[doc = "< When using stream capture, create an event wait node"]
#[doc = "  instead of the default behavior.  This flag is invalid"]
#[doc = "  when used outside of capture."]
pub const CUevent_wait_flags_enum_CU_EVENT_WAIT_EXTERNAL: CUevent_wait_flags_enum = 1;
#[doc = " Event wait flags"]
pub type CUevent_wait_flags_enum = ::std::os::raw::c_uint;
pub use self::CUevent_wait_flags_enum as CUevent_wait_flags;
#[doc = "< Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit"]
#[doc = "values). Note this is a cyclic comparison which ignores wraparound."]
#[doc = "(Default behavior.)"]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_GEQ: CUstreamWaitValue_flags_enum = 0;
#[doc = "< Wait until *addr == value."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_EQ: CUstreamWaitValue_flags_enum = 1;
#[doc = "< Wait until (*addr & value) != 0."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_AND: CUstreamWaitValue_flags_enum = 2;
#[doc = "< Wait until ~(*addr | value) != 0. Support for this operation can be"]
#[doc = "queried with ::cuDeviceGetAttribute() and"]
#[doc = "::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_NOR: CUstreamWaitValue_flags_enum = 3;
#[doc = "< Follow the wait operation with a flush of outstanding remote writes. This"]
#[doc = "means that, if a remote write operation is guaranteed to have reached the"]
#[doc = "device before the wait can be satisfied, that write is guaranteed to be"]
#[doc = "visible to downstream device work. The device is permitted to reorder"]
#[doc = "remote writes internally. For example, this flag would be required if"]
#[doc = "two remote writes arrive in a defined order, the wait is satisfied by the"]
#[doc = "second write, and downstream work needs to observe the first write."]
#[doc = "Support for this operation is restricted to selected platforms and can be"]
#[doc = "queried with ::CU_DEVICE_ATTRIBUTE_CAN_USE_WAIT_VALUE_FLUSH."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_FLUSH: CUstreamWaitValue_flags_enum =
    1073741824;
#[doc = " Flags for ::cuStreamWaitValue32 and ::cuStreamWaitValue64"]
pub type CUstreamWaitValue_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstreamWaitValue_flags_enum as CUstreamWaitValue_flags;
#[doc = "< Default behavior"]
pub const CUstreamWriteValue_flags_enum_CU_STREAM_WRITE_VALUE_DEFAULT:
    CUstreamWriteValue_flags_enum = 0;
#[doc = "< Permits the write to be reordered with writes which were issued"]
#[doc = "before it, as a performance optimization. Normally,"]
#[doc = "::cuStreamWriteValue32 will provide a memory fence before the"]
#[doc = "write, which has similar semantics to"]
#[doc = "__threadfence_system() but is scoped to the stream"]
#[doc = "rather than a CUDA thread."]
pub const CUstreamWriteValue_flags_enum_CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER:
    CUstreamWriteValue_flags_enum = 1;
#[doc = " Flags for ::cuStreamWriteValue32"]
pub type CUstreamWriteValue_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstreamWriteValue_flags_enum as CUstreamWriteValue_flags;
#[doc = "< Represents a ::cuStreamWaitValue32 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WAIT_VALUE_32: CUstreamBatchMemOpType_enum =
    1;
#[doc = "< Represents a ::cuStreamWriteValue32 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WRITE_VALUE_32: CUstreamBatchMemOpType_enum =
    2;
#[doc = "< Represents a ::cuStreamWaitValue64 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WAIT_VALUE_64: CUstreamBatchMemOpType_enum =
    4;
#[doc = "< Represents a ::cuStreamWriteValue64 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WRITE_VALUE_64: CUstreamBatchMemOpType_enum =
    5;
#[doc = "< This has the same effect as ::CU_STREAM_WAIT_VALUE_FLUSH, but as a"]
#[doc = "standalone operation."]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES:
    CUstreamBatchMemOpType_enum = 3;
#[doc = " Operations for ::cuStreamBatchMemOp"]
pub type CUstreamBatchMemOpType_enum = ::std::os::raw::c_uint;
pub use self::CUstreamBatchMemOpType_enum as CUstreamBatchMemOpType;
#[doc = " Per-operation parameters for ::cuStreamBatchMemOp"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union {
    pub operation: CUstreamBatchMemOpType,
    pub waitValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    pub writeValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    pub flushRemoteWrites: CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    pub pad: [cuuint64_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< For driver internal use. Initial value is unimportant."]
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
            >()))
            .value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .address as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .alias as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< For driver internal use. Initial value is unimportant."]
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
            >()))
            .value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .address as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .alias as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
            >()))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
            >()))
            .flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union>(),
        48usize,
        concat!("Size of: ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).operation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).waitValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).writeValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(writeValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).flushRemoteWrites as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(flushRemoteWrites)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).pad as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(pad)
        )
    );
}
pub type CUstreamBatchMemOpParams_v1 = CUstreamBatchMemOpParams_union;
pub type CUstreamBatchMemOpParams = CUstreamBatchMemOpParams_v1;
#[doc = "< Default behavior"]
pub const CUoccupancy_flags_enum_CU_OCCUPANCY_DEFAULT: CUoccupancy_flags_enum = 0;
#[doc = "< Assume global caching is enabled and cannot be automatically turned off"]
pub const CUoccupancy_flags_enum_CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE: CUoccupancy_flags_enum = 1;
#[doc = " Occupancy calculator flag"]
pub type CUoccupancy_flags_enum = ::std::os::raw::c_uint;
pub use self::CUoccupancy_flags_enum as CUoccupancy_flags;
#[doc = "< Add new nodes to the dependency set"]
pub const CUstreamUpdateCaptureDependencies_flags_enum_CU_STREAM_ADD_CAPTURE_DEPENDENCIES:
    CUstreamUpdateCaptureDependencies_flags_enum = 0;
#[doc = "< Replace the dependency set with the new nodes"]
pub const CUstreamUpdateCaptureDependencies_flags_enum_CU_STREAM_SET_CAPTURE_DEPENDENCIES:
    CUstreamUpdateCaptureDependencies_flags_enum = 1;
#[doc = " Flags for ::cuStreamUpdateCaptureDependencies"]
pub type CUstreamUpdateCaptureDependencies_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstreamUpdateCaptureDependencies_flags_enum as CUstreamUpdateCaptureDependencies_flags;
#[doc = "< Unsigned 8-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT8: CUarray_format_enum = 1;
#[doc = "< Unsigned 16-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT16: CUarray_format_enum = 2;
#[doc = "< Unsigned 32-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT32: CUarray_format_enum = 3;
#[doc = "< Signed 8-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT8: CUarray_format_enum = 8;
#[doc = "< Signed 16-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT16: CUarray_format_enum = 9;
#[doc = "< Signed 32-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT32: CUarray_format_enum = 10;
#[doc = "< 16-bit floating point"]
pub const CUarray_format_enum_CU_AD_FORMAT_HALF: CUarray_format_enum = 16;
#[doc = "< 32-bit floating point"]
pub const CUarray_format_enum_CU_AD_FORMAT_FLOAT: CUarray_format_enum = 32;
pub const CUarray_format_enum_CU_AD_FORMAT_NV12: CUarray_format_enum = 176;
#[doc = " Array formats"]
pub type CUarray_format_enum = ::std::os::raw::c_uint;
pub use self::CUarray_format_enum as CUarray_format;
#[doc = "< Wrapping address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_WRAP: CUaddress_mode_enum = 0;
#[doc = "< Clamp to edge address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_CLAMP: CUaddress_mode_enum = 1;
#[doc = "< Mirror address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_MIRROR: CUaddress_mode_enum = 2;
#[doc = "< Border address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_BORDER: CUaddress_mode_enum = 3;
#[doc = " Texture reference addressing modes"]
pub type CUaddress_mode_enum = ::std::os::raw::c_uint;
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[doc = "< Point filter mode"]
pub const CUfilter_mode_enum_CU_TR_FILTER_MODE_POINT: CUfilter_mode_enum = 0;
#[doc = "< Linear filter mode"]
pub const CUfilter_mode_enum_CU_TR_FILTER_MODE_LINEAR: CUfilter_mode_enum = 1;
#[doc = " Texture reference filtering modes"]
pub type CUfilter_mode_enum = ::std::os::raw::c_uint;
pub use self::CUfilter_mode_enum as CUfilter_mode;
#[doc = "< Maximum number of threads per block"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
    CUdevice_attribute_enum = 1;
#[doc = "< Maximum block dimension X"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: CUdevice_attribute_enum = 2;
#[doc = "< Maximum block dimension Y"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: CUdevice_attribute_enum = 3;
#[doc = "< Maximum block dimension Z"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: CUdevice_attribute_enum = 4;
#[doc = "< Maximum grid dimension X"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: CUdevice_attribute_enum = 5;
#[doc = "< Maximum grid dimension Y"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: CUdevice_attribute_enum = 6;
#[doc = "< Maximum grid dimension Z"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: CUdevice_attribute_enum = 7;
#[doc = "< Maximum shared memory available per block in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 8;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 8;
#[doc = "< Memory available on device for __constant__ variables in a CUDA C kernel in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY:
    CUdevice_attribute_enum = 9;
#[doc = "< Warp size in threads"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_WARP_SIZE: CUdevice_attribute_enum = 10;
#[doc = "< Maximum pitch in bytes allowed by memory copies"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_PITCH: CUdevice_attribute_enum = 11;
#[doc = "< Maximum number of 32-bit registers available per block"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK:
    CUdevice_attribute_enum = 12;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum =
    12;
#[doc = "< Typical clock frequency in kilohertz"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CLOCK_RATE: CUdevice_attribute_enum = 13;
#[doc = "< Alignment requirement for textures"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: CUdevice_attribute_enum =
    14;
#[doc = "< Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: CUdevice_attribute_enum = 15;
#[doc = "< Number of multiprocessors on device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT:
    CUdevice_attribute_enum = 16;
#[doc = "< Specifies whether there is a run time limit on kernels"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: CUdevice_attribute_enum =
    17;
#[doc = "< Device is integrated with host memory"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_INTEGRATED: CUdevice_attribute_enum = 18;
#[doc = "< Device can map host memory into CUDA address space"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: CUdevice_attribute_enum =
    19;
#[doc = "< Compute mode (See ::CUcomputemode for details)"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: CUdevice_attribute_enum = 20;
#[doc = "< Maximum 1D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH:
    CUdevice_attribute_enum = 21;
#[doc = "< Maximum 2D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH:
    CUdevice_attribute_enum = 22;
#[doc = "< Maximum 2D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT:
    CUdevice_attribute_enum = 23;
#[doc = "< Maximum 3D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH:
    CUdevice_attribute_enum = 24;
#[doc = "< Maximum 3D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT:
    CUdevice_attribute_enum = 25;
#[doc = "< Maximum 3D texture depth"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH:
    CUdevice_attribute_enum = 26;
#[doc = "< Maximum 2D layered texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 27;
#[doc = "< Maximum 2D layered texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT:
    CUdevice_attribute_enum = 28;
#[doc = "< Maximum layers in a 2D layered texture"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 29;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH:
    CUdevice_attribute_enum = 27;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT:
    CUdevice_attribute_enum = 28;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES:
    CUdevice_attribute_enum = 29;
#[doc = "< Alignment requirement for surfaces"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT: CUdevice_attribute_enum =
    30;
#[doc = "< Device can possibly execute multiple kernels concurrently"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: CUdevice_attribute_enum =
    31;
#[doc = "< Device has ECC support enabled"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_ECC_ENABLED: CUdevice_attribute_enum = 32;
#[doc = "< PCI bus ID of the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: CUdevice_attribute_enum = 33;
#[doc = "< PCI device ID of the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: CUdevice_attribute_enum = 34;
#[doc = "< Device is using TCC driver model"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TCC_DRIVER: CUdevice_attribute_enum = 35;
#[doc = "< Peak memory clock frequency in kilohertz"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: CUdevice_attribute_enum =
    36;
#[doc = "< Global memory bus width in bits"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH:
    CUdevice_attribute_enum = 37;
#[doc = "< Size of L2 cache in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: CUdevice_attribute_enum = 38;
#[doc = "< Maximum resident threads per multiprocessor"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 39;
#[doc = "< Number of asynchronous engines"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT: CUdevice_attribute_enum =
    40;
#[doc = "< Device shares a unified address space with the host"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: CUdevice_attribute_enum =
    41;
#[doc = "< Maximum 1D layered texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 42;
#[doc = "< Maximum layers in a 1D layered texture"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 43;
#[doc = "< Deprecated, do not use."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER: CUdevice_attribute_enum =
    44;
#[doc = "< Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH:
    CUdevice_attribute_enum = 45;
#[doc = "< Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT:
    CUdevice_attribute_enum = 46;
#[doc = "< Alternate maximum 3D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE:
    CUdevice_attribute_enum = 47;
#[doc = "< Alternate maximum 3D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE:
    CUdevice_attribute_enum = 48;
#[doc = "< Alternate maximum 3D texture depth"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE:
    CUdevice_attribute_enum = 49;
#[doc = "< PCI domain ID of the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: CUdevice_attribute_enum = 50;
#[doc = "< Pitch alignment requirement for textures"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT:
    CUdevice_attribute_enum = 51;
#[doc = "< Maximum cubemap texture width/height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH:
    CUdevice_attribute_enum = 52;
#[doc = "< Maximum cubemap layered texture width/height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH:
    CUdevice_attribute_enum = 53;
#[doc = "< Maximum layers in a cubemap layered texture"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS:
    CUdevice_attribute_enum = 54;
#[doc = "< Maximum 1D surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH:
    CUdevice_attribute_enum = 55;
#[doc = "< Maximum 2D surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH:
    CUdevice_attribute_enum = 56;
#[doc = "< Maximum 2D surface height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT:
    CUdevice_attribute_enum = 57;
#[doc = "< Maximum 3D surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH:
    CUdevice_attribute_enum = 58;
#[doc = "< Maximum 3D surface height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT:
    CUdevice_attribute_enum = 59;
#[doc = "< Maximum 3D surface depth"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH:
    CUdevice_attribute_enum = 60;
#[doc = "< Maximum 1D layered surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 61;
#[doc = "< Maximum layers in a 1D layered surface"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 62;
#[doc = "< Maximum 2D layered surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 63;
#[doc = "< Maximum 2D layered surface height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT:
    CUdevice_attribute_enum = 64;
#[doc = "< Maximum layers in a 2D layered surface"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 65;
#[doc = "< Maximum cubemap surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH:
    CUdevice_attribute_enum = 66;
#[doc = "< Maximum cubemap layered surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH:
    CUdevice_attribute_enum = 67;
#[doc = "< Maximum layers in a cubemap layered surface"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS:
    CUdevice_attribute_enum = 68;
#[doc = "< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH:
    CUdevice_attribute_enum = 69;
#[doc = "< Maximum 2D linear texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH:
    CUdevice_attribute_enum = 70;
#[doc = "< Maximum 2D linear texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT:
    CUdevice_attribute_enum = 71;
#[doc = "< Maximum 2D linear texture pitch in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH:
    CUdevice_attribute_enum = 72;
#[doc = "< Maximum mipmapped 2D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH:
    CUdevice_attribute_enum = 73;
#[doc = "< Maximum mipmapped 2D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT:
    CUdevice_attribute_enum = 74;
#[doc = "< Major compute capability version number"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR:
    CUdevice_attribute_enum = 75;
#[doc = "< Minor compute capability version number"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR:
    CUdevice_attribute_enum = 76;
#[doc = "< Maximum mipmapped 1D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH:
    CUdevice_attribute_enum = 77;
#[doc = "< Device supports stream priorities"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED:
    CUdevice_attribute_enum = 78;
#[doc = "< Device supports caching globals in L1"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED:
    CUdevice_attribute_enum = 79;
#[doc = "< Device supports caching locals in L1"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED:
    CUdevice_attribute_enum = 80;
#[doc = "< Maximum shared memory available per multiprocessor in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 81;
#[doc = "< Maximum number of 32-bit registers available per multiprocessor"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 82;
#[doc = "< Device can allocate managed memory on this system"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: CUdevice_attribute_enum = 83;
#[doc = "< Device is on a multi-GPU board"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: CUdevice_attribute_enum = 84;
#[doc = "< Unique id for a group of devices on the same multi-GPU board"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID:
    CUdevice_attribute_enum = 85;
#[doc = "< Link between the device and the host supports native atomic operations (this is a placeholder attribute, and is not supported on any current hardware)"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED:
    CUdevice_attribute_enum = 86;
#[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO:
    CUdevice_attribute_enum = 87;
#[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS:
    CUdevice_attribute_enum = 88;
#[doc = "< Device can coherently access managed memory concurrently with the CPU"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS:
    CUdevice_attribute_enum = 89;
#[doc = "< Device supports compute preemption."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED:
    CUdevice_attribute_enum = 90;
#[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM:
    CUdevice_attribute_enum = 91;
#[doc = "< ::cuStreamBatchMemOp and related APIs are supported."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS:
    CUdevice_attribute_enum = 92;
#[doc = "< 64-bit operations are supported in ::cuStreamBatchMemOp and related APIs."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS:
    CUdevice_attribute_enum = 93;
#[doc = "< ::CU_STREAM_WAIT_VALUE_NOR is supported."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR:
    CUdevice_attribute_enum = 94;
#[doc = "< Device supports launching cooperative kernels via ::cuLaunchCooperativeKernel"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH: CUdevice_attribute_enum =
    95;
#[doc = "< Deprecated, ::cuLaunchCooperativeKernelMultiDevice is deprecated."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH:
    CUdevice_attribute_enum = 96;
#[doc = "< Maximum optin shared memory per block"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN:
    CUdevice_attribute_enum = 97;
#[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device. See \\ref CUDA_MEMOP for additional details."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES:
    CUdevice_attribute_enum = 98;
#[doc = "< Device supports host memory registration via ::cudaHostRegister."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED:
    CUdevice_attribute_enum = 99;
#[doc = "< Device accesses pageable memory via the host's page tables."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES : CUdevice_attribute_enum = 100 ;
#[doc = "< The host can directly access managed memory on the device without migration."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST:
    CUdevice_attribute_enum = 101;
#[doc = "< Deprecated, Use CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED:
    CUdevice_attribute_enum = 102;
#[doc = "< Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED:
    CUdevice_attribute_enum = 102;
#[doc = "< Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED : CUdevice_attribute_enum = 103 ;
#[doc = "< Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED:
    CUdevice_attribute_enum = 104;
#[doc = "< Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED:
    CUdevice_attribute_enum = 105;
#[doc = "< Maximum number of blocks per multiprocessor"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 106;
#[doc = "< Device supports compression of memory"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED:
    CUdevice_attribute_enum = 107;
#[doc = "< Maximum L2 persisting lines capacity setting in bytes."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE:
    CUdevice_attribute_enum = 108;
#[doc = "< Maximum value of CUaccessPolicyWindow::num_bytes."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE:
    CUdevice_attribute_enum = 109;
#[doc = "< Device supports specifying the GPUDirect RDMA flag with ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED:
    CUdevice_attribute_enum = 110;
#[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 111;
#[doc = "< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED:
    CUdevice_attribute_enum = 112;
#[doc = "< Device supports using the ::cuMemHostRegister flag CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED:
    CUdevice_attribute_enum = 113;
#[doc = "< External timeline semaphore interop is supported on the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED:
    CUdevice_attribute_enum = 114;
#[doc = "< Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED:
    CUdevice_attribute_enum = 115;
#[doc = "< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED:
    CUdevice_attribute_enum = 116;
#[doc = "< The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the ::CUflushGPUDirectRDMAWritesOptions enum"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS:
    CUdevice_attribute_enum = 117;
#[doc = "< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::CUGPUDirectRDMAWritesOrdering for the numerical values returned here."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING:
    CUdevice_attribute_enum = 118;
#[doc = "< Handle types supported with mempool based IPC"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES:
    CUdevice_attribute_enum = 119;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX: CUdevice_attribute_enum = 120;
#[doc = " Device properties"]
pub type CUdevice_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[doc = " Legacy device properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUdevprop_st {
    #[doc = "< Maximum number of threads per block"]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Maximum size of each dimension of a block"]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum size of each dimension of a grid"]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Shared memory available per block in bytes"]
    pub sharedMemPerBlock: ::std::os::raw::c_int,
    #[doc = "< Constant memory available on device in bytes"]
    pub totalConstantMemory: ::std::os::raw::c_int,
    #[doc = "< Warp size in threads"]
    pub SIMDWidth: ::std::os::raw::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: ::std::os::raw::c_int,
    #[doc = "< 32-bit registers available per block"]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Clock frequency in kilohertz"]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlign: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUdevprop_st() {
    assert_eq!(
        ::std::mem::size_of::<CUdevprop_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUdevprop_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxThreadsPerBlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxThreadsDim as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxGridSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).sharedMemPerBlock as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUdevprop_st>())).totalConstantMemory as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(totalConstantMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).SIMDWidth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(SIMDWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).memPitch as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).regsPerBlock as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).clockRate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).textureAlign as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(textureAlign)
        )
    );
}
pub type CUdevprop_v1 = CUdevprop_st;
pub type CUdevprop = CUdevprop_v1;
#[doc = "< The ::CUcontext on which a pointer was allocated or registered"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_CONTEXT: CUpointer_attribute_enum = 1;
#[doc = "< The ::CUmemorytype describing the physical location of a pointer"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMORY_TYPE: CUpointer_attribute_enum = 2;
#[doc = "< The address at which a pointer's memory may be accessed on the device"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_DEVICE_POINTER: CUpointer_attribute_enum =
    3;
#[doc = "< The address at which a pointer's memory may be accessed on the host"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_HOST_POINTER: CUpointer_attribute_enum = 4;
#[doc = "< A pair of tokens for use with the nv-p2p.h Linux kernel interface"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_P2P_TOKENS: CUpointer_attribute_enum = 5;
#[doc = "< Synchronize every synchronous memory operation initiated on this region"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_SYNC_MEMOPS: CUpointer_attribute_enum = 6;
#[doc = "< A process-wide unique ID for an allocated memory region"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_BUFFER_ID: CUpointer_attribute_enum = 7;
#[doc = "< Indicates if the pointer points to managed memory"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_MANAGED: CUpointer_attribute_enum = 8;
#[doc = "< A device ordinal of a device on which a pointer was allocated or registered"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL: CUpointer_attribute_enum =
    9;
#[doc = "< 1 if this pointer maps to an allocation that is suitable for ::cudaIpcGetMemHandle, 0 otherwise"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE:
    CUpointer_attribute_enum = 10;
#[doc = "< Starting address for this requested pointer"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_RANGE_START_ADDR: CUpointer_attribute_enum =
    11;
#[doc = "< Size of the address range for this requested pointer"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_RANGE_SIZE: CUpointer_attribute_enum = 12;
#[doc = "< 1 if this pointer is in a valid address range that is mapped to a backing allocation, 0 otherwise"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MAPPED: CUpointer_attribute_enum = 13;
#[doc = "< Bitmask of allowed ::CUmemAllocationHandleType for this allocation"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES:
    CUpointer_attribute_enum = 14;
#[doc = "< 1 if the memory this pointer is referencing can be used with the GPUDirect RDMA API"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE:
    CUpointer_attribute_enum = 15;
#[doc = "< Returns the access flags the device associated with the current context has on the corresponding memory referenced by the pointer given"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAGS: CUpointer_attribute_enum = 16;
#[doc = "< Returns the mempool handle for the allocation if it was allocated from a mempool. Otherwise returns NULL."]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE: CUpointer_attribute_enum =
    17;
#[doc = " Pointer information"]
pub type CUpointer_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUpointer_attribute_enum as CUpointer_attribute;
#[doc = " The maximum number of threads per block, beyond which a launch of the"]
#[doc = " function would fail. This number depends on both the function and the"]
#[doc = " device on which the function is currently loaded."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
    CUfunction_attribute_enum = 0;
#[doc = " The size in bytes of statically-allocated shared memory required by"]
#[doc = " this function. This does not include dynamically-allocated shared"]
#[doc = " memory requested by the user at runtime."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: CUfunction_attribute_enum =
    1;
#[doc = " The size in bytes of user-allocated constant memory required by this"]
#[doc = " function."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: CUfunction_attribute_enum =
    2;
#[doc = " The size in bytes of local memory used by each thread of this function."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: CUfunction_attribute_enum =
    3;
#[doc = " The number of registers used by each thread of this function."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_NUM_REGS: CUfunction_attribute_enum = 4;
#[doc = " The PTX virtual architecture version for which the function was"]
#[doc = " compiled. This value is the major PTX version * 10 + the minor PTX"]
#[doc = " version, so a PTX version 1.3 function would return the value 13."]
#[doc = " Note that this may return the undefined value of 0 for cubins"]
#[doc = " compiled prior to CUDA 3.0."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_PTX_VERSION: CUfunction_attribute_enum = 5;
#[doc = " The binary architecture version for which the function was compiled."]
#[doc = " This value is the major binary version * 10 + the minor binary version,"]
#[doc = " so a binary version 1.3 function would return the value 13. Note that"]
#[doc = " this will return a value of 10 for legacy cubins that do not have a"]
#[doc = " properly-encoded binary architecture version."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_BINARY_VERSION: CUfunction_attribute_enum = 6;
#[doc = " The attribute to indicate whether the function has been compiled with"]
#[doc = " user specified option \"-Xptxas --dlcm=ca\" set ."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CACHE_MODE_CA: CUfunction_attribute_enum = 7;
#[doc = " The maximum size in bytes of dynamically-allocated shared memory that can be used by"]
#[doc = " this function. If the user-specified dynamic shared memory size is larger than this"]
#[doc = " value, the launch will fail."]
#[doc = " See ::cuFuncSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES:
    CUfunction_attribute_enum = 8;
#[doc = " On devices where the L1 cache and shared memory use the same hardware resources,"]
#[doc = " this sets the shared memory carveout preference, in percent of the total shared memory."]
#[doc = " Refer to ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR."]
#[doc = " This is only a hint, and the driver can choose a different ratio if required to execute the function."]
#[doc = " See ::cuFuncSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT:
    CUfunction_attribute_enum = 9;
#[doc = " On devices where the L1 cache and shared memory use the same hardware resources,"]
#[doc = " this sets the shared memory carveout preference, in percent of the total shared memory."]
#[doc = " Refer to ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR."]
#[doc = " This is only a hint, and the driver can choose a different ratio if required to execute the function."]
#[doc = " See ::cuFuncSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX: CUfunction_attribute_enum = 10;
#[doc = " Function properties"]
pub type CUfunction_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUfunction_attribute_enum as CUfunction_attribute;
#[doc = "< no preference for shared memory or L1 (default)"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_NONE: CUfunc_cache_enum = 0;
#[doc = "< prefer larger shared memory and smaller L1 cache"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_SHARED: CUfunc_cache_enum = 1;
#[doc = "< prefer larger L1 cache and smaller shared memory"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_L1: CUfunc_cache_enum = 2;
#[doc = "< prefer equal sized L1 cache and shared memory"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_EQUAL: CUfunc_cache_enum = 3;
#[doc = " Function cache configurations"]
pub type CUfunc_cache_enum = ::std::os::raw::c_uint;
pub use self::CUfunc_cache_enum as CUfunc_cache;
#[doc = "< set default shared memory bank size"]
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: CUsharedconfig_enum = 0;
#[doc = "< set shared memory bank width to four bytes"]
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: CUsharedconfig_enum = 1;
#[doc = "< set shared memory bank width to eight bytes"]
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: CUsharedconfig_enum = 2;
#[doc = " Shared memory configurations"]
pub type CUsharedconfig_enum = ::std::os::raw::c_uint;
pub use self::CUsharedconfig_enum as CUsharedconfig;
#[doc = "< No preference for shared memory or L1 (default)"]
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_DEFAULT: CUshared_carveout_enum = -1;
#[doc = "< Prefer maximum available shared memory, minimum L1 cache"]
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_MAX_SHARED: CUshared_carveout_enum = 100;
#[doc = "< Prefer maximum available L1 cache, minimum shared memory"]
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_MAX_L1: CUshared_carveout_enum = 0;
#[doc = " Shared memory carveout configurations. These may be passed to ::cuFuncSetAttribute"]
pub type CUshared_carveout_enum = ::std::os::raw::c_int;
pub use self::CUshared_carveout_enum as CUshared_carveout;
#[doc = "< Host memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_HOST: CUmemorytype_enum = 1;
#[doc = "< Device memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_DEVICE: CUmemorytype_enum = 2;
#[doc = "< Array memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_ARRAY: CUmemorytype_enum = 3;
#[doc = "< Unified device or host memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_UNIFIED: CUmemorytype_enum = 4;
#[doc = " Memory types"]
pub type CUmemorytype_enum = ::std::os::raw::c_uint;
pub use self::CUmemorytype_enum as CUmemorytype;
#[doc = "< Default compute mode (Multiple contexts allowed per device)"]
pub const CUcomputemode_enum_CU_COMPUTEMODE_DEFAULT: CUcomputemode_enum = 0;
#[doc = "< Compute-prohibited mode (No contexts can be created on this device at this time)"]
pub const CUcomputemode_enum_CU_COMPUTEMODE_PROHIBITED: CUcomputemode_enum = 2;
#[doc = "< Compute-exclusive-process mode (Only one context used by a single process can be present on this device at a time)"]
pub const CUcomputemode_enum_CU_COMPUTEMODE_EXCLUSIVE_PROCESS: CUcomputemode_enum = 3;
#[doc = " Compute Modes"]
pub type CUcomputemode_enum = ::std::os::raw::c_uint;
pub use self::CUcomputemode_enum as CUcomputemode;
#[doc = "< Data will mostly be read and only occassionally be written to"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_READ_MOSTLY: CUmem_advise_enum = 1;
#[doc = "< Undo the effect of ::CU_MEM_ADVISE_SET_READ_MOSTLY"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_READ_MOSTLY: CUmem_advise_enum = 2;
#[doc = "< Set the preferred location for the data as the specified device"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_PREFERRED_LOCATION: CUmem_advise_enum = 3;
#[doc = "< Clear the preferred location for the data"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION: CUmem_advise_enum = 4;
#[doc = "< Data will be accessed by the specified device, so prevent page faults as much as possible"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_ACCESSED_BY: CUmem_advise_enum = 5;
#[doc = "< Let the Unified Memory subsystem decide on the page faulting policy for the specified device"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_ACCESSED_BY: CUmem_advise_enum = 6;
#[doc = " Memory advise values"]
pub type CUmem_advise_enum = ::std::os::raw::c_uint;
pub use self::CUmem_advise_enum as CUmem_advise;
#[doc = "< Whether the range will mostly be read and only occassionally be written to"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY:
    CUmem_range_attribute_enum = 1;
#[doc = "< The preferred location of the range"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION:
    CUmem_range_attribute_enum = 2;
#[doc = "< Memory range has ::CU_MEM_ADVISE_SET_ACCESSED_BY set for specified device"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY:
    CUmem_range_attribute_enum = 3;
#[doc = "< The last location to which the range was prefetched"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION:
    CUmem_range_attribute_enum = 4;
pub type CUmem_range_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUmem_range_attribute_enum as CUmem_range_attribute;
#[doc = " Max number of registers that a thread may use.\\n"]
#[doc = " Option type: unsigned int\\n"]
#[doc = " Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_MAX_REGISTERS: CUjit_option_enum = 0;
#[doc = " IN: Specifies minimum number of threads per block to target compilation"]
#[doc = " for\\n"]
#[doc = " OUT: Returns the number of threads the compiler actually targeted."]
#[doc = " This restricts the resource utilization fo the compiler (e.g. max"]
#[doc = " registers) such that a block with the given number of threads should be"]
#[doc = " able to launch based on register limitations. Note, this option does not"]
#[doc = " currently take into account any other resource limitations, such as"]
#[doc = " shared memory utilization.\\n"]
#[doc = " Cannot be combined with ::CU_JIT_TARGET.\\n"]
#[doc = " Option type: unsigned int\\n"]
#[doc = " Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_THREADS_PER_BLOCK: CUjit_option_enum = 1;
#[doc = " Overwrites the option value with the total wall clock time, in"]
#[doc = " milliseconds, spent in the compiler and linker\\n"]
#[doc = " Option type: float\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_WALL_TIME: CUjit_option_enum = 2;
#[doc = " Pointer to a buffer in which to print any log messages"]
#[doc = " that are informational in nature (the buffer size is specified via"]
#[doc = " option ::CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES)\\n"]
#[doc = " Option type: char *\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_INFO_LOG_BUFFER: CUjit_option_enum = 3;
#[doc = " IN: Log buffer size in bytes.  Log messages will be capped at this size"]
#[doc = " (including null terminator)\\n"]
#[doc = " OUT: Amount of log buffer filled with messages\\n"]
#[doc = " Option type: unsigned int\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES: CUjit_option_enum = 4;
#[doc = " Pointer to a buffer in which to print any log messages that"]
#[doc = " reflect errors (the buffer size is specified via option"]
#[doc = " ::CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES)\\n"]
#[doc = " Option type: char *\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_ERROR_LOG_BUFFER: CUjit_option_enum = 5;
#[doc = " IN: Log buffer size in bytes.  Log messages will be capped at this size"]
#[doc = " (including null terminator)\\n"]
#[doc = " OUT: Amount of log buffer filled with messages\\n"]
#[doc = " Option type: unsigned int\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES: CUjit_option_enum = 6;
#[doc = " Level of optimizations to apply to generated code (0 - 4), with 4"]
#[doc = " being the default and highest level of optimizations.\\n"]
#[doc = " Option type: unsigned int\\n"]
#[doc = " Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_OPTIMIZATION_LEVEL: CUjit_option_enum = 7;
#[doc = " No option value required. Determines the target based on the current"]
#[doc = " attached context (default)\\n"]
#[doc = " Option type: No option value needed\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_TARGET_FROM_CUCONTEXT: CUjit_option_enum = 8;
#[doc = " Target is chosen based on supplied ::CUjit_target.  Cannot be"]
#[doc = " combined with ::CU_JIT_THREADS_PER_BLOCK.\\n"]
#[doc = " Option type: unsigned int for enumerated type ::CUjit_target\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_TARGET: CUjit_option_enum = 9;
#[doc = " Specifies choice of fallback strategy if matching cubin is not found."]
#[doc = " Choice is based on supplied ::CUjit_fallback.  This option cannot be"]
#[doc = " used with cuLink* APIs as the linker requires exact matches.\\n"]
#[doc = " Option type: unsigned int for enumerated type ::CUjit_fallback\\n"]
#[doc = " Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_FALLBACK_STRATEGY: CUjit_option_enum = 10;
#[doc = " Specifies whether to create debug information in output (-g)"]
#[doc = " (0: false, default)\\n"]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_GENERATE_DEBUG_INFO: CUjit_option_enum = 11;
#[doc = " Generate verbose log messages (0: false, default)\\n"]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_LOG_VERBOSE: CUjit_option_enum = 12;
#[doc = " Generate line number information (-lineinfo) (0: false, default)\\n"]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_GENERATE_LINE_INFO: CUjit_option_enum = 13;
#[doc = " Specifies whether to enable caching explicitly (-dlcm) \\n"]
#[doc = " Choice is based on supplied ::CUjit_cacheMode_enum.\\n"]
#[doc = " Option type: unsigned int for enumerated type ::CUjit_cacheMode_enum\\n"]
#[doc = " Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_CACHE_MODE: CUjit_option_enum = 14;
#[doc = " The below jit options are used for internal purposes only, in this version of CUDA"]
pub const CUjit_option_enum_CU_JIT_NEW_SM3X_OPT: CUjit_option_enum = 15;
#[doc = " The below jit options are used for internal purposes only, in this version of CUDA"]
pub const CUjit_option_enum_CU_JIT_FAST_COMPILE: CUjit_option_enum = 16;
#[doc = " Array of device symbol names that will be relocated to the corresponing"]
#[doc = " host addresses stored in ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES.\\n"]
#[doc = " Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.\\n"]
#[doc = " When loding a device module, driver will relocate all encountered"]
#[doc = " unresolved symbols to the host addresses.\\n"]
#[doc = " It is only allowed to register symbols that correspond to unresolved"]
#[doc = " global variables.\\n"]
#[doc = " It is illegal to register the same device symbol at multiple addresses.\\n"]
#[doc = " Option type: const char **\\n"]
#[doc = " Applies to: dynamic linker only"]
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_NAMES: CUjit_option_enum = 17;
#[doc = " Array of host addresses that will be used to relocate corresponding"]
#[doc = " device symbols stored in ::CU_JIT_GLOBAL_SYMBOL_NAMES.\\n"]
#[doc = " Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.\\n"]
#[doc = " Option type: void **\\n"]
#[doc = " Applies to: dynamic linker only"]
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_ADDRESSES: CUjit_option_enum = 18;
#[doc = " Number of entries in ::CU_JIT_GLOBAL_SYMBOL_NAMES and"]
#[doc = " ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES arrays.\\n"]
#[doc = " Option type: unsigned int\\n"]
#[doc = " Applies to: dynamic linker only"]
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_COUNT: CUjit_option_enum = 19;
#[doc = " Enable link-time optimization (-dlto) for device code (0: false, default)\\n"]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_LTO: CUjit_option_enum = 20;
#[doc = " Control single-precision denormals (-ftz) support (0: false, default)."]
#[doc = " 1 : flushes denormal values to zero"]
#[doc = " 0 : preserves denormal values"]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: link-time optimization specified with CU_JIT_LTO"]
pub const CUjit_option_enum_CU_JIT_FTZ: CUjit_option_enum = 21;
#[doc = " Control single-precision floating-point division and reciprocals"]
#[doc = " (-prec-div) support (1: true, default)."]
#[doc = " 1 : Enables the IEEE round-to-nearest mode"]
#[doc = " 0 : Enables the fast approximation mode"]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: link-time optimization specified with CU_JIT_LTO"]
pub const CUjit_option_enum_CU_JIT_PREC_DIV: CUjit_option_enum = 22;
#[doc = " Control single-precision floating-point square root"]
#[doc = " (-prec-sqrt) support (1: true, default)."]
#[doc = " 1 : Enables the IEEE round-to-nearest mode"]
#[doc = " 0 : Enables the fast approximation mode"]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: link-time optimization specified with CU_JIT_LTO"]
pub const CUjit_option_enum_CU_JIT_PREC_SQRT: CUjit_option_enum = 23;
#[doc = " Enable/Disable the contraction of floating-point multiplies"]
#[doc = " and adds/subtracts into floating-point multiply-add (-fma)"]
#[doc = " operations (1: Enable, default; 0: Disable)."]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: link-time optimization specified with CU_JIT_LTO"]
pub const CUjit_option_enum_CU_JIT_FMA: CUjit_option_enum = 24;
#[doc = " Enable/Disable the contraction of floating-point multiplies"]
#[doc = " and adds/subtracts into floating-point multiply-add (-fma)"]
#[doc = " operations (1: Enable, default; 0: Disable)."]
#[doc = " Option type: int\\n"]
#[doc = " Applies to: link-time optimization specified with CU_JIT_LTO"]
pub const CUjit_option_enum_CU_JIT_NUM_OPTIONS: CUjit_option_enum = 25;
#[doc = " Online compiler and linker options"]
pub type CUjit_option_enum = ::std::os::raw::c_uint;
pub use self::CUjit_option_enum as CUjit_option;
#[doc = "< Compute device class 2.0"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_20: CUjit_target_enum = 20;
#[doc = "< Compute device class 2.1"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_21: CUjit_target_enum = 21;
#[doc = "< Compute device class 3.0"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_30: CUjit_target_enum = 30;
#[doc = "< Compute device class 3.2"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_32: CUjit_target_enum = 32;
#[doc = "< Compute device class 3.5"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_35: CUjit_target_enum = 35;
#[doc = "< Compute device class 3.7"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_37: CUjit_target_enum = 37;
#[doc = "< Compute device class 5.0"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_50: CUjit_target_enum = 50;
#[doc = "< Compute device class 5.2"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_52: CUjit_target_enum = 52;
#[doc = "< Compute device class 5.3"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_53: CUjit_target_enum = 53;
#[doc = "< Compute device class 6.0."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_60: CUjit_target_enum = 60;
#[doc = "< Compute device class 6.1."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_61: CUjit_target_enum = 61;
#[doc = "< Compute device class 6.2."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_62: CUjit_target_enum = 62;
#[doc = "< Compute device class 7.0."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_70: CUjit_target_enum = 70;
#[doc = "< Compute device class 7.2."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_72: CUjit_target_enum = 72;
#[doc = "< Compute device class 7.5."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_75: CUjit_target_enum = 75;
#[doc = "< Compute device class 8.0."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_80: CUjit_target_enum = 80;
#[doc = "< Compute device class 8.6."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_86: CUjit_target_enum = 86;
#[doc = " Online compilation targets"]
pub type CUjit_target_enum = ::std::os::raw::c_uint;
pub use self::CUjit_target_enum as CUjit_target;
#[doc = "< Prefer to compile ptx if exact binary match not found"]
pub const CUjit_fallback_enum_CU_PREFER_PTX: CUjit_fallback_enum = 0;
#[doc = "< Prefer to fall back to compatible binary code if exact match not found"]
pub const CUjit_fallback_enum_CU_PREFER_BINARY: CUjit_fallback_enum = 1;
#[doc = " Cubin matching fallback strategies"]
pub type CUjit_fallback_enum = ::std::os::raw::c_uint;
pub use self::CUjit_fallback_enum as CUjit_fallback;
#[doc = "< Compile with no -dlcm flag specified"]
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_NONE: CUjit_cacheMode_enum = 0;
#[doc = "< Compile with L1 cache disabled"]
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_CG: CUjit_cacheMode_enum = 1;
#[doc = "< Compile with L1 cache enabled"]
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_CA: CUjit_cacheMode_enum = 2;
#[doc = " Caching modes for dlcm"]
pub type CUjit_cacheMode_enum = ::std::os::raw::c_uint;
pub use self::CUjit_cacheMode_enum as CUjit_cacheMode;
#[doc = " Compiled device-class-specific device code\\n"]
#[doc = " Applicable options: none"]
pub const CUjitInputType_enum_CU_JIT_INPUT_CUBIN: CUjitInputType_enum = 0;
#[doc = " PTX source code\\n"]
#[doc = " Applicable options: PTX compiler options"]
pub const CUjitInputType_enum_CU_JIT_INPUT_PTX: CUjitInputType_enum = 1;
#[doc = " Bundle of multiple cubins and/or PTX of some device code\\n"]
#[doc = " Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY"]
pub const CUjitInputType_enum_CU_JIT_INPUT_FATBINARY: CUjitInputType_enum = 2;
#[doc = " Host object with embedded device code\\n"]
#[doc = " Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY"]
pub const CUjitInputType_enum_CU_JIT_INPUT_OBJECT: CUjitInputType_enum = 3;
#[doc = " Archive of host objects with embedded device code\\n"]
#[doc = " Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY"]
pub const CUjitInputType_enum_CU_JIT_INPUT_LIBRARY: CUjitInputType_enum = 4;
#[doc = " High-level intermediate code for link-time optimization\\n"]
#[doc = " Applicable options: NVVM compiler options, PTX compiler options"]
pub const CUjitInputType_enum_CU_JIT_INPUT_NVVM: CUjitInputType_enum = 5;
#[doc = " High-level intermediate code for link-time optimization\\n"]
#[doc = " Applicable options: NVVM compiler options, PTX compiler options"]
pub const CUjitInputType_enum_CU_JIT_NUM_INPUT_TYPES: CUjitInputType_enum = 6;
#[doc = " Device code formats"]
pub type CUjitInputType_enum = ::std::os::raw::c_uint;
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_NONE:
    CUgraphicsRegisterFlags_enum = 0;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY:
    CUgraphicsRegisterFlags_enum = 1;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD:
    CUgraphicsRegisterFlags_enum = 2;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST:
    CUgraphicsRegisterFlags_enum = 4;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER:
    CUgraphicsRegisterFlags_enum = 8;
#[doc = " Flags to register a graphics resource"]
pub type CUgraphicsRegisterFlags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE:
    CUgraphicsMapResourceFlags_enum = 0;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY:
    CUgraphicsMapResourceFlags_enum = 1;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD:
    CUgraphicsMapResourceFlags_enum = 2;
#[doc = " Flags for mapping and unmapping interop resources"]
pub type CUgraphicsMapResourceFlags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphicsMapResourceFlags_enum as CUgraphicsMapResourceFlags;
#[doc = "< Positive X face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_X: CUarray_cubemap_face_enum = 0;
#[doc = "< Negative X face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_X: CUarray_cubemap_face_enum = 1;
#[doc = "< Positive Y face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_Y: CUarray_cubemap_face_enum = 2;
#[doc = "< Negative Y face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_Y: CUarray_cubemap_face_enum = 3;
#[doc = "< Positive Z face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_Z: CUarray_cubemap_face_enum = 4;
#[doc = "< Negative Z face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_Z: CUarray_cubemap_face_enum = 5;
#[doc = " Array indices for cube faces"]
pub type CUarray_cubemap_face_enum = ::std::os::raw::c_uint;
pub use self::CUarray_cubemap_face_enum as CUarray_cubemap_face;
#[doc = "< GPU thread stack size"]
pub const CUlimit_enum_CU_LIMIT_STACK_SIZE: CUlimit_enum = 0;
#[doc = "< GPU printf FIFO size"]
pub const CUlimit_enum_CU_LIMIT_PRINTF_FIFO_SIZE: CUlimit_enum = 1;
#[doc = "< GPU malloc heap size"]
pub const CUlimit_enum_CU_LIMIT_MALLOC_HEAP_SIZE: CUlimit_enum = 2;
#[doc = "< GPU device runtime launch synchronize depth"]
pub const CUlimit_enum_CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH: CUlimit_enum = 3;
#[doc = "< GPU device runtime pending launch count"]
pub const CUlimit_enum_CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT: CUlimit_enum = 4;
#[doc = "< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint"]
pub const CUlimit_enum_CU_LIMIT_MAX_L2_FETCH_GRANULARITY: CUlimit_enum = 5;
#[doc = "< A size in bytes for L2 persisting lines cache size"]
pub const CUlimit_enum_CU_LIMIT_PERSISTING_L2_CACHE_SIZE: CUlimit_enum = 6;
pub const CUlimit_enum_CU_LIMIT_MAX: CUlimit_enum = 7;
#[doc = " Limits"]
pub type CUlimit_enum = ::std::os::raw::c_uint;
pub use self::CUlimit_enum as CUlimit;
#[doc = "< Array resoure"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_ARRAY: CUresourcetype_enum = 0;
#[doc = "< Mipmapped array resource"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_MIPMAPPED_ARRAY: CUresourcetype_enum = 1;
#[doc = "< Linear resource"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_LINEAR: CUresourcetype_enum = 2;
#[doc = "< Pitch 2D resource"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_PITCH2D: CUresourcetype_enum = 3;
#[doc = " Resource types"]
pub type CUresourcetype_enum = ::std::os::raw::c_uint;
pub use self::CUresourcetype_enum as CUresourcetype;
#[doc = " CUDA host function"]
#[doc = " \\param userData Argument value passed to the function"]
pub type CUhostFn =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[doc = "< Normal cache persistence."]
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_NORMAL: CUaccessProperty_enum = 0;
#[doc = "< Streaming access is less likely to persit from cache."]
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_STREAMING: CUaccessProperty_enum = 1;
#[doc = "< Persisting access is more likely to persist in cache."]
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_PERSISTING: CUaccessProperty_enum = 2;
#[doc = " Specifies performance hint with ::CUaccessPolicyWindow for hitProp and missProp members."]
pub type CUaccessProperty_enum = ::std::os::raw::c_uint;
pub use self::CUaccessProperty_enum as CUaccessProperty;
#[doc = " Specifies an access policy for a window, a contiguous extent of memory"]
#[doc = " beginning at base_ptr and ending at base_ptr + num_bytes."]
#[doc = " num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE."]
#[doc = " Partition into many segments and assign segments such that:"]
#[doc = " sum of \"hit segments\" / window == approx. ratio."]
#[doc = " sum of \"miss segments\" / window == approx 1-ratio."]
#[doc = " Segments and ratio specifications are fitted to the capabilities of"]
#[doc = " the architecture."]
#[doc = " Accesses in a hit segment apply the hitProp access policy."]
#[doc = " Accesses in a miss segment apply the missProp access policy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUaccessPolicyWindow_st {
    #[doc = "< Starting address of the access policy window. CUDA driver may align it."]
    pub base_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment."]
    pub num_bytes: size_t,
    #[doc = "< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp."]
    pub hitRatio: f32,
    #[doc = "< ::CUaccessProperty set for hit."]
    pub hitProp: CUaccessProperty,
    #[doc = "< ::CUaccessProperty set for miss. Must be either NORMAL or STREAMING"]
    pub missProp: CUaccessProperty,
}
#[test]
fn bindgen_test_layout_CUaccessPolicyWindow_st() {
    assert_eq!(
        ::std::mem::size_of::<CUaccessPolicyWindow_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUaccessPolicyWindow_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).base_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(base_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).num_bytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).hitRatio as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).hitProp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitProp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).missProp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(missProp)
        )
    );
}
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
#[doc = " GPU kernel node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_KERNEL_NODE_PARAMS_st {
    #[doc = "< Kernel to launch"]
    pub func: CUfunction,
    #[doc = "< Width of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Array of pointers to kernel parameters"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Extra options"]
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimX as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimY as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimZ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimX as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimY as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimZ as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).sharedMemBytes as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).kernelParams as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).extra as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(extra)
        )
    );
}
pub type CUDA_KERNEL_NODE_PARAMS_v1 = CUDA_KERNEL_NODE_PARAMS_st;
pub type CUDA_KERNEL_NODE_PARAMS = CUDA_KERNEL_NODE_PARAMS_v1;
#[doc = " Memset node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMSET_NODE_PARAMS_st {
    #[doc = "< Destination device pointer"]
    pub dst: CUdeviceptr,
    #[doc = "< Pitch of destination device pointer. Unused if height is 1"]
    pub pitch: size_t,
    #[doc = "< Value to be set"]
    pub value: ::std::os::raw::c_uint,
    #[doc = "< Size of each element in bytes. Must be 1, 2, or 4."]
    pub elementSize: ::std::os::raw::c_uint,
    #[doc = "< Width of the row in elements"]
    pub width: size_t,
    #[doc = "< Number of rows"]
    pub height: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMSET_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).pitch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).elementSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).height as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(height)
        )
    );
}
pub type CUDA_MEMSET_NODE_PARAMS_v1 = CUDA_MEMSET_NODE_PARAMS_st;
pub type CUDA_MEMSET_NODE_PARAMS = CUDA_MEMSET_NODE_PARAMS_v1;
#[doc = " Host node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_HOST_NODE_PARAMS_st {
    #[doc = "< The function to call when the node executes"]
    pub fn_: CUhostFn,
    #[doc = "< Argument to pass to the function"]
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_HOST_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_HOST_NODE_PARAMS_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_HOST_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_HOST_NODE_PARAMS_st>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_HOST_NODE_PARAMS_st>())).userData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(userData)
        )
    );
}
pub type CUDA_HOST_NODE_PARAMS_v1 = CUDA_HOST_NODE_PARAMS_st;
pub type CUDA_HOST_NODE_PARAMS = CUDA_HOST_NODE_PARAMS_v1;
#[doc = "< GPU kernel node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_KERNEL: CUgraphNodeType_enum = 0;
#[doc = "< Memcpy node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEMCPY: CUgraphNodeType_enum = 1;
#[doc = "< Memset node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEMSET: CUgraphNodeType_enum = 2;
#[doc = "< Host (executable) node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_HOST: CUgraphNodeType_enum = 3;
#[doc = "< Node which executes an embedded graph"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_GRAPH: CUgraphNodeType_enum = 4;
#[doc = "< Empty (no-op) node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EMPTY: CUgraphNodeType_enum = 5;
#[doc = "< External event wait node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_WAIT_EVENT: CUgraphNodeType_enum = 6;
#[doc = "< External event record node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EVENT_RECORD: CUgraphNodeType_enum = 7;
#[doc = "< External semaphore signal node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL: CUgraphNodeType_enum = 8;
#[doc = "< External semaphore wait node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT: CUgraphNodeType_enum = 9;
#[doc = "< Memory Allocation Node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEM_ALLOC: CUgraphNodeType_enum = 10;
#[doc = "< Memory Free Node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEM_FREE: CUgraphNodeType_enum = 11;
#[doc = " Graph node types"]
pub type CUgraphNodeType_enum = ::std::os::raw::c_uint;
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_AUTO: CUsynchronizationPolicy_enum = 1;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_SPIN: CUsynchronizationPolicy_enum = 2;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_YIELD: CUsynchronizationPolicy_enum = 3;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_BLOCKING_SYNC: CUsynchronizationPolicy_enum =
    4;
pub type CUsynchronizationPolicy_enum = ::std::os::raw::c_uint;
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
#[doc = "< Identifier for ::CUkernelNodeAttrValue::accessPolicyWindow."]
pub const CUkernelNodeAttrID_enum_CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW:
    CUkernelNodeAttrID_enum = 1;
#[doc = "< Allows a kernel node to be cooperative (see ::cuLaunchCooperativeKernel)."]
pub const CUkernelNodeAttrID_enum_CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE: CUkernelNodeAttrID_enum = 2;
#[doc = " Graph kernel node Attributes"]
pub type CUkernelNodeAttrID_enum = ::std::os::raw::c_uint;
pub use self::CUkernelNodeAttrID_enum as CUkernelNodeAttrID;
#[doc = " Graph kernel node attributes union, used with ::cuKernelNodeSetAttribute/::cuKernelNodeGetAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUkernelNodeAttrValue_union {
    #[doc = "< Attribute ::CUaccessPolicyWindow."]
    pub accessPolicyWindow: CUaccessPolicyWindow,
    #[doc = "< Nonzero indicates a cooperative kernel (see ::cuLaunchCooperativeKernel)."]
    pub cooperative: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUkernelNodeAttrValue_union() {
    assert_eq!(
        ::std::mem::size_of::<CUkernelNodeAttrValue_union>(),
        32usize,
        concat!("Size of: ", stringify!(CUkernelNodeAttrValue_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUkernelNodeAttrValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUkernelNodeAttrValue_union))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUkernelNodeAttrValue_union>())).accessPolicyWindow as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUkernelNodeAttrValue_union),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUkernelNodeAttrValue_union>())).cooperative as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUkernelNodeAttrValue_union),
            "::",
            stringify!(cooperative)
        )
    );
}
pub type CUkernelNodeAttrValue_v1 = CUkernelNodeAttrValue_union;
pub type CUkernelNodeAttrValue = CUkernelNodeAttrValue_v1;
#[doc = "< Stream is not capturing"]
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_NONE: CUstreamCaptureStatus_enum = 0;
#[doc = "< Stream is actively capturing"]
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_ACTIVE: CUstreamCaptureStatus_enum =
    1;
#[doc = "< Stream is part of a capture sequence that"]
#[doc = "has been invalidated, but not terminated"]
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_INVALIDATED:
    CUstreamCaptureStatus_enum = 2;
#[doc = " Possible stream capture statuses returned by ::cuStreamIsCapturing"]
pub type CUstreamCaptureStatus_enum = ::std::os::raw::c_uint;
pub use self::CUstreamCaptureStatus_enum as CUstreamCaptureStatus;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_GLOBAL: CUstreamCaptureMode_enum = 0;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_THREAD_LOCAL: CUstreamCaptureMode_enum =
    1;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_RELAXED: CUstreamCaptureMode_enum = 2;
#[doc = " Possible modes for stream capture thread interactions. For more details see"]
#[doc = " ::cuStreamBeginCapture and ::cuThreadExchangeStreamCaptureMode"]
pub type CUstreamCaptureMode_enum = ::std::os::raw::c_uint;
pub use self::CUstreamCaptureMode_enum as CUstreamCaptureMode;
#[doc = "< Identifier for ::CUstreamAttrValue::accessPolicyWindow."]
pub const CUstreamAttrID_enum_CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW: CUstreamAttrID_enum = 1;
#[doc = "< ::CUsynchronizationPolicy for work queued up in this stream"]
pub const CUstreamAttrID_enum_CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY: CUstreamAttrID_enum = 3;
#[doc = " Stream Attributes"]
pub type CUstreamAttrID_enum = ::std::os::raw::c_uint;
pub use self::CUstreamAttrID_enum as CUstreamAttrID;
#[doc = " Stream attributes union, used with ::cuStreamSetAttribute/::cuStreamGetAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamAttrValue_union {
    #[doc = "< Attribute ::CUaccessPolicyWindow."]
    pub accessPolicyWindow: CUaccessPolicyWindow,
    #[doc = "< Value for ::CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY."]
    pub syncPolicy: CUsynchronizationPolicy,
}
#[test]
fn bindgen_test_layout_CUstreamAttrValue_union() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamAttrValue_union>(),
        32usize,
        concat!("Size of: ", stringify!(CUstreamAttrValue_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamAttrValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamAttrValue_union))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamAttrValue_union>())).accessPolicyWindow as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamAttrValue_union),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamAttrValue_union>())).syncPolicy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamAttrValue_union),
            "::",
            stringify!(syncPolicy)
        )
    );
}
pub type CUstreamAttrValue_v1 = CUstreamAttrValue_union;
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
#[doc = "< Default search mode for driver symbols."]
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_DEFAULT:
    CUdriverProcAddress_flags_enum = 0;
#[doc = "< Search for legacy versions of driver symbols."]
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_LEGACY_STREAM:
    CUdriverProcAddress_flags_enum = 1;
#[doc = "< Search for per-thread versions of driver symbols."]
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM:
    CUdriverProcAddress_flags_enum = 2;
#[doc = " Flags to specify search options. For more details see ::cuGetProcAddress"]
pub type CUdriverProcAddress_flags_enum = ::std::os::raw::c_uint;
pub use self::CUdriverProcAddress_flags_enum as CUdriverProcAddress_flags;
#[doc = "< Create a context with limited SMs."]
pub const CUexecAffinityType_enum_CU_EXEC_AFFINITY_TYPE_SM_COUNT: CUexecAffinityType_enum = 0;
pub const CUexecAffinityType_enum_CU_EXEC_AFFINITY_TYPE_MAX: CUexecAffinityType_enum = 1;
#[doc = " Execution Affinity Types"]
pub type CUexecAffinityType_enum = ::std::os::raw::c_uint;
pub use self::CUexecAffinityType_enum as CUexecAffinityType;
#[doc = " Value for ::CU_EXEC_AFFINITY_TYPE_SM_COUNT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexecAffinitySmCount_st {
    #[doc = "< The number of SMs the context is limited to use."]
    pub val: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUexecAffinitySmCount_st() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Size of: ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUexecAffinitySmCount_st>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinitySmCount_st),
            "::",
            stringify!(val)
        )
    );
}
pub type CUexecAffinitySmCount_v1 = CUexecAffinitySmCount_st;
pub type CUexecAffinitySmCount = CUexecAffinitySmCount_v1;
#[doc = " Execution Affinity Parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUexecAffinityParam_st {
    pub type_: CUexecAffinityType,
    pub param: CUexecAffinityParam_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUexecAffinityParam_st__bindgen_ty_1 {
    pub smCount: CUexecAffinitySmCount,
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUexecAffinityParam_st__bindgen_ty_1>())).smCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1),
            "::",
            stringify!(smCount)
        )
    );
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUexecAffinityParam_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUexecAffinityParam_st>())).param as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(param)
        )
    );
}
pub type CUexecAffinityParam_v1 = CUexecAffinityParam_st;
pub type CUexecAffinityParam = CUexecAffinityParam_v1;
#[doc = " The API call returned with no errors. In the case of query calls, this"]
#[doc = " also means that the operation being queried is complete (see"]
#[doc = " ::cuEventQuery() and ::cuStreamQuery())."]
pub const cudaError_enum_CUDA_SUCCESS: cudaError_enum = 0;
#[doc = " This indicates that one or more of the parameters passed to the API call"]
#[doc = " is not within an acceptable range of values."]
pub const cudaError_enum_CUDA_ERROR_INVALID_VALUE: cudaError_enum = 1;
#[doc = " The API call failed because it was unable to allocate enough memory to"]
#[doc = " perform the requested operation."]
pub const cudaError_enum_CUDA_ERROR_OUT_OF_MEMORY: cudaError_enum = 2;
#[doc = " This indicates that the CUDA driver has not been initialized with"]
#[doc = " ::cuInit() or that initialization has failed."]
pub const cudaError_enum_CUDA_ERROR_NOT_INITIALIZED: cudaError_enum = 3;
#[doc = " This indicates that the CUDA driver is in the process of shutting down."]
pub const cudaError_enum_CUDA_ERROR_DEINITIALIZED: cudaError_enum = 4;
#[doc = " This indicates profiler is not initialized for this run. This can"]
#[doc = " happen when the application is running with external profiling tools"]
#[doc = " like visual profiler."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_DISABLED: cudaError_enum = 5;
#[doc = " \\deprecated"]
#[doc = " This error return is deprecated as of CUDA 5.0. It is no longer an error"]
#[doc = " to attempt to enable/disable the profiling via ::cuProfilerStart or"]
#[doc = " ::cuProfilerStop without initialization."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_NOT_INITIALIZED: cudaError_enum = 6;
#[doc = " \\deprecated"]
#[doc = " This error return is deprecated as of CUDA 5.0. It is no longer an error"]
#[doc = " to call cuProfilerStart() when profiling is already enabled."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_ALREADY_STARTED: cudaError_enum = 7;
#[doc = " \\deprecated"]
#[doc = " This error return is deprecated as of CUDA 5.0. It is no longer an error"]
#[doc = " to call cuProfilerStop() when profiling is already disabled."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_ALREADY_STOPPED: cudaError_enum = 8;
#[doc = " This indicates that the CUDA driver that the application has loaded is a"]
#[doc = " stub library. Applications that run with the stub rather than a real"]
#[doc = " driver loaded will result in CUDA API returning this error."]
pub const cudaError_enum_CUDA_ERROR_STUB_LIBRARY: cudaError_enum = 34;
#[doc = " This indicates that no CUDA-capable devices were detected by the installed"]
#[doc = " CUDA driver."]
pub const cudaError_enum_CUDA_ERROR_NO_DEVICE: cudaError_enum = 100;
#[doc = " This indicates that the device ordinal supplied by the user does not"]
#[doc = " correspond to a valid CUDA device or that the action requested is"]
#[doc = " invalid for the specified device."]
pub const cudaError_enum_CUDA_ERROR_INVALID_DEVICE: cudaError_enum = 101;
#[doc = " This error indicates that the Grid license is not applied."]
pub const cudaError_enum_CUDA_ERROR_DEVICE_NOT_LICENSED: cudaError_enum = 102;
#[doc = " This indicates that the device kernel image is invalid. This can also"]
#[doc = " indicate an invalid CUDA module."]
pub const cudaError_enum_CUDA_ERROR_INVALID_IMAGE: cudaError_enum = 200;
#[doc = " This most frequently indicates that there is no context bound to the"]
#[doc = " current thread. This can also be returned if the context passed to an"]
#[doc = " API call is not a valid handle (such as a context that has had"]
#[doc = " ::cuCtxDestroy() invoked on it). This can also be returned if a user"]
#[doc = " mixes different API versions (i.e. 3010 context with 3020 API calls)."]
#[doc = " See ::cuCtxGetApiVersion() for more details."]
pub const cudaError_enum_CUDA_ERROR_INVALID_CONTEXT: cudaError_enum = 201;
#[doc = " This indicated that the context being supplied as a parameter to the"]
#[doc = " API call was already the active context."]
#[doc = " \\deprecated"]
#[doc = " This error return is deprecated as of CUDA 3.2. It is no longer an"]
#[doc = " error to attempt to push the active context via ::cuCtxPushCurrent()."]
pub const cudaError_enum_CUDA_ERROR_CONTEXT_ALREADY_CURRENT: cudaError_enum = 202;
#[doc = " This indicates that a map or register operation has failed."]
pub const cudaError_enum_CUDA_ERROR_MAP_FAILED: cudaError_enum = 205;
#[doc = " This indicates that an unmap or unregister operation has failed."]
pub const cudaError_enum_CUDA_ERROR_UNMAP_FAILED: cudaError_enum = 206;
#[doc = " This indicates that the specified array is currently mapped and thus"]
#[doc = " cannot be destroyed."]
pub const cudaError_enum_CUDA_ERROR_ARRAY_IS_MAPPED: cudaError_enum = 207;
#[doc = " This indicates that the resource is already mapped."]
pub const cudaError_enum_CUDA_ERROR_ALREADY_MAPPED: cudaError_enum = 208;
#[doc = " This indicates that there is no kernel image available that is suitable"]
#[doc = " for the device. This can occur when a user specifies code generation"]
#[doc = " options for a particular CUDA source file that do not include the"]
#[doc = " corresponding device configuration."]
pub const cudaError_enum_CUDA_ERROR_NO_BINARY_FOR_GPU: cudaError_enum = 209;
#[doc = " This indicates that a resource has already been acquired."]
pub const cudaError_enum_CUDA_ERROR_ALREADY_ACQUIRED: cudaError_enum = 210;
#[doc = " This indicates that a resource is not mapped."]
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED: cudaError_enum = 211;
#[doc = " This indicates that a mapped resource is not available for access as an"]
#[doc = " array."]
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED_AS_ARRAY: cudaError_enum = 212;
#[doc = " This indicates that a mapped resource is not available for access as a"]
#[doc = " pointer."]
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED_AS_POINTER: cudaError_enum = 213;
#[doc = " This indicates that an uncorrectable ECC error was detected during"]
#[doc = " execution."]
pub const cudaError_enum_CUDA_ERROR_ECC_UNCORRECTABLE: cudaError_enum = 214;
#[doc = " This indicates that the ::CUlimit passed to the API call is not"]
#[doc = " supported by the active device."]
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_LIMIT: cudaError_enum = 215;
#[doc = " This indicates that the ::CUcontext passed to the API call can"]
#[doc = " only be bound to a single CPU thread at a time but is already"]
#[doc = " bound to a CPU thread."]
pub const cudaError_enum_CUDA_ERROR_CONTEXT_ALREADY_IN_USE: cudaError_enum = 216;
#[doc = " This indicates that peer access is not supported across the given"]
#[doc = " devices."]
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_UNSUPPORTED: cudaError_enum = 217;
#[doc = " This indicates that a PTX JIT compilation failed."]
pub const cudaError_enum_CUDA_ERROR_INVALID_PTX: cudaError_enum = 218;
#[doc = " This indicates an error with OpenGL or DirectX context."]
pub const cudaError_enum_CUDA_ERROR_INVALID_GRAPHICS_CONTEXT: cudaError_enum = 219;
#[doc = " This indicates that an uncorrectable NVLink error was detected during the"]
#[doc = " execution."]
pub const cudaError_enum_CUDA_ERROR_NVLINK_UNCORRECTABLE: cudaError_enum = 220;
#[doc = " This indicates that the PTX JIT compiler library was not found."]
pub const cudaError_enum_CUDA_ERROR_JIT_COMPILER_NOT_FOUND: cudaError_enum = 221;
#[doc = " This indicates that the provided PTX was compiled with an unsupported toolchain."]
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_PTX_VERSION: cudaError_enum = 222;
#[doc = " This indicates that the PTX JIT compilation was disabled."]
pub const cudaError_enum_CUDA_ERROR_JIT_COMPILATION_DISABLED: cudaError_enum = 223;
#[doc = " This indicates that the ::CUexecAffinityType passed to the API call is not"]
#[doc = " supported by the active device."]
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY: cudaError_enum = 224;
#[doc = " This indicates that the device kernel source is invalid."]
pub const cudaError_enum_CUDA_ERROR_INVALID_SOURCE: cudaError_enum = 300;
#[doc = " This indicates that the file specified was not found."]
pub const cudaError_enum_CUDA_ERROR_FILE_NOT_FOUND: cudaError_enum = 301;
#[doc = " This indicates that a link to a shared object failed to resolve."]
pub const cudaError_enum_CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND: cudaError_enum = 302;
#[doc = " This indicates that initialization of a shared object failed."]
pub const cudaError_enum_CUDA_ERROR_SHARED_OBJECT_INIT_FAILED: cudaError_enum = 303;
#[doc = " This indicates that an OS call failed."]
pub const cudaError_enum_CUDA_ERROR_OPERATING_SYSTEM: cudaError_enum = 304;
#[doc = " This indicates that a resource handle passed to the API call was not"]
#[doc = " valid. Resource handles are opaque types like ::CUstream and ::CUevent."]
pub const cudaError_enum_CUDA_ERROR_INVALID_HANDLE: cudaError_enum = 400;
#[doc = " This indicates that a resource required by the API call is not in a"]
#[doc = " valid state to perform the requested operation."]
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_STATE: cudaError_enum = 401;
#[doc = " This indicates that a named symbol was not found. Examples of symbols"]
#[doc = " are global/constant variable names, driver function names, texture names,"]
#[doc = " and surface names."]
pub const cudaError_enum_CUDA_ERROR_NOT_FOUND: cudaError_enum = 500;
#[doc = " This indicates that asynchronous operations issued previously have not"]
#[doc = " completed yet. This result is not actually an error, but must be indicated"]
#[doc = " differently than ::CUDA_SUCCESS (which indicates completion). Calls that"]
#[doc = " may return this value include ::cuEventQuery() and ::cuStreamQuery()."]
pub const cudaError_enum_CUDA_ERROR_NOT_READY: cudaError_enum = 600;
#[doc = " While executing a kernel, the device encountered a"]
#[doc = " load or store instruction on an invalid memory address."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_ADDRESS: cudaError_enum = 700;
#[doc = " This indicates that a launch did not occur because it did not have"]
#[doc = " appropriate resources. This error usually indicates that the user has"]
#[doc = " attempted to pass too many arguments to the device kernel, or the"]
#[doc = " kernel launch specifies too many threads for the kernel's register"]
#[doc = " count. Passing arguments of the wrong size (i.e. a 64-bit pointer"]
#[doc = " when a 32-bit int is expected) is equivalent to passing too many"]
#[doc = " arguments and can also result in this error."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES: cudaError_enum = 701;
#[doc = " This indicates that the device kernel took too long to execute. This can"]
#[doc = " only occur if timeouts are enabled - see the device attribute"]
#[doc = " ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_TIMEOUT: cudaError_enum = 702;
#[doc = " This error indicates a kernel launch that uses an incompatible texturing"]
#[doc = " mode."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING: cudaError_enum = 703;
#[doc = " This error indicates that a call to ::cuCtxEnablePeerAccess() is"]
#[doc = " trying to re-enable peer access to a context which has already"]
#[doc = " had peer access to it enabled."]
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED: cudaError_enum = 704;
#[doc = " This error indicates that ::cuCtxDisablePeerAccess() is"]
#[doc = " trying to disable peer access which has not been enabled yet"]
#[doc = " via ::cuCtxEnablePeerAccess()."]
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_NOT_ENABLED: cudaError_enum = 705;
#[doc = " This error indicates that the primary context for the specified device"]
#[doc = " has already been initialized."]
pub const cudaError_enum_CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE: cudaError_enum = 708;
#[doc = " This error indicates that the context current to the calling thread"]
#[doc = " has been destroyed using ::cuCtxDestroy, or is a primary context which"]
#[doc = " has not yet been initialized."]
pub const cudaError_enum_CUDA_ERROR_CONTEXT_IS_DESTROYED: cudaError_enum = 709;
#[doc = " A device-side assert triggered during kernel execution. The context"]
#[doc = " cannot be used anymore, and must be destroyed. All existing device"]
#[doc = " memory allocations from this context are invalid and must be"]
#[doc = " reconstructed if the program is to continue using CUDA."]
pub const cudaError_enum_CUDA_ERROR_ASSERT: cudaError_enum = 710;
#[doc = " This error indicates that the hardware resources required to enable"]
#[doc = " peer access have been exhausted for one or more of the devices"]
#[doc = " passed to ::cuCtxEnablePeerAccess()."]
pub const cudaError_enum_CUDA_ERROR_TOO_MANY_PEERS: cudaError_enum = 711;
#[doc = " This error indicates that the memory range passed to ::cuMemHostRegister()"]
#[doc = " has already been registered."]
pub const cudaError_enum_CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED: cudaError_enum = 712;
#[doc = " This error indicates that the pointer passed to ::cuMemHostUnregister()"]
#[doc = " does not correspond to any currently registered memory region."]
pub const cudaError_enum_CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED: cudaError_enum = 713;
#[doc = " While executing a kernel, the device encountered a stack error."]
#[doc = " This can be due to stack corruption or exceeding the stack size limit."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_HARDWARE_STACK_ERROR: cudaError_enum = 714;
#[doc = " While executing a kernel, the device encountered an illegal instruction."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_INSTRUCTION: cudaError_enum = 715;
#[doc = " While executing a kernel, the device encountered a load or store instruction"]
#[doc = " on a memory address which is not aligned."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_MISALIGNED_ADDRESS: cudaError_enum = 716;
#[doc = " While executing a kernel, the device encountered an instruction"]
#[doc = " which can only operate on memory locations in certain address spaces"]
#[doc = " (global, shared, or local), but was supplied a memory address not"]
#[doc = " belonging to an allowed address space."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_INVALID_ADDRESS_SPACE: cudaError_enum = 717;
#[doc = " While executing a kernel, the device program counter wrapped its address space."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_INVALID_PC: cudaError_enum = 718;
#[doc = " An exception occurred on the device while executing a kernel. Common"]
#[doc = " causes include dereferencing an invalid device pointer and accessing"]
#[doc = " out of bounds shared memory. Less common cases can be system specific - more"]
#[doc = " information about these cases can be found in the system specific user guide."]
#[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
#[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
#[doc = " and relaunched."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_FAILED: cudaError_enum = 719;
#[doc = " This error indicates that the number of blocks launched per grid for a kernel that was"]
#[doc = " launched via either ::cuLaunchCooperativeKernel or ::cuLaunchCooperativeKernelMultiDevice"]
#[doc = " exceeds the maximum number of blocks as allowed by ::cuOccupancyMaxActiveBlocksPerMultiprocessor"]
#[doc = " or ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors"]
#[doc = " as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT."]
pub const cudaError_enum_CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE: cudaError_enum = 720;
#[doc = " This error indicates that the attempted operation is not permitted."]
pub const cudaError_enum_CUDA_ERROR_NOT_PERMITTED: cudaError_enum = 800;
#[doc = " This error indicates that the attempted operation is not supported"]
#[doc = " on the current system or device."]
pub const cudaError_enum_CUDA_ERROR_NOT_SUPPORTED: cudaError_enum = 801;
#[doc = " This error indicates that the system is not yet ready to start any CUDA"]
#[doc = " work.  To continue using CUDA, verify the system configuration is in a"]
#[doc = " valid state and all required driver daemons are actively running."]
#[doc = " More information about this error can be found in the system specific"]
#[doc = " user guide."]
pub const cudaError_enum_CUDA_ERROR_SYSTEM_NOT_READY: cudaError_enum = 802;
#[doc = " This error indicates that there is a mismatch between the versions of"]
#[doc = " the display driver and the CUDA driver. Refer to the compatibility documentation"]
#[doc = " for supported versions."]
pub const cudaError_enum_CUDA_ERROR_SYSTEM_DRIVER_MISMATCH: cudaError_enum = 803;
#[doc = " This error indicates that the system was upgraded to run with forward compatibility"]
#[doc = " but the visible hardware detected by CUDA does not support this configuration."]
#[doc = " Refer to the compatibility documentation for the supported hardware matrix or ensure"]
#[doc = " that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES"]
#[doc = " environment variable."]
pub const cudaError_enum_CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE: cudaError_enum = 804;
#[doc = " This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server."]
pub const cudaError_enum_CUDA_ERROR_MPS_CONNECTION_FAILED: cudaError_enum = 805;
#[doc = " This error indicates that the remote procedural call between the MPS server and the MPS client failed."]
pub const cudaError_enum_CUDA_ERROR_MPS_RPC_FAILURE: cudaError_enum = 806;
#[doc = " This error indicates that the MPS server is not ready to accept new MPS client requests."]
#[doc = " This error can be returned when the MPS server is in the process of recovering from a fatal failure."]
pub const cudaError_enum_CUDA_ERROR_MPS_SERVER_NOT_READY: cudaError_enum = 807;
#[doc = " This error indicates that the hardware resources required to create MPS client have been exhausted."]
pub const cudaError_enum_CUDA_ERROR_MPS_MAX_CLIENTS_REACHED: cudaError_enum = 808;
#[doc = " This error indicates the the hardware resources required to support device connections have been exhausted."]
pub const cudaError_enum_CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED: cudaError_enum = 809;
#[doc = " This error indicates that the operation is not permitted when"]
#[doc = " the stream is capturing."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED: cudaError_enum = 900;
#[doc = " This error indicates that the current capture sequence on the stream"]
#[doc = " has been invalidated due to a previous error."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_INVALIDATED: cudaError_enum = 901;
#[doc = " This error indicates that the operation would have resulted in a merge"]
#[doc = " of two independent capture sequences."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_MERGE: cudaError_enum = 902;
#[doc = " This error indicates that the capture was not initiated in this stream."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNMATCHED: cudaError_enum = 903;
#[doc = " This error indicates that the capture sequence contains a fork that was"]
#[doc = " not joined to the primary stream."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNJOINED: cudaError_enum = 904;
#[doc = " This error indicates that a dependency would have been created which"]
#[doc = " crosses the capture sequence boundary. Only implicit in-stream ordering"]
#[doc = " dependencies are allowed to cross the boundary."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_ISOLATION: cudaError_enum = 905;
#[doc = " This error indicates a disallowed implicit dependency on a current capture"]
#[doc = " sequence from cudaStreamLegacy."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_IMPLICIT: cudaError_enum = 906;
#[doc = " This error indicates that the operation is not permitted on an event which"]
#[doc = " was last recorded in a capturing stream."]
pub const cudaError_enum_CUDA_ERROR_CAPTURED_EVENT: cudaError_enum = 907;
#[doc = " A stream capture sequence not initiated with the ::CU_STREAM_CAPTURE_MODE_RELAXED"]
#[doc = " argument to ::cuStreamBeginCapture was passed to ::cuStreamEndCapture in a"]
#[doc = " different thread."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD: cudaError_enum = 908;
#[doc = " This error indicates that the timeout specified for the wait operation has lapsed."]
pub const cudaError_enum_CUDA_ERROR_TIMEOUT: cudaError_enum = 909;
#[doc = " This error indicates that the graph update was not performed because it included"]
#[doc = " changes which violated constraints specific to instantiated graph update."]
pub const cudaError_enum_CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE: cudaError_enum = 910;
#[doc = " This indicates that an unknown internal error has occurred."]
pub const cudaError_enum_CUDA_ERROR_UNKNOWN: cudaError_enum = 999;
#[doc = " Error codes"]
pub type cudaError_enum = ::std::os::raw::c_uint;
pub use self::cudaError_enum as CUresult;
#[doc = "< A relative value indicating the performance of the link between two devices"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK:
    CUdevice_P2PAttribute_enum = 1;
#[doc = "< P2P Access is enable"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 2;
#[doc = "< Atomic operation over the link supported"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED:
    CUdevice_P2PAttribute_enum = 3;
#[doc = "< \\deprecated use CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED instead"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 4;
#[doc = "< Accessing CUDA arrays over the link supported"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 4;
#[doc = " P2P Attributes"]
pub type CUdevice_P2PAttribute_enum = ::std::os::raw::c_uint;
pub use self::CUdevice_P2PAttribute_enum as CUdevice_P2PAttribute;
#[doc = " CUDA stream callback"]
#[doc = " \\param hStream The stream the callback was added to, as passed to ::cuStreamAddCallback.  May be NULL."]
#[doc = " \\param status ::CUDA_SUCCESS or any persistent error on the stream."]
#[doc = " \\param userData User parameter provided at registration."]
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        status: CUresult,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Block size to per-block dynamic shared memory mapping for a certain"]
#[doc = " kernel \\param blockSize Block size of the kernel."]
#[doc = ""]
#[doc = " \\return The dynamic shared memory needed by a block."]
pub type CUoccupancyB2DSize =
    ::std::option::Option<unsafe extern "C" fn(blockSize: ::std::os::raw::c_int) -> size_t>;
#[doc = " 2D memory copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY2D_st {
    #[doc = "< Source X in bytes"]
    pub srcXInBytes: size_t,
    #[doc = "< Source Y"]
    pub srcY: size_t,
    #[doc = "< Source memory type (host, device, array)"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer"]
    pub srcHost: *const ::std::os::raw::c_void,
    #[doc = "< Source device pointer"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference"]
    pub srcArray: CUarray,
    #[doc = "< Source pitch (ignored when src is array)"]
    pub srcPitch: size_t,
    #[doc = "< Destination X in bytes"]
    pub dstXInBytes: size_t,
    #[doc = "< Destination Y"]
    pub dstY: size_t,
    #[doc = "< Destination memory type (host, device, array)"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer"]
    pub dstHost: *mut ::std::os::raw::c_void,
    #[doc = "< Destination device pointer"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference"]
    pub dstArray: CUarray,
    #[doc = "< Destination pitch (ignored when dst is array)"]
    pub dstPitch: size_t,
    #[doc = "< Width of 2D memory copy in bytes"]
    pub WidthInBytes: size_t,
    #[doc = "< Height of 2D memory copy"]
    pub Height: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY2D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY2D_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY2D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcMemoryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcHost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcDevice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcArray as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcPitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstXInBytes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstY as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstMemoryType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstHost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstDevice as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstArray as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstPitch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).WidthInBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).Height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(Height)
        )
    );
}
pub type CUDA_MEMCPY2D_v2 = CUDA_MEMCPY2D_st;
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_v2;
#[doc = " 3D memory copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_st {
    #[doc = "< Source X in bytes"]
    pub srcXInBytes: size_t,
    #[doc = "< Source Y"]
    pub srcY: size_t,
    #[doc = "< Source Z"]
    pub srcZ: size_t,
    #[doc = "< Source LOD"]
    pub srcLOD: size_t,
    #[doc = "< Source memory type (host, device, array)"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer"]
    pub srcHost: *const ::std::os::raw::c_void,
    #[doc = "< Source device pointer"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference"]
    pub srcArray: CUarray,
    #[doc = "< Must be NULL"]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = "< Source pitch (ignored when src is array)"]
    pub srcPitch: size_t,
    #[doc = "< Source height (ignored when src is array; may be 0 if Depth==1)"]
    pub srcHeight: size_t,
    #[doc = "< Destination X in bytes"]
    pub dstXInBytes: size_t,
    #[doc = "< Destination Y"]
    pub dstY: size_t,
    #[doc = "< Destination Z"]
    pub dstZ: size_t,
    #[doc = "< Destination LOD"]
    pub dstLOD: size_t,
    #[doc = "< Destination memory type (host, device, array)"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer"]
    pub dstHost: *mut ::std::os::raw::c_void,
    #[doc = "< Destination device pointer"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference"]
    pub dstArray: CUarray,
    #[doc = "< Must be NULL"]
    pub reserved1: *mut ::std::os::raw::c_void,
    #[doc = "< Destination pitch (ignored when dst is array)"]
    pub dstPitch: size_t,
    #[doc = "< Destination height (ignored when dst is array; may be 0 if Depth==1)"]
    pub dstHeight: size_t,
    #[doc = "< Width of 3D memory copy in bytes"]
    pub WidthInBytes: size_t,
    #[doc = "< Height of 3D memory copy"]
    pub Height: size_t,
    #[doc = "< Depth of 3D memory copy"]
    pub Depth: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcLOD as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcMemoryType as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcHost as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcDevice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcArray as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).reserved0 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcPitch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcHeight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstXInBytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstY as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstZ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstLOD as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstMemoryType as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstHost as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstArray as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).reserved1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstPitch as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstHeight as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).WidthInBytes as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).Height as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).Depth as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Depth)
        )
    );
}
pub type CUDA_MEMCPY3D_v2 = CUDA_MEMCPY3D_st;
pub type CUDA_MEMCPY3D = CUDA_MEMCPY3D_v2;
#[doc = " 3D memory cross-context copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_PEER_st {
    #[doc = "< Source X in bytes"]
    pub srcXInBytes: size_t,
    #[doc = "< Source Y"]
    pub srcY: size_t,
    #[doc = "< Source Z"]
    pub srcZ: size_t,
    #[doc = "< Source LOD"]
    pub srcLOD: size_t,
    #[doc = "< Source memory type (host, device, array)"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer"]
    pub srcHost: *const ::std::os::raw::c_void,
    #[doc = "< Source device pointer"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference"]
    pub srcArray: CUarray,
    #[doc = "< Source context (ignored with srcMemoryType is ::CU_MEMORYTYPE_ARRAY)"]
    pub srcContext: CUcontext,
    #[doc = "< Source pitch (ignored when src is array)"]
    pub srcPitch: size_t,
    #[doc = "< Source height (ignored when src is array; may be 0 if Depth==1)"]
    pub srcHeight: size_t,
    #[doc = "< Destination X in bytes"]
    pub dstXInBytes: size_t,
    #[doc = "< Destination Y"]
    pub dstY: size_t,
    #[doc = "< Destination Z"]
    pub dstZ: size_t,
    #[doc = "< Destination LOD"]
    pub dstLOD: size_t,
    #[doc = "< Destination memory type (host, device, array)"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer"]
    pub dstHost: *mut ::std::os::raw::c_void,
    #[doc = "< Destination device pointer"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference"]
    pub dstArray: CUarray,
    #[doc = "< Destination context (ignored with dstMemoryType is ::CU_MEMORYTYPE_ARRAY)"]
    pub dstContext: CUcontext,
    #[doc = "< Destination pitch (ignored when dst is array)"]
    pub dstPitch: size_t,
    #[doc = "< Destination height (ignored when dst is array; may be 0 if Depth==1)"]
    pub dstHeight: size_t,
    #[doc = "< Width of 3D memory copy in bytes"]
    pub WidthInBytes: size_t,
    #[doc = "< Height of 3D memory copy"]
    pub Height: size_t,
    #[doc = "< Depth of 3D memory copy"]
    pub Depth: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_PEER_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_PEER_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_PEER_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcXInBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcLOD as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcMemoryType as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcHost as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcDevice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcArray as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcContext as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcPitch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcHeight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstXInBytes as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstY as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstZ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstLOD as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstMemoryType as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstHost as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstArray as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstContext as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstPitch as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstHeight as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).WidthInBytes as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).Height as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).Depth as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Depth)
        )
    );
}
pub type CUDA_MEMCPY3D_PEER_v1 = CUDA_MEMCPY3D_PEER_st;
pub type CUDA_MEMCPY3D_PEER = CUDA_MEMCPY3D_PEER_v1;
#[doc = " Array descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    #[doc = "< Width of array"]
    pub Width: size_t,
    #[doc = "< Height of array"]
    pub Height: size_t,
    #[doc = "< Array format"]
    pub Format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub NumChannels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).NumChannels as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
}
pub type CUDA_ARRAY_DESCRIPTOR_v2 = CUDA_ARRAY_DESCRIPTOR_st;
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_v2;
#[doc = " 3D array descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    #[doc = "< Width of 3D array"]
    pub Width: size_t,
    #[doc = "< Height of 3D array"]
    pub Height: size_t,
    #[doc = "< Depth of 3D array"]
    pub Depth: size_t,
    #[doc = "< Array format"]
    pub Format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub NumChannels: ::std::os::raw::c_uint,
    #[doc = "< Flags"]
    pub Flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY3D_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Format as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).NumChannels as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Flags)
        )
    );
}
pub type CUDA_ARRAY3D_DESCRIPTOR_v2 = CUDA_ARRAY3D_DESCRIPTOR_st;
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_v2;
#[doc = " CUDA array sparse properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    pub tileExtent: CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1,
    #[doc = " First mip level at which the mip tail begins."]
    pub miptailFirstLevel: ::std::os::raw::c_uint,
    #[doc = " Total size of the mip tail."]
    pub miptailSize: ::std::os::raw::c_ulonglong,
    #[doc = " Flags will either be zero or ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL"]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 {
    #[doc = "< Width of sparse tile in elements"]
    pub width: ::std::os::raw::c_uint,
    #[doc = "< Height of sparse tile in elements"]
    pub height: ::std::os::raw::c_uint,
    #[doc = "< Depth of sparse tile in elements"]
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>())).width
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>())).height
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>())).depth
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        48usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).tileExtent as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(tileExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).miptailFirstLevel
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailFirstLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).miptailSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).reserved as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_ARRAY_SPARSE_PROPERTIES_v1 = CUDA_ARRAY_SPARSE_PROPERTIES_st;
pub type CUDA_ARRAY_SPARSE_PROPERTIES = CUDA_ARRAY_SPARSE_PROPERTIES_v1;
#[doc = " CUDA Resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< CUDA array"]
    pub hArray: CUarray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>())).hArray
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< CUDA mipmapped array"]
    pub hMipmappedArray: CUmipmappedArray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>()))
                .hMipmappedArray as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: CUdeviceptr,
    #[doc = "< Array format"]
    pub format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>()))
                .numChannels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>()))
                .sizeInBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: CUdeviceptr,
    #[doc = "< Array format"]
    pub format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: size_t,
    #[doc = "< Height of the array in elements"]
    pub height: size_t,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .numChannels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .pitchInBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).mipmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).linear as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).pitch2D as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type CUDA_RESOURCE_DESC_v1 = CUDA_RESOURCE_DESC_st;
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_v1;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [CUaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: CUfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: CUfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_CUDA_TEXTURE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).addressMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).maxAnisotropy as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).mipmapFilterMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).mipmapLevelBias as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).minMipmapLevelClamp as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).maxMipmapLevelClamp as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).borderColor as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_TEXTURE_DESC_v1 = CUDA_TEXTURE_DESC_st;
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_v1;
#[doc = "< No resource view format (use underlying resource format)"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_NONE: CUresourceViewFormat_enum = 0;
#[doc = "< 1 channel unsigned 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X8: CUresourceViewFormat_enum = 1;
#[doc = "< 2 channel unsigned 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X8: CUresourceViewFormat_enum = 2;
#[doc = "< 4 channel unsigned 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X8: CUresourceViewFormat_enum = 3;
#[doc = "< 1 channel signed 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X8: CUresourceViewFormat_enum = 4;
#[doc = "< 2 channel signed 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X8: CUresourceViewFormat_enum = 5;
#[doc = "< 4 channel signed 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X8: CUresourceViewFormat_enum = 6;
#[doc = "< 1 channel unsigned 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X16: CUresourceViewFormat_enum = 7;
#[doc = "< 2 channel unsigned 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X16: CUresourceViewFormat_enum = 8;
#[doc = "< 4 channel unsigned 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X16: CUresourceViewFormat_enum = 9;
#[doc = "< 1 channel signed 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X16: CUresourceViewFormat_enum = 10;
#[doc = "< 2 channel signed 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X16: CUresourceViewFormat_enum = 11;
#[doc = "< 4 channel signed 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X16: CUresourceViewFormat_enum = 12;
#[doc = "< 1 channel unsigned 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X32: CUresourceViewFormat_enum = 13;
#[doc = "< 2 channel unsigned 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X32: CUresourceViewFormat_enum = 14;
#[doc = "< 4 channel unsigned 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X32: CUresourceViewFormat_enum = 15;
#[doc = "< 1 channel signed 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X32: CUresourceViewFormat_enum = 16;
#[doc = "< 2 channel signed 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X32: CUresourceViewFormat_enum = 17;
#[doc = "< 4 channel signed 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X32: CUresourceViewFormat_enum = 18;
#[doc = "< 1 channel 16-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_1X16: CUresourceViewFormat_enum = 19;
#[doc = "< 2 channel 16-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_2X16: CUresourceViewFormat_enum = 20;
#[doc = "< 4 channel 16-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_4X16: CUresourceViewFormat_enum = 21;
#[doc = "< 1 channel 32-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_1X32: CUresourceViewFormat_enum = 22;
#[doc = "< 2 channel 32-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_2X32: CUresourceViewFormat_enum = 23;
#[doc = "< 4 channel 32-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_4X32: CUresourceViewFormat_enum = 24;
#[doc = "< Block compressed 1"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC1: CUresourceViewFormat_enum = 25;
#[doc = "< Block compressed 2"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC2: CUresourceViewFormat_enum = 26;
#[doc = "< Block compressed 3"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC3: CUresourceViewFormat_enum = 27;
#[doc = "< Block compressed 4 unsigned"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC4: CUresourceViewFormat_enum = 28;
#[doc = "< Block compressed 4 signed"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC4: CUresourceViewFormat_enum = 29;
#[doc = "< Block compressed 5 unsigned"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC5: CUresourceViewFormat_enum = 30;
#[doc = "< Block compressed 5 signed"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC5: CUresourceViewFormat_enum = 31;
#[doc = "< Block compressed 6 unsigned half-float"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC6H: CUresourceViewFormat_enum =
    32;
#[doc = "< Block compressed 6 signed half-float"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC6H: CUresourceViewFormat_enum = 33;
#[doc = "< Block compressed 7"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC7: CUresourceViewFormat_enum = 34;
#[doc = " Resource view format"]
pub type CUresourceViewFormat_enum = ::std::os::raw::c_uint;
pub use self::CUresourceViewFormat_enum as CUresourceViewFormat;
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: CUresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: size_t,
    #[doc = "< Height of the resource view"]
    pub height: size_t,
    #[doc = "< Depth of the resource view"]
    pub depth: size_t,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_VIEW_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).format as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).depth as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).firstMipmapLevel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).lastMipmapLevel as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).firstLayer as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).lastLayer as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).reserved as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_RESOURCE_VIEW_DESC_v1 = CUDA_RESOURCE_VIEW_DESC_st;
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_v1;
#[doc = " GPU Direct v3 tokens"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    pub p2pToken: ::std::os::raw::c_ulonglong,
    pub vaSpaceToken: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>())).p2pToken as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(p2pToken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>())).vaSpaceToken
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(vaSpaceToken)
        )
    );
}
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st;
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
#[doc = "< No access, meaning the device cannot access this memory at all, thus must be staged through accessible memory in order to complete certain operations"]
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 0;
#[doc = "< Read-only access, meaning writes to this memory are considered invalid accesses and thus return error in that case."]
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 1;
#[doc = "< Read-write access, the device has full read-write access to the memory"]
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 3;
#[doc = " Access flags that specify the level of access the current context's device has"]
#[doc = " on the memory referenced."]
pub type CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = ::std::os::raw::c_uint;
pub use self::CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum as CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;
#[doc = " Kernel launch parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_LAUNCH_PARAMS_st {
    #[doc = "< Kernel to launch"]
    pub function: CUfunction,
    #[doc = "< Width of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Stream identifier"]
    pub hStream: CUstream,
    #[doc = "< Array of pointers to kernel parameters"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_LAUNCH_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_LAUNCH_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_LAUNCH_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimX as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimZ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).sharedMemBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).hStream as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).kernelParams as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
}
pub type CUDA_LAUNCH_PARAMS_v1 = CUDA_LAUNCH_PARAMS_st;
pub type CUDA_LAUNCH_PARAMS = CUDA_LAUNCH_PARAMS_v1;
#[doc = " Handle is an opaque file descriptor"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD:
    CUexternalMemoryHandleType_enum = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32:
    CUexternalMemoryHandleType_enum = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT:
    CUexternalMemoryHandleType_enum = 3;
#[doc = " Handle is a D3D12 heap object"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP:
    CUexternalMemoryHandleType_enum = 4;
#[doc = " Handle is a D3D12 committed resource"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE:
    CUexternalMemoryHandleType_enum = 5;
#[doc = " Handle is a shared NT handle to a D3D11 resource"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE:
    CUexternalMemoryHandleType_enum = 6;
#[doc = " Handle is a globally shared handle to a D3D11 resource"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT:
    CUexternalMemoryHandleType_enum = 7;
#[doc = " Handle is an NvSciBuf object"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF:
    CUexternalMemoryHandleType_enum = 8;
#[doc = " External memory handle types"]
pub type CUexternalMemoryHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[doc = " External memory handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    #[doc = " Type of the handle"]
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    #[doc = " Size of the memory allocation"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags must either be zero or ::CUDA_EXTERNAL_MEMORY_DEDICATED"]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    #[doc = " File descriptor referencing the memory object. Valid"]
    #[doc = " when type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD"]
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    #[doc = " A handle representing an NvSciBuf Object. Valid when type"]
    #[doc = " is ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF"]
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when"]
#[doc = " type is one of the following:"]
#[doc = " - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32"]
#[doc = " - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT"]
#[doc = " - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP"]
#[doc = " - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE"]
#[doc = " - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE"]
#[doc = " - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT"]
#[doc = " Exactly one of 'handle' and 'name' must be non-NULL. If"]
#[doc = " type is one of the following:"]
#[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT"]
#[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT"]
#[doc = " then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid memory object."]
    #[doc = " Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
            )))
            .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
            )))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>())).fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>()))
                .nvSciBufObject as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciBufObject)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).handle as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).size as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).flags as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).reserved as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
#[doc = " External memory buffer descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    #[doc = " Offset into the memory object where the buffer's base is"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Size of the buffer"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags reserved for future use. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).reserved as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
#[doc = " External memory mipmap descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    #[doc = " Offset into the memory object where the base level of the"]
    #[doc = " mipmap chain is."]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Format, dimension and type of base level of the mipmap chain"]
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    #[doc = " Total number of levels in the mipmap chain"]
    pub numLevels: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).offset
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).arrayDesc
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(arrayDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).numLevels
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).reserved
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 =
    CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
#[doc = " Handle is an opaque file descriptor"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD:
    CUexternalSemaphoreHandleType_enum = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32:
    CUexternalSemaphoreHandleType_enum = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT:
    CUexternalSemaphoreHandleType_enum = 3;
#[doc = " Handle is a shared NT handle referencing a D3D12 fence object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE:
    CUexternalSemaphoreHandleType_enum = 4;
#[doc = " Handle is a shared NT handle referencing a D3D11 fence object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE:
    CUexternalSemaphoreHandleType_enum = 5;
#[doc = " Opaque handle to NvSciSync Object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC:
    CUexternalSemaphoreHandleType_enum = 6;
#[doc = " Handle is a shared NT handle referencing a D3D11 keyed mutex object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX:
    CUexternalSemaphoreHandleType_enum = 7;
#[doc = " Handle is a globally shared handle referencing a D3D11 keyed mutex object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT : CUexternalSemaphoreHandleType_enum = 8 ;
#[doc = " Handle is an opaque file descriptor referencing a timeline semaphore"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD : CUexternalSemaphoreHandleType_enum = 9 ;
#[doc = " Handle is an opaque shared NT handle referencing a timeline semaphore"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 : CUexternalSemaphoreHandleType_enum = 10 ;
#[doc = " External semaphore handle types"]
pub type CUexternalSemaphoreHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[doc = " External semaphore handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    #[doc = " Type of the handle"]
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    #[doc = " Flags reserved for the future. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    #[doc = " File descriptor referencing the semaphore object. Valid"]
    #[doc = " when type is one of the following:"]
    #[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD"]
    #[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD"]
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Valid NvSciSyncObj. Must be non NULL"]
    pub nvSciSyncObj: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when"]
#[doc = " type is one of the following:"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32"]
#[doc = " Exactly one of 'handle' and 'name' must be non-NULL. If"]
#[doc = " type is one of the following:"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT"]
#[doc = " - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT"]
#[doc = " then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid synchronization primitive."]
    #[doc = " Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>())).fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>()))
                .nvSciSyncObj as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSyncObj)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).handle as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).flags as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).reserved as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
#[doc = " External semaphore signal parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    #[doc = " Only when ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS is used to"]
    #[doc = " signal a ::CUexternalSemaphore of type"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, the valid flag is"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC which indicates"]
    #[doc = " that while signaling the ::CUexternalSemaphore, no memory synchronization"]
    #[doc = " operations should be performed for any external memory object imported"]
    #[doc = " as ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF."]
    #[doc = " For all other types of ::CUexternalSemaphore, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be signaled"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::CUexternalSemaphoreHandleType"]
    #[doc = " is of type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .fence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to release the mutex with"]
    pub key: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
            >()))
            .key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>()))
                .nvSciSync as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>()))
                .keyedMutex as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>()))
                .reserved as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).flags as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).reserved
                as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
#[doc = " External semaphore wait parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
    #[doc = " Only when ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS is used to wait on"]
    #[doc = " a ::CUexternalSemaphore of type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC,"]
    #[doc = " the valid flag is ::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC"]
    #[doc = " which indicates that while waiting for the ::CUexternalSemaphore, no memory"]
    #[doc = " synchronization operations should be performed for any external memory"]
    #[doc = " object imported as ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF."]
    #[doc = " For all other types of ::CUexternalSemaphore, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be waited on"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Pointer to NvSciSyncFence. Valid if CUexternalSemaphoreHandleType"]
#[doc = " is of type CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .fence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to acquire the mutex with"]
    pub key: ::std::os::raw::c_ulonglong,
    #[doc = " Timeout in milliseconds to wait to acquire the mutex"]
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
            >()))
            .key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
            >()))
            .timeoutMs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(timeoutMs)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>()))
                .nvSciSync as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>()))
                .keyedMutex as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>()))
                .reserved as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).flags as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).reserved as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
#[doc = " Semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore signal parameters."]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>())).extSemArray as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>())).paramsArray as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>())).numExtSems as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
#[doc = " Semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore wait parameters."]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_WAIT_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>())).extSemArray as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>())).paramsArray as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>())).numExtSems as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
pub type CUmemGenericAllocationHandle_v1 = ::std::os::raw::c_ulonglong;
pub type CUmemGenericAllocationHandle = CUmemGenericAllocationHandle_v1;
#[doc = "< Does not allow any export mechanism. >"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_NONE: CUmemAllocationHandleType_enum =
    0;
#[doc = "< Allows a file descriptor to be used for exporting. Permitted only on POSIX systems. (int)"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR:
    CUmemAllocationHandleType_enum = 1;
#[doc = "< Allows a Win32 NT handle to be used for exporting. (HANDLE)"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_WIN32: CUmemAllocationHandleType_enum =
    2;
#[doc = "< Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_WIN32_KMT:
    CUmemAllocationHandleType_enum = 4;
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_MAX: CUmemAllocationHandleType_enum =
    2147483647;
#[doc = " Flags for specifying particular handle types"]
pub type CUmemAllocationHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationHandleType_enum as CUmemAllocationHandleType;
#[doc = "< Default, make the address range not accessible"]
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_NONE: CUmemAccess_flags_enum = 0;
#[doc = "< Make the address range read accessible"]
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_READ: CUmemAccess_flags_enum = 1;
#[doc = "< Make the address range read-write accessible"]
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_READWRITE: CUmemAccess_flags_enum = 3;
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_MAX: CUmemAccess_flags_enum = 2147483647;
#[doc = " Specifies the memory protection flags for mapping."]
pub type CUmemAccess_flags_enum = ::std::os::raw::c_uint;
pub use self::CUmemAccess_flags_enum as CUmemAccess_flags;
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_INVALID: CUmemLocationType_enum = 0;
#[doc = "< Location is a device location, thus id is a device ordinal"]
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_DEVICE: CUmemLocationType_enum = 1;
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_MAX: CUmemLocationType_enum = 2147483647;
#[doc = " Specifies the type of location"]
pub type CUmemLocationType_enum = ::std::os::raw::c_uint;
pub use self::CUmemLocationType_enum as CUmemLocationType;
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_INVALID: CUmemAllocationType_enum = 0;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current"]
#[doc = " location while the application is actively using it"]
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_PINNED: CUmemAllocationType_enum = 1;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current"]
#[doc = " location while the application is actively using it"]
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_MAX: CUmemAllocationType_enum =
    2147483647;
#[doc = " Defines the allocation types available"]
pub type CUmemAllocationType_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationType_enum as CUmemAllocationType;
#[doc = "< Minimum required granularity for allocation"]
pub const CUmemAllocationGranularity_flags_enum_CU_MEM_ALLOC_GRANULARITY_MINIMUM:
    CUmemAllocationGranularity_flags_enum = 0;
#[doc = "< Recommended granularity for allocation for best performance"]
pub const CUmemAllocationGranularity_flags_enum_CU_MEM_ALLOC_GRANULARITY_RECOMMENDED:
    CUmemAllocationGranularity_flags_enum = 1;
#[doc = " Flag for requesting different optimal and required granularities for an allocation."]
pub type CUmemAllocationGranularity_flags_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationGranularity_flags_enum as CUmemAllocationGranularity_flags;
pub const CUarraySparseSubresourceType_enum_CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL:
    CUarraySparseSubresourceType_enum = 0;
pub const CUarraySparseSubresourceType_enum_CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL:
    CUarraySparseSubresourceType_enum = 1;
#[doc = " Sparse subresource types"]
pub type CUarraySparseSubresourceType_enum = ::std::os::raw::c_uint;
pub use self::CUarraySparseSubresourceType_enum as CUarraySparseSubresourceType;
pub const CUmemOperationType_enum_CU_MEM_OPERATION_TYPE_MAP: CUmemOperationType_enum = 1;
pub const CUmemOperationType_enum_CU_MEM_OPERATION_TYPE_UNMAP: CUmemOperationType_enum = 2;
#[doc = " Memory operation types"]
pub type CUmemOperationType_enum = ::std::os::raw::c_uint;
pub use self::CUmemOperationType_enum as CUmemOperationType;
pub const CUmemHandleType_enum_CU_MEM_HANDLE_TYPE_GENERIC: CUmemHandleType_enum = 0;
#[doc = " Memory handle types"]
pub type CUmemHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUmemHandleType_enum as CUmemHandleType;
#[doc = " Specifies the CUDA array or CUDA mipmapped array memory mapping information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUarrayMapInfo_st {
    #[doc = "< Resource type"]
    pub resourceType: CUresourcetype,
    pub resource: CUarrayMapInfo_st__bindgen_ty_1,
    #[doc = "< Sparse subresource type"]
    pub subresourceType: CUarraySparseSubresourceType,
    pub subresource: CUarrayMapInfo_st__bindgen_ty_2,
    #[doc = "< Memory operation type"]
    pub memOperationType: CUmemOperationType,
    #[doc = "< Memory handle type"]
    pub memHandleType: CUmemHandleType,
    pub memHandle: CUarrayMapInfo_st__bindgen_ty_3,
    #[doc = "< Offset within the memory"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Device ordinal bit mask"]
    pub deviceBitMask: ::std::os::raw::c_uint,
    #[doc = "< flags for future use, must be zero now."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use, must be zero now."]
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_1 {
    pub mipmap: CUmipmappedArray,
    pub array: CUarray,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_1>())).mipmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_1>())).array as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_2 {
    pub sparseLevel: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1,
    pub miptail: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< For CUDA mipmapped arrays must a valid mipmap level. For CUDA arrays must be zero"]
    pub level: ::std::os::raw::c_uint,
    #[doc = "< For CUDA layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< Starting X offset in elements"]
    pub offsetX: ::std::os::raw::c_uint,
    #[doc = "< Starting Y offset in elements"]
    pub offsetY: ::std::os::raw::c_uint,
    #[doc = "< Starting Z offset in elements"]
    pub offsetZ: ::std::os::raw::c_uint,
    #[doc = "< Width in elements"]
    pub extentWidth: ::std::os::raw::c_uint,
    #[doc = "< Height in elements"]
    pub extentHeight: ::std::os::raw::c_uint,
    #[doc = "< Depth in elements"]
    pub extentDepth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).level
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).layer
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).offsetX
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).offsetY
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).offsetZ
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).extentWidth
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).extentHeight
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).extentDepth
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentDepth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< For CUDA layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< Offset within mip tail"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Extent in bytes"]
    pub size: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>())).layer
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>())).offset
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>())).size
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2>())).sparseLevel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(sparseLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2>())).miptail as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(miptail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_3 {
    pub memHandle: CUmemGenericAllocationHandle,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_3>())).memHandle as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_3),
            "::",
            stringify!(memHandle)
        )
    );
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st>(),
        96usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).resourceType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).resource as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st>())).subresourceType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresourceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).subresource as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st>())).memOperationType as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memOperationType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).memHandleType as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandleType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).memHandle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).offset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).deviceBitMask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(deviceBitMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).flags as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).reserved as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUarrayMapInfo_v1 = CUarrayMapInfo_st;
pub type CUarrayMapInfo = CUarrayMapInfo_v1;
#[doc = " Specifies a memory location."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemLocation_st {
    #[doc = "< Specifies the location type, which modifies the meaning of id."]
    pub type_: CUmemLocationType,
    #[doc = "< identifier for a given this location's ::CUmemLocationType."]
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUmemLocation_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemLocation_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemLocation_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemLocation_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemLocation_st>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(id)
        )
    );
}
pub type CUmemLocation_v1 = CUmemLocation_st;
pub type CUmemLocation = CUmemLocation_v1;
#[doc = "< Allocating non-compressible memory"]
pub const CUmemAllocationCompType_enum_CU_MEM_ALLOCATION_COMP_NONE: CUmemAllocationCompType_enum =
    0;
#[doc = "< Allocating  compressible memory"]
pub const CUmemAllocationCompType_enum_CU_MEM_ALLOCATION_COMP_GENERIC:
    CUmemAllocationCompType_enum = 1;
#[doc = " Specifies compression attribute for an allocation."]
pub type CUmemAllocationCompType_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationCompType_enum as CUmemAllocationCompType;
#[doc = " Specifies the allocation properties for a allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st {
    #[doc = " Allocation type"]
    pub type_: CUmemAllocationType,
    #[doc = " requested ::CUmemAllocationHandleType"]
    pub requestedHandleTypes: CUmemAllocationHandleType,
    #[doc = " Location of allocation"]
    pub location: CUmemLocation,
    #[doc = " Windows-specific POBJECT_ATTRIBUTES required when"]
    #[doc = " ::CU_MEM_HANDLE_TYPE_WIN32 is specified.  This object atributes structure"]
    #[doc = " includes security attributes that define"]
    #[doc = " the scope of which exported allocations may be tranferred to other"]
    #[doc = " processes.  In all other cases, this field is required to be zero."]
    pub win32HandleMetaData: *mut ::std::os::raw::c_void,
    pub allocFlags: CUmemAllocationProp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st__bindgen_ty_1 {
    #[doc = " Allocation hint for requesting compressible memory."]
    #[doc = " On devices that support Compute Data Compression, compressible"]
    #[doc = " memory can be used to accelerate accesses to data with unstructured"]
    #[doc = " sparsity and other compressible data patterns. Applications are"]
    #[doc = " expected to query allocation property of the handle obtained with"]
    #[doc = " ::cuMemCreate using ::cuMemGetAllocationPropertiesFromHandle to"]
    #[doc = " validate if the obtained allocation is compressible or not. Note that"]
    #[doc = " compressed memory may not be mappable on all devices."]
    pub compressionType: ::std::os::raw::c_uchar,
    pub gpuDirectRDMACapable: ::std::os::raw::c_uchar,
    #[doc = " Bitmask indicating intended usage for this allocation"]
    pub usage: ::std::os::raw::c_ushort,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).compressionType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(compressionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).gpuDirectRDMACapable
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(gpuDirectRDMACapable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).usage as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAllocationProp_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st>())).requestedHandleTypes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(requestedHandleTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAllocationProp_st>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st>())).win32HandleMetaData as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(win32HandleMetaData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st>())).allocFlags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(allocFlags)
        )
    );
}
pub type CUmemAllocationProp_v1 = CUmemAllocationProp_st;
pub type CUmemAllocationProp = CUmemAllocationProp_v1;
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAccessDesc_st {
    #[doc = "< Location on which the request is to change it's accessibility"]
    pub location: CUmemLocation,
    #[doc = "< ::CUmemProt accessibility flags to set on the request"]
    pub flags: CUmemAccess_flags,
}
#[test]
fn bindgen_test_layout_CUmemAccessDesc_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAccessDesc_st>(),
        12usize,
        concat!("Size of: ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAccessDesc_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAccessDesc_st>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAccessDesc_st>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type CUmemAccessDesc_v1 = CUmemAccessDesc_st;
pub type CUmemAccessDesc = CUmemAccessDesc_v1;
#[doc = "< The update succeeded"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_SUCCESS: CUgraphExecUpdateResult_enum =
    0;
#[doc = "< The update failed for an unexpected reason which is described in the return value of the function"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR: CUgraphExecUpdateResult_enum = 1;
#[doc = "< The update failed because the topology changed"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED:
    CUgraphExecUpdateResult_enum = 2;
#[doc = "< The update failed because a node type changed"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED:
    CUgraphExecUpdateResult_enum = 3;
#[doc = "< The update failed because the function of a kernel node changed (CUDA driver < 11.2)"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED:
    CUgraphExecUpdateResult_enum = 4;
#[doc = "< The update failed because the parameters changed in a way that is not supported"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED:
    CUgraphExecUpdateResult_enum = 5;
#[doc = "< The update failed because something about the node is not supported"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED:
    CUgraphExecUpdateResult_enum = 6;
#[doc = "< The update failed because the function of a kernel node changed in an unsupported way"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE:
    CUgraphExecUpdateResult_enum = 7;
pub type CUgraphExecUpdateResult_enum = ::std::os::raw::c_uint;
pub use self::CUgraphExecUpdateResult_enum as CUgraphExecUpdateResult;
#[doc = " (value type = int)"]
#[doc = " Allow cuMemAllocAsync to use memory asynchronously freed"]
#[doc = " in another streams as long as a stream ordering dependency"]
#[doc = " of the allocating stream on the free action exists."]
#[doc = " Cuda events and null stream interactions can create the required"]
#[doc = " stream ordered dependencies. (default enabled)"]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES:
    CUmemPool_attribute_enum = 1;
#[doc = " (value type = int)"]
#[doc = " Allow reuse of already completed frees when there is no dependency"]
#[doc = " between the free and allocation. (default enabled)"]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC:
    CUmemPool_attribute_enum = 2;
#[doc = " (value type = int)"]
#[doc = " Allow cuMemAllocAsync to insert new stream dependencies"]
#[doc = " in order to establish the stream ordering required to reuse"]
#[doc = " a piece of memory released by cuFreeAsync (default enabled)."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES:
    CUmemPool_attribute_enum = 3;
#[doc = " (value type = cuuint64_t)"]
#[doc = " Amount of reserved memory in bytes to hold onto before trying"]
#[doc = " to release memory back to the OS. When more than the release"]
#[doc = " threshold bytes of memory are held by the memory pool, the"]
#[doc = " allocator will try to release memory back to the OS on the"]
#[doc = " next call to stream, event or context synchronize. (default 0)"]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: CUmemPool_attribute_enum = 4;
#[doc = " (value type = cuuint64_t)"]
#[doc = " Amount of backing memory currently allocated for the mempool."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT: CUmemPool_attribute_enum =
    5;
#[doc = " (value type = cuuint64_t)"]
#[doc = " High watermark of backing memory allocated for the mempool since the"]
#[doc = " last time it was reset. High watermark can only be reset to zero."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: CUmemPool_attribute_enum = 6;
#[doc = " (value type = cuuint64_t)"]
#[doc = " Amount of memory from the pool that is currently in use by the application."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_USED_MEM_CURRENT: CUmemPool_attribute_enum = 7;
#[doc = " (value type = cuuint64_t)"]
#[doc = " High watermark of the amount of memory from the pool that was in use by the application since"]
#[doc = " the last time it was reset. High watermark can only be reset to zero."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_USED_MEM_HIGH: CUmemPool_attribute_enum = 8;
#[doc = " CUDA memory pool attributes"]
pub type CUmemPool_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUmemPool_attribute_enum as CUmemPool_attribute;
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUmemPoolProps_st {
    #[doc = "< Allocation type. Currently must be specified as CU_MEM_ALLOCATION_TYPE_PINNED"]
    pub allocType: CUmemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool."]
    pub handleTypes: CUmemAllocationHandleType,
    #[doc = "< Location where allocations should reside."]
    pub location: CUmemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when"]
    #[doc = " ::CU_MEM_HANDLE_TYPE_WIN32 is specified.  This security attribute defines"]
    #[doc = " the scope of which exported allocations may be tranferred to other"]
    #[doc = " processes.  In all other cases, this field is required to be zero."]
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    #[doc = "< reserved for future use, must be 0"]
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolProps_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolProps_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolProps_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).allocType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(allocType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).handleTypes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemPoolProps_st>())).win32SecurityAttributes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(win32SecurityAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUmemPoolProps_v1 = CUmemPoolProps_st;
pub type CUmemPoolProps = CUmemPoolProps_v1;
#[doc = " Opaque data for exporting a pool allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUmemPoolPtrExportData_st {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolPtrExportData_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolPtrExportData_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolPtrExportData_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemPoolPtrExportData_st>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolPtrExportData_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUmemPoolPtrExportData_v1 = CUmemPoolPtrExportData_st;
pub type CUmemPoolPtrExportData = CUmemPoolPtrExportData_v1;
#[doc = " Memory allocation node parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_st {
    #[doc = " in: location where the allocation should reside (specified in ::location)."]
    #[doc = " ::handleTypes must be ::CU_MEM_HANDLE_TYPE_NONE. IPC is not supported."]
    pub poolProps: CUmemPoolProps,
    #[doc = "< in: array of memory access descriptors. Used to describe peer GPU access"]
    pub accessDescs: *const CUmemAccessDesc,
    #[doc = "< in: number of memory access descriptors.  Must not exceed the number of GPUs."]
    pub accessDescCount: size_t,
    #[doc = "< in: size in bytes of the requested allocation"]
    pub bytesize: size_t,
    #[doc = "< out: address of the allocation returned by CUDA"]
    pub dptr: CUdeviceptr,
}
#[test]
fn bindgen_test_layout_CUDA_MEM_ALLOC_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        120usize,
        concat!("Size of: ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).poolProps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).accessDescs as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).accessDescCount as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).bytesize as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).dptr as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(dptr)
        )
    );
}
pub type CUDA_MEM_ALLOC_NODE_PARAMS = CUDA_MEM_ALLOC_NODE_PARAMS_st;
#[doc = " (value type = cuuint64_t)"]
#[doc = " Amount of memory, in bytes, currently associated with graphs"]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT: CUgraphMem_attribute_enum =
    0;
#[doc = " (value type = cuuint64_t)"]
#[doc = " High watermark of memory, in bytes, associated with graphs since the"]
#[doc = " last time it was reset.  High watermark can only be reset to zero."]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: CUgraphMem_attribute_enum = 1;
#[doc = " (value type = cuuint64_t)"]
#[doc = " Amount of memory, in bytes, currently allocated for use by"]
#[doc = " the CUDA graphs asynchronous allocator."]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT:
    CUgraphMem_attribute_enum = 2;
#[doc = " (value type = cuuint64_t)"]
#[doc = " High watermark of memory, in bytes, currently allocated for use by"]
#[doc = " the CUDA graphs asynchronous allocator."]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: CUgraphMem_attribute_enum =
    3;
pub type CUgraphMem_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUgraphMem_attribute_enum as CUgraphMem_attribute;
#[doc = "< ::cuFlushGPUDirectRDMAWrites() and its CUDA Runtime API counterpart are supported on the device."]
pub const CUflushGPUDirectRDMAWritesOptions_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST:
    CUflushGPUDirectRDMAWritesOptions_enum = 1;
#[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device."]
pub const CUflushGPUDirectRDMAWritesOptions_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS:
    CUflushGPUDirectRDMAWritesOptions_enum = 2;
#[doc = " Bitmasks for ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS"]
pub type CUflushGPUDirectRDMAWritesOptions_enum = ::std::os::raw::c_uint;
pub use self::CUflushGPUDirectRDMAWritesOptions_enum as CUflushGPUDirectRDMAWritesOptions;
#[doc = "< The device does not natively support ordering of remote writes. ::cuFlushGPUDirectRDMAWrites() can be leveraged if supported."]
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE:
    CUGPUDirectRDMAWritesOrdering_enum = 0;
#[doc = "< Natively, the device can consistently consume remote writes, although other CUDA devices may not."]
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER:
    CUGPUDirectRDMAWritesOrdering_enum = 100;
#[doc = "< Any CUDA device in the system can consistently consume remote writes to this device."]
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES:
    CUGPUDirectRDMAWritesOrdering_enum = 200;
#[doc = " Platform native ordering for GPUDirect RDMA writes"]
pub type CUGPUDirectRDMAWritesOrdering_enum = ::std::os::raw::c_uint;
pub use self::CUGPUDirectRDMAWritesOrdering_enum as CUGPUDirectRDMAWritesOrdering;
#[doc = "< Blocks until remote writes are visible to the CUDA device context owning the data."]
pub const CUflushGPUDirectRDMAWritesScope_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER:
    CUflushGPUDirectRDMAWritesScope_enum = 100;
#[doc = "< Blocks until remote writes are visible to all CUDA device contexts."]
pub const CUflushGPUDirectRDMAWritesScope_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES:
    CUflushGPUDirectRDMAWritesScope_enum = 200;
#[doc = " The scopes for ::cuFlushGPUDirectRDMAWrites"]
pub type CUflushGPUDirectRDMAWritesScope_enum = ::std::os::raw::c_uint;
pub use self::CUflushGPUDirectRDMAWritesScope_enum as CUflushGPUDirectRDMAWritesScope;
#[doc = "< Sets the target for ::cuFlushGPUDirectRDMAWrites() to the currently active CUDA device context."]
pub const CUflushGPUDirectRDMAWritesTarget_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX : CUflushGPUDirectRDMAWritesTarget_enum = 0 ;
#[doc = " The targets for ::cuFlushGPUDirectRDMAWrites"]
pub type CUflushGPUDirectRDMAWritesTarget_enum = ::std::os::raw::c_uint;
pub use self::CUflushGPUDirectRDMAWritesTarget_enum as CUflushGPUDirectRDMAWritesTarget;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE: CUgraphDebugDot_flags_enum =
    1;
#[doc = " Output all debug data as if every debug flag is enabled"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES:
    CUgraphDebugDot_flags_enum = 2;
#[doc = " Use CUDA Runtime structures for output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 4;
#[doc = " Adds CUDA_KERNEL_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 8;
#[doc = " Adds CUDA_MEMCPY3D values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 16;
#[doc = " Adds CUDA_MEMSET_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 32;
#[doc = " Adds CUDA_HOST_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 64;
#[doc = " Adds CUevent handle from record and wait nodes to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 128;
#[doc = " Adds CUDA_EXT_SEM_SIGNAL_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 256;
#[doc = " Adds CUDA_EXT_SEM_WAIT_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES:
    CUgraphDebugDot_flags_enum = 512;
#[doc = " Adds CUkernelNodeAttrValue values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES: CUgraphDebugDot_flags_enum =
    1024;
#[doc = " Adds node handles and every kernel function handle to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 2048;
#[doc = " Adds memory alloc node parameters to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 4096;
#[doc = " The additional write options for ::cuGraphDebugDotPrint"]
pub type CUgraphDebugDot_flags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphDebugDot_flags_enum as CUgraphDebugDot_flags;
#[doc = "< Indicates the destructor execution is not synchronized by any CUDA handle."]
pub const CUuserObject_flags_enum_CU_USER_OBJECT_NO_DESTRUCTOR_SYNC: CUuserObject_flags_enum = 1;
#[doc = " Flags for user objects for graphs"]
pub type CUuserObject_flags_enum = ::std::os::raw::c_uint;
pub use self::CUuserObject_flags_enum as CUuserObject_flags;
#[doc = "< Transfer references from the caller rather than creating new references."]
pub const CUuserObjectRetain_flags_enum_CU_GRAPH_USER_OBJECT_MOVE: CUuserObjectRetain_flags_enum =
    1;
#[doc = " Flags for retaining user object references for graphs"]
pub type CUuserObjectRetain_flags_enum = ::std::os::raw::c_uint;
pub use self::CUuserObjectRetain_flags_enum as CUuserObjectRetain_flags;
#[doc = "< Automatically free memory allocated in a graph before relaunching."]
pub const CUgraphInstantiate_flags_enum_CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH:
    CUgraphInstantiate_flags_enum = 1;
#[doc = " Flags for instantiating a graph"]
pub type CUgraphInstantiate_flags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphInstantiate_flags_enum as CUgraphInstantiate_flags;
extern "C" {
    #[doc = " \\brief Gets the string description of an error code"]
    #[doc = ""]
    #[doc = " Sets \\p *pStr to the address of a NULL-terminated string description"]
    #[doc = " of the error code \\p error."]
    #[doc = " If the error code is not recognized, ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " will be returned and \\p *pStr will be set to the NULL address."]
    #[doc = ""]
    #[doc = " \\param error - Error code to convert to string"]
    #[doc = " \\param pStr - Address of the string pointer."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUresult,"]
    #[doc = " ::cudaGetErrorString"]
    pub fn cuGetErrorString(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the string representation of an error code enum name"]
    #[doc = ""]
    #[doc = " Sets \\p *pStr to the address of a NULL-terminated string representation"]
    #[doc = " of the name of the enum error code \\p error."]
    #[doc = " If the error code is not recognized, ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " will be returned and \\p *pStr will be set to the NULL address."]
    #[doc = ""]
    #[doc = " \\param error - Error code to convert to string"]
    #[doc = " \\param pStr - Address of the string pointer."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUresult,"]
    #[doc = " ::cudaGetErrorName"]
    pub fn cuGetErrorName(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Initialize the CUDA driver API"]
    #[doc = ""]
    #[doc = " Initializes the driver API and must be called before any other function from"]
    #[doc = " the driver API. Currently, the \\p Flags parameter must be 0. If ::cuInit()"]
    #[doc = " has not been called, any function from the driver API will return"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = " \\param Flags - Initialization flag for CUDA."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_SYSTEM_DRIVER_MISMATCH,"]
    #[doc = " ::CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE"]
    #[doc = " \\notefnerr"]
    pub fn cuInit(Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the latest CUDA version supported by driver"]
    #[doc = ""]
    #[doc = " Returns in \\p *driverVersion the version of CUDA supported by"]
    #[doc = " the driver.  The version is returned as"]
    #[doc = " (1000 &times; major + 10 &times; minor). For example, CUDA 9.2"]
    #[doc = " would be represented by 9020."]
    #[doc = ""]
    #[doc = " This function automatically returns ::CUDA_ERROR_INVALID_VALUE if"]
    #[doc = " \\p driverVersion is NULL."]
    #[doc = ""]
    #[doc = " \\param driverVersion - Returns the CUDA driver version"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cudaDriverGetVersion,"]
    #[doc = " ::cudaRuntimeGetVersion"]
    pub fn cuDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a compute device"]
    #[doc = ""]
    #[doc = " Returns in \\p *device a device handle given an ordinal in the range <b>[0,"]
    #[doc = " ::cuDeviceGetCount()-1]</b>."]
    #[doc = ""]
    #[doc = " \\param device  - Returned device handle"]
    #[doc = " \\param ordinal - Device number to get handle for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGetLuid,"]
    #[doc = " ::cuDeviceTotalMem,"]
    #[doc = " ::cuDeviceGetExecAffinitySupport"]
    pub fn cuDeviceGet(device: *mut CUdevice, ordinal: ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the number of compute-capable devices"]
    #[doc = ""]
    #[doc = " Returns in \\p *count the number of devices with compute capability greater"]
    #[doc = " than or equal to 2.0 that are available for execution. If there is no such"]
    #[doc = " device, ::cuDeviceGetCount() returns 0."]
    #[doc = ""]
    #[doc = " \\param count - Returned number of compute-capable devices"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGetLuid,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem,"]
    #[doc = " ::cuDeviceGetExecAffinitySupport,"]
    #[doc = " ::cudaGetDeviceCount"]
    pub fn cuDeviceGetCount(count: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns an identifer string for the device"]
    #[doc = ""]
    #[doc = " Returns an ASCII string identifying the device \\p dev in the NULL-terminated"]
    #[doc = " string pointed to by \\p name. \\p len specifies the maximum length of the"]
    #[doc = " string that may be returned."]
    #[doc = ""]
    #[doc = " \\param name - Returned identifier string for the device"]
    #[doc = " \\param len  - Maximum length of string to store in \\p name"]
    #[doc = " \\param dev  - Device to get identifier string for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGetLuid,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem,"]
    #[doc = " ::cuDeviceGetExecAffinitySupport,"]
    #[doc = " ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetName(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Return an UUID for the device"]
    #[doc = ""]
    #[doc = " Note there is a later version of this API, ::cuDeviceGetUuid_v2. It will"]
    #[doc = " supplant this version in 12.0, which is retained for minor version compatibility."]
    #[doc = ""]
    #[doc = " Returns 16-octets identifing the device \\p dev in the structure"]
    #[doc = " pointed by the \\p uuid."]
    #[doc = ""]
    #[doc = " \\param uuid - Returned UUID"]
    #[doc = " \\param dev  - Device to get identifier string for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetUuid_v2"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetLuid,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem,"]
    #[doc = " ::cuDeviceGetExecAffinitySupport,"]
    #[doc = " ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetUuid(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetUuid_v2(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Return an LUID and device node mask for the device"]
    #[doc = ""]
    #[doc = " Return identifying information (\\p luid and \\p deviceNodeMask) to allow"]
    #[doc = " matching device with graphics APIs."]
    #[doc = ""]
    #[doc = " \\param luid - Returned LUID"]
    #[doc = " \\param deviceNodeMask - Returned device node mask"]
    #[doc = " \\param dev  - Device to get identifier string for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem,"]
    #[doc = " ::cuDeviceGetExecAffinitySupport,"]
    #[doc = " ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetLuid(
        luid: *mut ::std::os::raw::c_char,
        deviceNodeMask: *mut ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceTotalMem_v2(bytes: *mut size_t, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size."]
    #[doc = ""]
    #[doc = " Returns in \\p maxWidthInElements the maximum number of texture elements allocatable in a 1D linear texture"]
    #[doc = " for given \\p format and \\p numChannels."]
    #[doc = ""]
    #[doc = " \\param maxWidthInElements    - Returned maximum number of texture elements allocatable for given \\p format and \\p numChannels."]
    #[doc = " \\param format                - Texture format."]
    #[doc = " \\param numChannels           - Number of channels per texture element."]
    #[doc = " \\param dev                   - Device handle."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cudaMemGetInfo,"]
    #[doc = " ::cuDeviceTotalMem"]
    pub fn cuDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut size_t,
        format: CUarray_format,
        numChannels: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about the device"]
    #[doc = ""]
    #[doc = " Returns in \\p *pi the integer value of the attribute \\p attrib on device"]
    #[doc = " \\p dev. The supported attributes are:"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: Maximum number of threads per"]
    #[doc = "   block;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: Maximum x-dimension of a block;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: Maximum y-dimension of a block;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: Maximum z-dimension of a block;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: Maximum x-dimension of a grid;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: Maximum y-dimension of a grid;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: Maximum z-dimension of a grid;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: Maximum amount of"]
    #[doc = "   shared memory available to a thread block in bytes;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: Memory available on device for"]
    #[doc = "   __constant__ variables in a CUDA C kernel in bytes;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_WARP_SIZE: Warp size in threads;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_PITCH: Maximum pitch in bytes allowed by the"]
    #[doc = "   memory copy functions that involve memory regions allocated through"]
    #[doc = "   ::cuMemAllocPitch();"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH: Maximum 1D"]
    #[doc = "  texture width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH: Maximum width"]
    #[doc = "  for a 1D texture bound to linear memory;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH: Maximum"]
    #[doc = "  mipmapped 1D texture width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH: Maximum 2D"]
    #[doc = "  texture width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT: Maximum 2D"]
    #[doc = "  texture height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH: Maximum width"]
    #[doc = "  for a 2D texture bound to linear memory;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT: Maximum height"]
    #[doc = "  for a 2D texture bound to linear memory;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH: Maximum pitch"]
    #[doc = "  in bytes for a 2D texture bound to linear memory;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH: Maximum"]
    #[doc = "  mipmapped 2D texture width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT: Maximum"]
    #[doc = "  mipmapped 2D texture height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH: Maximum 3D"]
    #[doc = "  texture width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT: Maximum 3D"]
    #[doc = "  texture height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH: Maximum 3D"]
    #[doc = "  texture depth;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE:"]
    #[doc = "  Alternate maximum 3D texture width, 0 if no alternate"]
    #[doc = "  maximum 3D texture size is supported;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE:"]
    #[doc = "  Alternate maximum 3D texture height, 0 if no alternate"]
    #[doc = "  maximum 3D texture size is supported;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE:"]
    #[doc = "  Alternate maximum 3D texture depth, 0 if no alternate"]
    #[doc = "  maximum 3D texture size is supported;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH:"]
    #[doc = "  Maximum cubemap texture width or height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH:"]
    #[doc = "  Maximum 1D layered texture width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS:"]
    #[doc = "   Maximum layers in a 1D layered texture;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH:"]
    #[doc = "  Maximum 2D layered texture width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT:"]
    #[doc = "   Maximum 2D layered texture height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS:"]
    #[doc = "   Maximum layers in a 2D layered texture;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH:"]
    #[doc = "   Maximum cubemap layered texture width or height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS:"]
    #[doc = "   Maximum layers in a cubemap layered texture;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH:"]
    #[doc = "   Maximum 1D surface width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH:"]
    #[doc = "   Maximum 2D surface width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT:"]
    #[doc = "   Maximum 2D surface height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH:"]
    #[doc = "   Maximum 3D surface width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT:"]
    #[doc = "   Maximum 3D surface height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH:"]
    #[doc = "   Maximum 3D surface depth;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH:"]
    #[doc = "   Maximum 1D layered surface width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS:"]
    #[doc = "   Maximum layers in a 1D layered surface;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH:"]
    #[doc = "   Maximum 2D layered surface width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT:"]
    #[doc = "   Maximum 2D layered surface height;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS:"]
    #[doc = "   Maximum layers in a 2D layered surface;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH:"]
    #[doc = "   Maximum cubemap surface width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH:"]
    #[doc = "   Maximum cubemap layered surface width;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS:"]
    #[doc = "   Maximum layers in a cubemap layered surface;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: Maximum number of 32-bit"]
    #[doc = "   registers available to a thread block;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_CLOCK_RATE: The typical clock frequency in kilohertz;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: Alignment requirement; texture"]
    #[doc = "   base addresses aligned to ::textureAlign bytes do not need an offset"]
    #[doc = "   applied to texture fetches;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT: Pitch alignment requirement"]
    #[doc = "   for 2D texture references bound to pitched memory;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: 1 if the device can concurrently copy"]
    #[doc = "   memory between host and device while executing a kernel, or 0 if not;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: Number of multiprocessors on"]
    #[doc = "   the device;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: 1 if there is a run time limit"]
    #[doc = "   for kernels executed on the device, or 0 if not;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_INTEGRATED: 1 if the device is integrated with the"]
    #[doc = "   memory subsystem, or 0 if not;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: 1 if the device can map host"]
    #[doc = "   memory into the CUDA address space, or 0 if not;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: Compute mode that device is currently"]
    #[doc = "   in. Available modes are as follows:"]
    #[doc = "   - ::CU_COMPUTEMODE_DEFAULT: Default mode - Device is not restricted and"]
    #[doc = "     can have multiple CUDA contexts present at a single time."]
    #[doc = "   - ::CU_COMPUTEMODE_PROHIBITED: Compute-prohibited mode - Device is"]
    #[doc = "     prohibited from creating new CUDA contexts."]
    #[doc = "   - ::CU_COMPUTEMODE_EXCLUSIVE_PROCESS:  Compute-exclusive-process mode - Device"]
    #[doc = "     can have only one context used by a single process at a time."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: 1 if the device supports"]
    #[doc = "   executing multiple kernels within the same context simultaneously, or 0 if"]
    #[doc = "   not. It is not guaranteed that multiple kernels will be resident"]
    #[doc = "   on the device concurrently so this feature should not be relied upon for"]
    #[doc = "   correctness;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_ECC_ENABLED: 1 if error correction is enabled on the"]
    #[doc = "    device, 0 if error correction is disabled or not supported by the device;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: PCI bus identifier of the device;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: PCI device (also known as slot) identifier"]
    #[doc = "   of the device;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: PCI domain identifier of the device"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_TCC_DRIVER: 1 if the device is using a TCC driver. TCC"]
    #[doc = "    is only available on Tesla hardware running Windows Vista or later;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: Peak memory clock frequency in kilohertz;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: Global memory bus width in bits;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: Size of L2 cache in bytes. 0 if the device doesn't have L2 cache;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: Maximum resident threads per multiprocessor;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: 1 if the device shares a unified address space with"]
    #[doc = "   the host, or 0 if not;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: Major compute capability version number;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: Minor compute capability version number;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED: 1 if device supports caching globals"]
    #[doc = "    in L1 cache, 0 if caching globals in L1 cache is not supported by the device;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED: 1 if device supports caching locals"]
    #[doc = "    in L1 cache, 0 if caching locals in L1 cache is not supported by the device;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR: Maximum amount of"]
    #[doc = "   shared memory available to a multiprocessor in bytes; this amount is shared"]
    #[doc = "   by all thread blocks simultaneously resident on a multiprocessor;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR: Maximum number of 32-bit"]
    #[doc = "   registers available to a multiprocessor; this number is shared by all thread"]
    #[doc = "   blocks simultaneously resident on a multiprocessor;"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: 1 if device supports allocating managed memory"]
    #[doc = "   on this system, 0 if allocating managed memory is not supported by the device on this system."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: 1 if device is on a multi-GPU board, 0 if not."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID: Unique identifier for a group of devices"]
    #[doc = "   associated with the same board. Devices on the same multi-GPU board will share the same identifier."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED: 1 if Link between the device and the host"]
    #[doc = "   supports native atomic operations."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO: Ratio of single precision performance"]
    #[doc = "   (in floating-point operations per second) to double precision performance."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS: Device suppports coherently accessing"]
    #[doc = "   pageable memory without calling cudaHostRegister on it."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS: Device can coherently access managed memory"]
    #[doc = "   concurrently with the CPU."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED: Device supports Compute Preemption."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM: Device can access host registered"]
    #[doc = "   memory at the same virtual address as the CPU."]
    #[doc = " -  ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN: The maximum per block shared memory size"]
    #[doc = "    suported on this device. This is the maximum value that can be opted into when using the cuFuncSetAttribute() call."]
    #[doc = "    For more details see ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES: Device accesses pageable memory via the host's"]
    #[doc = "   page tables."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST: The host can directly access managed memory on the device without migration."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED:  Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED: Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED:  Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED: Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested ::cuMemCreate"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE: Maximum L2 persisting lines capacity setting in bytes."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE: Maximum value of CUaccessPolicyWindow::num_bytes."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR: Maximum number of thread blocks that can reside on a multiprocessor."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED: Device supports compressible memory allocation via ::cuMemCreate"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK: Amount of shared memory per block reserved by CUDA driver in bytes."]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED: Device supports using the ::cuMemHostRegister flag CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU"]
    #[doc = " - ::CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED: Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs"]
    #[doc = ""]
    #[doc = " \\param pi     - Returned device attribute value"]
    #[doc = " \\param attrib - Device attribute to query"]
    #[doc = " \\param dev    - Device handle"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem,"]
    #[doc = " ::cuDeviceGetExecAffinitySupport,"]
    #[doc = " ::cudaDeviceGetAttribute,"]
    #[doc = " ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Return NvSciSync attributes that this device can support."]
    #[doc = ""]
    #[doc = " Returns in \\p nvSciSyncAttrList, the properties of NvSciSync that"]
    #[doc = " this CUDA device, \\p dev can support. The returned \\p nvSciSyncAttrList"]
    #[doc = " can be used to create an NvSciSync object that matches this device's capabilities."]
    #[doc = ""]
    #[doc = " If NvSciSyncAttrKey_RequiredPerm field in \\p nvSciSyncAttrList is"]
    #[doc = " already set this API will return ::CUDA_ERROR_INVALID_VALUE."]
    #[doc = ""]
    #[doc = " The applications should set \\p nvSciSyncAttrList to a valid"]
    #[doc = " NvSciSyncAttrList failing which this API will return"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE."]
    #[doc = ""]
    #[doc = " The \\p flags controls how applications intends to use"]
    #[doc = " the NvSciSync created from the \\p nvSciSyncAttrList. The valid flags are:"]
    #[doc = " - ::CUDA_NVSCISYNC_ATTR_SIGNAL, specifies that the applications intends to"]
    #[doc = " signal an NvSciSync on this CUDA device."]
    #[doc = " - ::CUDA_NVSCISYNC_ATTR_WAIT, specifies that the applications intends to"]
    #[doc = " wait on an NvSciSync on this CUDA device."]
    #[doc = ""]
    #[doc = " At least one of these flags must be set, failing which the API"]
    #[doc = " returns ::CUDA_ERROR_INVALID_VALUE. Both the flags are orthogonal"]
    #[doc = " to one another: a developer may set both these flags that allows to"]
    #[doc = " set both wait and signal specific attributes in the same \\p nvSciSyncAttrList."]
    #[doc = ""]
    #[doc = " \\param nvSciSyncAttrList     - Return NvSciSync attributes supported."]
    #[doc = " \\param dev                   - Valid Cuda Device to get NvSciSync attributes for."]
    #[doc = " \\param flags                 - flags describing NvSciSync usage."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = ""]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuImportExternalSemaphore,"]
    #[doc = " ::cuDestroyExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::std::os::raw::c_void,
        dev: CUdevice,
        flags: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the current memory pool of a device"]
    #[doc = ""]
    #[doc = " The memory pool must be local to the specified device."]
    #[doc = " ::cuMemAllocAsync allocates from the current mempool of the provided stream's device."]
    #[doc = " By default, a device's current memory pool is its default memory pool."]
    #[doc = ""]
    #[doc = " \\note Use ::cuMemAllocFromPoolAsync to specify asynchronous allocations from a device different"]
    #[doc = " than the one the stream runs on."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuDeviceGetDefaultMemPool, ::cuDeviceGetMemPool, ::cuMemPoolCreate, ::cuMemPoolDestroy, ::cuMemAllocFromPoolAsync"]
    pub fn cuDeviceSetMemPool(dev: CUdevice, pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the current mempool for a device"]
    #[doc = ""]
    #[doc = " Returns the last pool provided to ::cuDeviceSetMemPool for this device"]
    #[doc = " or the device's default memory pool if ::cuDeviceSetMemPool has never been called."]
    #[doc = " By default the current mempool is the default mempool for a device."]
    #[doc = " Otherwise the returned pool must have been set with ::cuDeviceSetMemPool."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuDeviceGetDefaultMemPool, ::cuMemPoolCreate, ::cuDeviceSetMemPool"]
    pub fn cuDeviceGetMemPool(pool: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the default mempool of a device"]
    #[doc = ""]
    #[doc = " The default mempool of a device contains device memory from that device."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocAsync, ::cuMemPoolTrimTo, ::cuMemPoolGetAttribute, ::cuMemPoolSetAttribute, cuMemPoolSetAccess, ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuDeviceGetDefaultMemPool(pool_out: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns properties for a selected device"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " This function was deprecated as of CUDA 5.0 and replaced by ::cuDeviceGetAttribute()."]
    #[doc = ""]
    #[doc = " Returns in \\p *prop the properties of device \\p dev. The ::CUdevprop"]
    #[doc = " structure is defined as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef struct CUdevprop_st {"]
    #[doc = "int maxThreadsPerBlock;"]
    #[doc = "int maxThreadsDim[3];"]
    #[doc = "int maxGridSize[3];"]
    #[doc = "int sharedMemPerBlock;"]
    #[doc = "int totalConstantMemory;"]
    #[doc = "int SIMDWidth;"]
    #[doc = "int memPitch;"]
    #[doc = "int regsPerBlock;"]
    #[doc = "int clockRate;"]
    #[doc = "int textureAlign"]
    #[doc = "} CUdevprop;"]
    #[doc = " \\endcode"]
    #[doc = " where:"]
    #[doc = ""]
    #[doc = " - ::maxThreadsPerBlock is the maximum number of threads per block;"]
    #[doc = " - ::maxThreadsDim[3] is the maximum sizes of each dimension of a block;"]
    #[doc = " - ::maxGridSize[3] is the maximum sizes of each dimension of a grid;"]
    #[doc = " - ::sharedMemPerBlock is the total amount of shared memory available per"]
    #[doc = "   block in bytes;"]
    #[doc = " - ::totalConstantMemory is the total amount of constant memory available on"]
    #[doc = "   the device in bytes;"]
    #[doc = " - ::SIMDWidth is the warp size;"]
    #[doc = " - ::memPitch is the maximum pitch allowed by the memory copy functions that"]
    #[doc = "   involve memory regions allocated through ::cuMemAllocPitch();"]
    #[doc = " - ::regsPerBlock is the total number of registers available per block;"]
    #[doc = " - ::clockRate is the clock frequency in kilohertz;"]
    #[doc = " - ::textureAlign is the alignment requirement; texture base addresses that"]
    #[doc = "   are aligned to ::textureAlign bytes do not need an offset applied to"]
    #[doc = "   texture fetches."]
    #[doc = ""]
    #[doc = " \\param prop - Returned properties of device"]
    #[doc = " \\param dev  - Device to get properties for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem"]
    pub fn cuDeviceGetProperties(prop: *mut CUdevprop, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the compute capability of the device"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " This function was deprecated as of CUDA 5.0 and its functionality superceded"]
    #[doc = " by ::cuDeviceGetAttribute()."]
    #[doc = ""]
    #[doc = " Returns in \\p *major and \\p *minor the major and minor revision numbers that"]
    #[doc = " define the compute capability of the device \\p dev."]
    #[doc = ""]
    #[doc = " \\param major - Major revision number"]
    #[doc = " \\param minor - Minor revision number"]
    #[doc = " \\param dev   - Device handle"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem"]
    pub fn cuDeviceComputeCapability(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retain the primary context on the GPU"]
    #[doc = ""]
    #[doc = " Retains the primary context on the device."]
    #[doc = " Once the user successfully retains the primary context, the primary context"]
    #[doc = " will be active and available to the user until the user releases it"]
    #[doc = " with ::cuDevicePrimaryCtxRelease() or resets it with ::cuDevicePrimaryCtxReset()."]
    #[doc = " Unlike ::cuCtxCreate() the newly retained context is not pushed onto the stack."]
    #[doc = ""]
    #[doc = " Retaining the primary context for the first time will fail with ::CUDA_ERROR_UNKNOWN"]
    #[doc = " if the compute mode of the device is ::CU_COMPUTEMODE_PROHIBITED. The function"]
    #[doc = " ::cuDeviceGetAttribute() can be used with ::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE to"]
    #[doc = " determine the compute mode  of the device."]
    #[doc = " The <i>nvidia-smi</i> tool can be used to set the compute mode for"]
    #[doc = " devices. Documentation for <i>nvidia-smi</i> can be obtained by passing a"]
    #[doc = " -h option to it."]
    #[doc = ""]
    #[doc = " Please note that the primary context always supports pinned allocations. Other"]
    #[doc = " flags can be specified by ::cuDevicePrimaryCtxSetFlags()."]
    #[doc = ""]
    #[doc = " \\param pctx  - Returned context handle of the new context"]
    #[doc = " \\param dev   - Device for which primary context is requested"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuDevicePrimaryCtxRelease,"]
    #[doc = " ::cuDevicePrimaryCtxSetFlags,"]
    #[doc = " ::cuCtxCreate,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize"]
    pub fn cuDevicePrimaryCtxRetain(pctx: *mut CUcontext, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxRelease_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxSetFlags_v2(dev: CUdevice, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get the state of the primary context"]
    #[doc = ""]
    #[doc = " Returns in \\p *flags the flags for the primary context of \\p dev, and in"]
    #[doc = " \\p *active whether it is active.  See ::cuDevicePrimaryCtxSetFlags for flag"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = " \\param dev    - Device to get primary context flags for"]
    #[doc = " \\param flags  - Pointer to store flags"]
    #[doc = " \\param active - Pointer to store context state; 0 = inactive, 1 = active"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDevicePrimaryCtxSetFlags,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cudaGetDeviceFlags"]
    pub fn cuDevicePrimaryCtxGetState(
        dev: CUdevice,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxReset_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about the execution affinity support of the device."]
    #[doc = ""]
    #[doc = " Returns in \\p *pi whether execution affinity type \\p type is supported by device \\p dev."]
    #[doc = " The supported types are:"]
    #[doc = " - ::CU_EXEC_AFFINITY_TYPE_SM_COUNT: 1 if context with limited SMs is supported by the device,"]
    #[doc = "   or 0 if not;"]
    #[doc = ""]
    #[doc = " \\param pi   - 1 if the execution affinity type \\p type is supported by the device, or 0 if not"]
    #[doc = " \\param type - Execution affinity type to query"]
    #[doc = " \\param dev  - Device handle"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetCount,"]
    #[doc = " ::cuDeviceGetName,"]
    #[doc = " ::cuDeviceGetUuid,"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceTotalMem"]
    pub fn cuDeviceGetExecAffinitySupport(
        pi: *mut ::std::os::raw::c_int,
        type_: CUexecAffinityType,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v2(
        pctx: *mut CUcontext,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v3(
        pctx: *mut CUcontext,
        paramsArray: *mut CUexecAffinityParam,
        numParams: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxDestroy_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPushCurrent_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPopCurrent_v2(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Binds the specified CUDA context to the calling CPU thread"]
    #[doc = ""]
    #[doc = " Binds the specified CUDA context to the calling CPU thread."]
    #[doc = " If \\p ctx is NULL then the CUDA context previously bound to the"]
    #[doc = " calling CPU thread is unbound and ::CUDA_SUCCESS is returned."]
    #[doc = ""]
    #[doc = " If there exists a CUDA context stack on the calling CPU thread, this"]
    #[doc = " will replace the top of that stack with \\p ctx."]
    #[doc = " If \\p ctx is NULL then this will be equivalent to popping the top"]
    #[doc = " of the calling CPU thread's CUDA context stack (or a no-op if the"]
    #[doc = " calling CPU thread's CUDA context stack is empty)."]
    #[doc = ""]
    #[doc = " \\param ctx - Context to bind to the calling CPU thread"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuCtxGetCurrent,"]
    #[doc = " ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cudaSetDevice"]
    pub fn cuCtxSetCurrent(ctx: CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the CUDA context bound to the calling CPU thread."]
    #[doc = ""]
    #[doc = " Returns in \\p *pctx the CUDA context bound to the calling CPU thread."]
    #[doc = " If no context is bound to the calling CPU thread then \\p *pctx is"]
    #[doc = " set to NULL and ::CUDA_SUCCESS is returned."]
    #[doc = ""]
    #[doc = " \\param pctx - Returned context handle"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuCtxSetCurrent,"]
    #[doc = " ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cudaGetDevice"]
    pub fn cuCtxGetCurrent(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the device ID for the current context"]
    #[doc = ""]
    #[doc = " Returns in \\p *device the ordinal of the current context's device."]
    #[doc = ""]
    #[doc = " \\param device - Returned device ID for the current context"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cudaGetDevice"]
    pub fn cuCtxGetDevice(device: *mut CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the flags for the current context"]
    #[doc = ""]
    #[doc = " Returns in \\p *flags the flags of the current context. See ::cuCtxCreate"]
    #[doc = " for flag values."]
    #[doc = ""]
    #[doc = " \\param flags - Pointer to store flags of current context"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetCurrent,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxGetSharedMemConfig,"]
    #[doc = " ::cuCtxGetStreamPriorityRange,"]
    #[doc = " ::cudaGetDeviceFlags"]
    pub fn cuCtxGetFlags(flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Block for a context's tasks to complete"]
    #[doc = ""]
    #[doc = " Blocks until the device has completed all preceding requested tasks."]
    #[doc = " ::cuCtxSynchronize() returns an error if one of the preceding tasks failed."]
    #[doc = " If the context was created with the ::CU_CTX_SCHED_BLOCKING_SYNC flag, the"]
    #[doc = " CPU thread will block until the GPU context has finished its work."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cudaDeviceSynchronize"]
    pub fn cuCtxSynchronize() -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set resource limits"]
    #[doc = ""]
    #[doc = " Setting \\p limit to \\p value is a request by the application to update"]
    #[doc = " the current limit maintained by the context. The driver is free to"]
    #[doc = " modify the requested value to meet h/w requirements (this could be"]
    #[doc = " clamping to minimum or maximum values, rounding up to nearest element"]
    #[doc = " size, etc). The application can use ::cuCtxGetLimit() to find out exactly"]
    #[doc = " what the limit has been set to."]
    #[doc = ""]
    #[doc = " Setting each ::CUlimit has its own specific restrictions, so each is"]
    #[doc = " discussed here."]
    #[doc = ""]
    #[doc = " - ::CU_LIMIT_STACK_SIZE controls the stack size in bytes of each GPU thread."]
    #[doc = "   The driver automatically increases the per-thread stack size"]
    #[doc = "   for each kernel launch as needed. This size isn't reset back to the"]
    #[doc = "   original value after each launch. Setting this value will take effect"]
    #[doc = "   immediately, and if necessary, the device will block until all preceding"]
    #[doc = "   requested tasks are complete."]
    #[doc = ""]
    #[doc = " - ::CU_LIMIT_PRINTF_FIFO_SIZE controls the size in bytes of the FIFO used"]
    #[doc = "   by the ::printf() device system call. Setting ::CU_LIMIT_PRINTF_FIFO_SIZE"]
    #[doc = "   must be performed before launching any kernel that uses the ::printf()"]
    #[doc = "   device system call, otherwise ::CUDA_ERROR_INVALID_VALUE will be returned."]
    #[doc = ""]
    #[doc = " - ::CU_LIMIT_MALLOC_HEAP_SIZE controls the size in bytes of the heap used"]
    #[doc = "   by the ::malloc() and ::free() device system calls. Setting"]
    #[doc = "   ::CU_LIMIT_MALLOC_HEAP_SIZE must be performed before launching any kernel"]
    #[doc = "   that uses the ::malloc() or ::free() device system calls, otherwise"]
    #[doc = "   ::CUDA_ERROR_INVALID_VALUE will be returned."]
    #[doc = ""]
    #[doc = " - ::CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH controls the maximum nesting depth of"]
    #[doc = "   a grid at which a thread can safely call ::cudaDeviceSynchronize(). Setting"]
    #[doc = "   this limit must be performed before any launch of a kernel that uses the"]
    #[doc = "   device runtime and calls ::cudaDeviceSynchronize() above the default sync"]
    #[doc = "   depth, two levels of grids. Calls to ::cudaDeviceSynchronize() will fail"]
    #[doc = "   with error code ::cudaErrorSyncDepthExceeded if the limitation is"]
    #[doc = "   violated. This limit can be set smaller than the default or up the maximum"]
    #[doc = "   launch depth of 24. When setting this limit, keep in mind that additional"]
    #[doc = "   levels of sync depth require the driver to reserve large amounts of device"]
    #[doc = "   memory which can no longer be used for user allocations. If these"]
    #[doc = "   reservations of device memory fail, ::cuCtxSetLimit() will return"]
    #[doc = "   ::CUDA_ERROR_OUT_OF_MEMORY, and the limit can be reset to a lower value."]
    #[doc = "   This limit is only applicable to devices of compute capability 3.5 and"]
    #[doc = "   higher. Attempting to set this limit on devices of compute capability less"]
    #[doc = "   than 3.5 will result in the error ::CUDA_ERROR_UNSUPPORTED_LIMIT being"]
    #[doc = "   returned."]
    #[doc = ""]
    #[doc = " - ::CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT controls the maximum number of"]
    #[doc = "   outstanding device runtime launches that can be made from the current"]
    #[doc = "   context. A grid is outstanding from the point of launch up until the grid"]
    #[doc = "   is known to have been completed. Device runtime launches which violate"]
    #[doc = "   this limitation fail and return ::cudaErrorLaunchPendingCountExceeded when"]
    #[doc = "   ::cudaGetLastError() is called after launch. If more pending launches than"]
    #[doc = "   the default (2048 launches) are needed for a module using the device"]
    #[doc = "   runtime, this limit can be increased. Keep in mind that being able to"]
    #[doc = "   sustain additional pending launches will require the driver to reserve"]
    #[doc = "   larger amounts of device memory upfront which can no longer be used for"]
    #[doc = "   allocations. If these reservations fail, ::cuCtxSetLimit() will return"]
    #[doc = "   ::CUDA_ERROR_OUT_OF_MEMORY, and the limit can be reset to a lower value."]
    #[doc = "   This limit is only applicable to devices of compute capability 3.5 and"]
    #[doc = "   higher. Attempting to set this limit on devices of compute capability less"]
    #[doc = "   than 3.5 will result in the error ::CUDA_ERROR_UNSUPPORTED_LIMIT being"]
    #[doc = "   returned."]
    #[doc = ""]
    #[doc = " - ::CU_LIMIT_MAX_L2_FETCH_GRANULARITY controls the L2 cache fetch granularity."]
    #[doc = "   Values can range from 0B to 128B. This is purely a performence hint and"]
    #[doc = "   it can be ignored or clamped depending on the platform."]
    #[doc = ""]
    #[doc = " - ::CU_LIMIT_PERSISTING_L2_CACHE_SIZE controls size in bytes availabe for"]
    #[doc = "   persisting L2 cache. This is purely a performance hint and it can be"]
    #[doc = "   ignored or clamped depending on the platform."]
    #[doc = ""]
    #[doc = " \\param limit - Limit to set"]
    #[doc = " \\param value - Size of limit"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNSUPPORTED_LIMIT,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cudaDeviceSetLimit"]
    pub fn cuCtxSetLimit(limit: CUlimit, value: size_t) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns resource limits"]
    #[doc = ""]
    #[doc = " Returns in \\p *pvalue the current size of \\p limit.  The supported"]
    #[doc = " ::CUlimit values are:"]
    #[doc = " - ::CU_LIMIT_STACK_SIZE: stack size in bytes of each GPU thread."]
    #[doc = " - ::CU_LIMIT_PRINTF_FIFO_SIZE: size in bytes of the FIFO used by the"]
    #[doc = "   ::printf() device system call."]
    #[doc = " - ::CU_LIMIT_MALLOC_HEAP_SIZE: size in bytes of the heap used by the"]
    #[doc = "   ::malloc() and ::free() device system calls."]
    #[doc = " - ::CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH: maximum grid depth at which a thread"]
    #[doc = "   can issue the device runtime call ::cudaDeviceSynchronize() to wait on"]
    #[doc = "   child grid launches to complete."]
    #[doc = " - ::CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT: maximum number of outstanding"]
    #[doc = "   device runtime launches that can be made from this context."]
    #[doc = " - ::CU_LIMIT_MAX_L2_FETCH_GRANULARITY: L2 cache fetch granularity."]
    #[doc = " - ::CU_LIMIT_PERSISTING_L2_CACHE_SIZE: Persisting L2 cache size in bytes"]
    #[doc = ""]
    #[doc = " \\param limit  - Limit to query"]
    #[doc = " \\param pvalue - Returned size of limit"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNSUPPORTED_LIMIT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cudaDeviceGetLimit"]
    pub fn cuCtxGetLimit(pvalue: *mut size_t, limit: CUlimit) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the preferred cache configuration for the current context."]
    #[doc = ""]
    #[doc = " On devices where the L1 cache and shared memory use the same hardware"]
    #[doc = " resources, this function returns through \\p pconfig the preferred cache configuration"]
    #[doc = " for the current context. This is only a preference. The driver will use"]
    #[doc = " the requested configuration if possible, but it is free to choose a different"]
    #[doc = " configuration if required to execute functions."]
    #[doc = ""]
    #[doc = " This will return a \\p pconfig of ::CU_FUNC_CACHE_PREFER_NONE on devices"]
    #[doc = " where the size of the L1 cache and shared memory are fixed."]
    #[doc = ""]
    #[doc = " The supported cache configurations are:"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_SHARED: prefer larger shared memory and smaller L1 cache"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_L1: prefer larger L1 cache and smaller shared memory"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_EQUAL: prefer equal sized L1 cache and shared memory"]
    #[doc = ""]
    #[doc = " \\param pconfig - Returned cache configuration"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cudaDeviceGetCacheConfig"]
    pub fn cuCtxGetCacheConfig(pconfig: *mut CUfunc_cache) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for the current context."]
    #[doc = ""]
    #[doc = " On devices where the L1 cache and shared memory use the same hardware"]
    #[doc = " resources, this sets through \\p config the preferred cache configuration for"]
    #[doc = " the current context. This is only a preference. The driver will use"]
    #[doc = " the requested configuration if possible, but it is free to choose a different"]
    #[doc = " configuration if required to execute the function. Any function preference"]
    #[doc = " set via ::cuFuncSetCacheConfig() will be preferred over this context-wide"]
    #[doc = " setting. Setting the context-wide cache configuration to"]
    #[doc = " ::CU_FUNC_CACHE_PREFER_NONE will cause subsequent kernel launches to prefer"]
    #[doc = " to not change the cache configuration unless required to launch the kernel."]
    #[doc = ""]
    #[doc = " This setting does nothing on devices where the size of the L1 cache and"]
    #[doc = " shared memory are fixed."]
    #[doc = ""]
    #[doc = " Launching a kernel with a different preference than the most recent"]
    #[doc = " preference setting may insert a device-side synchronization point."]
    #[doc = ""]
    #[doc = " The supported cache configurations are:"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_SHARED: prefer larger shared memory and smaller L1 cache"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_L1: prefer larger L1 cache and smaller shared memory"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_EQUAL: prefer equal sized L1 cache and shared memory"]
    #[doc = ""]
    #[doc = " \\param config - Requested cache configuration"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cudaDeviceSetCacheConfig"]
    pub fn cuCtxSetCacheConfig(config: CUfunc_cache) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the current shared memory configuration for the current context."]
    #[doc = ""]
    #[doc = " This function will return in \\p pConfig the current size of shared memory banks"]
    #[doc = " in the current context. On devices with configurable shared memory banks,"]
    #[doc = " ::cuCtxSetSharedMemConfig can be used to change this setting, so that all"]
    #[doc = " subsequent kernel launches will by default use the new bank size. When"]
    #[doc = " ::cuCtxGetSharedMemConfig is called on devices without configurable shared"]
    #[doc = " memory, it will return the fixed bank size of the hardware."]
    #[doc = ""]
    #[doc = " The returned bank configurations can be either:"]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE:  shared memory bank width is"]
    #[doc = "   four bytes."]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: shared memory bank width will"]
    #[doc = "   eight bytes."]
    #[doc = ""]
    #[doc = " \\param pConfig - returned shared memory configuration"]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cuCtxGetSharedMemConfig,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cudaDeviceGetSharedMemConfig"]
    pub fn cuCtxGetSharedMemConfig(pConfig: *mut CUsharedconfig) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the shared memory configuration for the current context."]
    #[doc = ""]
    #[doc = " On devices with configurable shared memory banks, this function will set"]
    #[doc = " the context's shared memory bank size which is used for subsequent kernel"]
    #[doc = " launches."]
    #[doc = ""]
    #[doc = " Changed the shared memory configuration between launches may insert a device"]
    #[doc = " side synchronization point between those launches."]
    #[doc = ""]
    #[doc = " Changing the shared memory bank size will not increase shared memory usage"]
    #[doc = " or affect occupancy of kernels, but may have major effects on performance."]
    #[doc = " Larger bank sizes will allow for greater potential bandwidth to shared memory,"]
    #[doc = " but will change what kinds of accesses to shared memory will result in bank"]
    #[doc = " conflicts."]
    #[doc = ""]
    #[doc = " This function will do nothing on devices with fixed shared memory bank size."]
    #[doc = ""]
    #[doc = " The supported bank configurations are:"]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: set bank width to the default initial"]
    #[doc = "   setting (currently, four bytes)."]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: set shared memory bank width to"]
    #[doc = "   be natively four bytes."]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: set shared memory bank width to"]
    #[doc = "   be natively eight bytes."]
    #[doc = ""]
    #[doc = " \\param config - requested shared memory configuration"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cuCtxGetSharedMemConfig,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cudaDeviceSetSharedMemConfig"]
    pub fn cuCtxSetSharedMemConfig(config: CUsharedconfig) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the context's API version."]
    #[doc = ""]
    #[doc = " Returns a version number in \\p version corresponding to the capabilities of"]
    #[doc = " the context (e.g. 3010 or 3020), which library developers can use to direct"]
    #[doc = " callers to a specific API version. If \\p ctx is NULL, returns the API version"]
    #[doc = " used to create the currently bound context."]
    #[doc = ""]
    #[doc = " Note that new API versions are only introduced when context capabilities are"]
    #[doc = " changed that break binary compatibility, so the API version and driver version"]
    #[doc = " may be different. For example, it is valid for the API version to be 3020 while"]
    #[doc = " the driver version is 4020."]
    #[doc = ""]
    #[doc = " \\param ctx     - Context to check"]
    #[doc = " \\param version - Pointer to version"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize"]
    pub fn cuCtxGetApiVersion(ctx: CUcontext, version: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns numerical values that correspond to the least and"]
    #[doc = " greatest stream priorities."]
    #[doc = ""]
    #[doc = " Returns in \\p *leastPriority and \\p *greatestPriority the numerical values that correspond"]
    #[doc = " to the least and greatest stream priorities respectively. Stream priorities"]
    #[doc = " follow a convention where lower numbers imply greater priorities. The range of"]
    #[doc = " meaningful stream priorities is given by [\\p *greatestPriority, \\p *leastPriority]."]
    #[doc = " If the user attempts to create a stream with a priority value that is"]
    #[doc = " outside the meaningful range as specified by this API, the priority is"]
    #[doc = " automatically clamped down or up to either \\p *leastPriority or \\p *greatestPriority"]
    #[doc = " respectively. See ::cuStreamCreateWithPriority for details on creating a"]
    #[doc = " priority stream."]
    #[doc = " A NULL may be passed in for \\p *leastPriority or \\p *greatestPriority if the value"]
    #[doc = " is not desired."]
    #[doc = ""]
    #[doc = " This function will return '0' in both \\p *leastPriority and \\p *greatestPriority if"]
    #[doc = " the current context's device does not support stream priorities"]
    #[doc = " (see ::cuDeviceGetAttribute)."]
    #[doc = ""]
    #[doc = " \\param leastPriority    - Pointer to an int in which the numerical value for least"]
    #[doc = "                           stream priority is returned"]
    #[doc = " \\param greatestPriority - Pointer to an int in which the numerical value for greatest"]
    #[doc = "                           stream priority is returned"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamCreateWithPriority,"]
    #[doc = " ::cuStreamGetPriority,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize,"]
    #[doc = " ::cudaDeviceGetStreamPriorityRange"]
    pub fn cuCtxGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Resets all persisting lines in cache to normal status."]
    #[doc = ""]
    #[doc = " ::cuCtxResetPersistingL2Cache Resets all persisting lines in cache to normal"]
    #[doc = " status. Takes effect on function return."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUaccessPolicyWindow"]
    pub fn cuCtxResetPersistingL2Cache() -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the execution affinity setting for the current context."]
    #[doc = ""]
    #[doc = " Returns in \\p *pExecAffinity the current value of \\p type. The supported"]
    #[doc = " ::CUexecAffinityType values are:"]
    #[doc = " - ::CU_EXEC_AFFINITY_TYPE_SM_COUNT: number of SMs the context is limited to use."]
    #[doc = ""]
    #[doc = " \\param type          - Execution affinity type to query"]
    #[doc = " \\param pExecAffinity - Returned execution affinity"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUexecAffinityParam"]
    pub fn cuCtxGetExecAffinity(
        pExecAffinity: *mut CUexecAffinityParam,
        type_: CUexecAffinityType,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Increment a context's usage-count"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Note that this function is deprecated and should not be used."]
    #[doc = ""]
    #[doc = " Increments the usage count of the context and passes back a context handle"]
    #[doc = " in \\p *pctx that must be passed to ::cuCtxDetach() when the application is"]
    #[doc = " done with the context. ::cuCtxAttach() fails if there is no context current"]
    #[doc = " to the thread."]
    #[doc = ""]
    #[doc = " Currently, the \\p flags parameter must be 0."]
    #[doc = ""]
    #[doc = " \\param pctx  - Returned context handle of the current context"]
    #[doc = " \\param flags - Context attach flags (must be 0)"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxDetach,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize"]
    pub fn cuCtxAttach(pctx: *mut CUcontext, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Decrement a context's usage-count"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Note that this function is deprecated and should not be used."]
    #[doc = ""]
    #[doc = " Decrements the usage count of the context \\p ctx, and destroys the context"]
    #[doc = " if the usage count goes to 0. The context must be a handle that was passed"]
    #[doc = " back by ::cuCtxCreate() or ::cuCtxAttach(), and must be current to the"]
    #[doc = " calling thread."]
    #[doc = ""]
    #[doc = " \\param ctx - Context to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxCreate,"]
    #[doc = " ::cuCtxDestroy,"]
    #[doc = " ::cuCtxGetApiVersion,"]
    #[doc = " ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxGetDevice,"]
    #[doc = " ::cuCtxGetFlags,"]
    #[doc = " ::cuCtxGetLimit,"]
    #[doc = " ::cuCtxPopCurrent,"]
    #[doc = " ::cuCtxPushCurrent,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxSetLimit,"]
    #[doc = " ::cuCtxSynchronize"]
    pub fn cuCtxDetach(ctx: CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Loads a compute module"]
    #[doc = ""]
    #[doc = " Takes a filename \\p fname and loads the corresponding module \\p module into"]
    #[doc = " the current context. The CUDA driver API does not attempt to lazily"]
    #[doc = " allocate the resources needed by a module; if the memory for functions and"]
    #[doc = " data (constant and global) needed by the module cannot be allocated,"]
    #[doc = " ::cuModuleLoad() fails. The file should be a \\e cubin file as output by"]
    #[doc = " \\b nvcc, or a \\e PTX file either as output by \\b nvcc or handwritten, or"]
    #[doc = " a \\e fatbin file as output by \\b nvcc from toolchain 4.0 or later."]
    #[doc = ""]
    #[doc = " \\param module - Returned module"]
    #[doc = " \\param fname  - Filename of module to load"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_PTX,"]
    #[doc = " ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,"]
    #[doc = " ::CUDA_ERROR_NOT_FOUND,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_FILE_NOT_FOUND,"]
    #[doc = " ::CUDA_ERROR_NO_BINARY_FOR_GPU,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,"]
    #[doc = " ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetFunction,"]
    #[doc = " ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetTexRef,"]
    #[doc = " ::cuModuleLoadData,"]
    #[doc = " ::cuModuleLoadDataEx,"]
    #[doc = " ::cuModuleLoadFatBinary,"]
    #[doc = " ::cuModuleUnload"]
    pub fn cuModuleLoad(module: *mut CUmodule, fname: *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a module's data"]
    #[doc = ""]
    #[doc = " Takes a pointer \\p image and loads the corresponding module \\p module into"]
    #[doc = " the current context. The pointer may be obtained by mapping a \\e cubin or"]
    #[doc = " \\e PTX or \\e fatbin file, passing a \\e cubin or \\e PTX or \\e fatbin file"]
    #[doc = " as a NULL-terminated text string, or incorporating a \\e cubin or \\e fatbin"]
    #[doc = " object into the executable resources and using operating system calls such"]
    #[doc = " as Windows \\c FindResource() to obtain the pointer."]
    #[doc = ""]
    #[doc = " \\param module - Returned module"]
    #[doc = " \\param image  - Module data to load"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_PTX,"]
    #[doc = " ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_NO_BINARY_FOR_GPU,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,"]
    #[doc = " ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetFunction,"]
    #[doc = " ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetTexRef,"]
    #[doc = " ::cuModuleLoad,"]
    #[doc = " ::cuModuleLoadDataEx,"]
    #[doc = " ::cuModuleLoadFatBinary,"]
    #[doc = " ::cuModuleUnload"]
    pub fn cuModuleLoadData(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a module's data with options"]
    #[doc = ""]
    #[doc = " Takes a pointer \\p image and loads the corresponding module \\p module into"]
    #[doc = " the current context. The pointer may be obtained by mapping a \\e cubin or"]
    #[doc = " \\e PTX or \\e fatbin file, passing a \\e cubin or \\e PTX or \\e fatbin file"]
    #[doc = " as a NULL-terminated text string, or incorporating a \\e cubin or \\e fatbin"]
    #[doc = " object into the executable resources and using operating system calls such"]
    #[doc = " as Windows \\c FindResource() to obtain the pointer. Options are passed as"]
    #[doc = " an array via \\p options and any corresponding parameters are passed in"]
    #[doc = " \\p optionValues. The number of total options is supplied via \\p numOptions."]
    #[doc = " Any outputs will be returned via \\p optionValues."]
    #[doc = ""]
    #[doc = " \\param module       - Returned module"]
    #[doc = " \\param image        - Module data to load"]
    #[doc = " \\param numOptions   - Number of options"]
    #[doc = " \\param options      - Options for JIT"]
    #[doc = " \\param optionValues - Option values for JIT"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_PTX,"]
    #[doc = " ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_NO_BINARY_FOR_GPU,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,"]
    #[doc = " ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetFunction,"]
    #[doc = " ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetTexRef,"]
    #[doc = " ::cuModuleLoad,"]
    #[doc = " ::cuModuleLoadData,"]
    #[doc = " ::cuModuleLoadFatBinary,"]
    #[doc = " ::cuModuleUnload"]
    pub fn cuModuleLoadDataEx(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a module's data"]
    #[doc = ""]
    #[doc = " Takes a pointer \\p fatCubin and loads the corresponding module \\p module"]
    #[doc = " into the current context. The pointer represents a <i>fat binary</i> object,"]
    #[doc = " which is a collection of different \\e cubin and/or \\e PTX files, all"]
    #[doc = " representing the same device code, but compiled and optimized for different"]
    #[doc = " architectures."]
    #[doc = ""]
    #[doc = " Prior to CUDA 4.0, there was no documented API for constructing and using"]
    #[doc = " fat binary objects by programmers.  Starting with CUDA 4.0, fat binary"]
    #[doc = " objects can be constructed by providing the <i>-fatbin option</i> to \\b nvcc."]
    #[doc = " More information can be found in the \\b nvcc document."]
    #[doc = ""]
    #[doc = " \\param module   - Returned module"]
    #[doc = " \\param fatCubin - Fat binary to load"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_PTX,"]
    #[doc = " ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,"]
    #[doc = " ::CUDA_ERROR_NOT_FOUND,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_NO_BINARY_FOR_GPU,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,"]
    #[doc = " ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetFunction,"]
    #[doc = " ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetTexRef,"]
    #[doc = " ::cuModuleLoad,"]
    #[doc = " ::cuModuleLoadData,"]
    #[doc = " ::cuModuleLoadDataEx,"]
    #[doc = " ::cuModuleUnload"]
    pub fn cuModuleLoadFatBinary(
        module: *mut CUmodule,
        fatCubin: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unloads a module"]
    #[doc = ""]
    #[doc = " Unloads a module \\p hmod from the current context."]
    #[doc = ""]
    #[doc = " \\param hmod - Module to unload"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetFunction,"]
    #[doc = " ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetTexRef,"]
    #[doc = " ::cuModuleLoad,"]
    #[doc = " ::cuModuleLoadData,"]
    #[doc = " ::cuModuleLoadDataEx,"]
    #[doc = " ::cuModuleLoadFatBinary"]
    pub fn cuModuleUnload(hmod: CUmodule) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a function handle"]
    #[doc = ""]
    #[doc = " Returns in \\p *hfunc the handle of the function of name \\p name located in"]
    #[doc = " module \\p hmod. If no function of that name exists, ::cuModuleGetFunction()"]
    #[doc = " returns ::CUDA_ERROR_NOT_FOUND."]
    #[doc = ""]
    #[doc = " \\param hfunc - Returned function handle"]
    #[doc = " \\param hmod  - Module to retrieve function from"]
    #[doc = " \\param name  - Name of function to retrieve"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetTexRef,"]
    #[doc = " ::cuModuleLoad,"]
    #[doc = " ::cuModuleLoadData,"]
    #[doc = " ::cuModuleLoadDataEx,"]
    #[doc = " ::cuModuleLoadFatBinary,"]
    #[doc = " ::cuModuleUnload"]
    pub fn cuModuleGetFunction(
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetGlobal_v2(
        dptr: *mut CUdeviceptr,
        bytes: *mut size_t,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a texture reference"]
    #[doc = ""]
    #[doc = " Returns in \\p *pTexRef the handle of the texture reference of name \\p name"]
    #[doc = " in the module \\p hmod. If no texture reference of that name exists,"]
    #[doc = " ::cuModuleGetTexRef() returns ::CUDA_ERROR_NOT_FOUND. This texture reference"]
    #[doc = " handle should not be destroyed, since it will be destroyed when the module"]
    #[doc = " is unloaded."]
    #[doc = ""]
    #[doc = " \\param pTexRef  - Returned texture reference"]
    #[doc = " \\param hmod     - Module to retrieve texture reference from"]
    #[doc = " \\param name     - Name of texture reference to retrieve"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetFunction,"]
    #[doc = " ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetSurfRef,"]
    #[doc = " ::cuModuleLoad,"]
    #[doc = " ::cuModuleLoadData,"]
    #[doc = " ::cuModuleLoadDataEx,"]
    #[doc = " ::cuModuleLoadFatBinary,"]
    #[doc = " ::cuModuleUnload,"]
    #[doc = " ::cudaGetTextureReference"]
    pub fn cuModuleGetTexRef(
        pTexRef: *mut CUtexref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a surface reference"]
    #[doc = ""]
    #[doc = " Returns in \\p *pSurfRef the handle of the surface reference of name \\p name"]
    #[doc = " in the module \\p hmod. If no surface reference of that name exists,"]
    #[doc = " ::cuModuleGetSurfRef() returns ::CUDA_ERROR_NOT_FOUND."]
    #[doc = ""]
    #[doc = " \\param pSurfRef  - Returned surface reference"]
    #[doc = " \\param hmod     - Module to retrieve surface reference from"]
    #[doc = " \\param name     - Name of surface reference to retrieve"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetFunction,"]
    #[doc = " ::cuModuleGetGlobal,"]
    #[doc = " ::cuModuleGetTexRef,"]
    #[doc = " ::cuModuleLoad,"]
    #[doc = " ::cuModuleLoadData,"]
    #[doc = " ::cuModuleLoadDataEx,"]
    #[doc = " ::cuModuleLoadFatBinary,"]
    #[doc = " ::cuModuleUnload,"]
    #[doc = " ::cudaGetSurfaceReference"]
    pub fn cuModuleGetSurfRef(
        pSurfRef: *mut CUsurfref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkCreate_v2(
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddData_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::std::os::raw::c_void,
        size: size_t,
        name: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddFile_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        path: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Complete a pending linker invocation"]
    #[doc = ""]
    #[doc = " Completes the pending linker action and returns the cubin image for the linked"]
    #[doc = " device code, which can be used with ::cuModuleLoadData.  The cubin is owned by"]
    #[doc = " \\p state, so it should be loaded before \\p state is destroyed via ::cuLinkDestroy."]
    #[doc = " This call does not destroy \\p state."]
    #[doc = ""]
    #[doc = " \\param state    A pending linker invocation"]
    #[doc = " \\param cubinOut On success, this will point to the output image"]
    #[doc = " \\param sizeOut  Optional parameter to receive the size of the generated image"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa ::cuLinkCreate,"]
    #[doc = " ::cuLinkAddData,"]
    #[doc = " ::cuLinkAddFile,"]
    #[doc = " ::cuLinkDestroy,"]
    #[doc = " ::cuModuleLoadData"]
    pub fn cuLinkComplete(
        state: CUlinkState,
        cubinOut: *mut *mut ::std::os::raw::c_void,
        sizeOut: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys state for a JIT linker invocation."]
    #[doc = ""]
    #[doc = " \\param state State object for the linker invocation"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = ""]
    #[doc = " \\sa ::cuLinkCreate"]
    pub fn cuLinkDestroy(state: CUlinkState) -> CUresult;
}
extern "C" {
    pub fn cuMemGetInfo_v2(free: *mut size_t, total: *mut size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemAlloc_v2(dptr: *mut CUdeviceptr, bytesize: size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocPitch_v2(
        dptr: *mut CUdeviceptr,
        pPitch: *mut size_t,
        WidthInBytes: size_t,
        Height: size_t,
        ElementSizeBytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemFree_v2(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAddressRange_v2(
        pbase: *mut CUdeviceptr,
        psize: *mut size_t,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocHost_v2(pp: *mut *mut ::std::os::raw::c_void, bytesize: size_t) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Frees page-locked host memory"]
    #[doc = ""]
    #[doc = " Frees the memory space pointed to by \\p p, which must have been returned by"]
    #[doc = " a previous call to ::cuMemAllocHost()."]
    #[doc = ""]
    #[doc = " \\param p - Pointer to memory to free"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,"]
    #[doc = " ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,"]
    #[doc = " ::cudaFreeHost"]
    pub fn cuMemFreeHost(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates page-locked host memory"]
    #[doc = ""]
    #[doc = " Allocates \\p bytesize bytes of host memory that is page-locked and accessible"]
    #[doc = " to the device. The driver tracks the virtual memory ranges allocated with"]
    #[doc = " this function and automatically accelerates calls to functions such as"]
    #[doc = " ::cuMemcpyHtoD(). Since the memory can be accessed directly by the device,"]
    #[doc = " it can be read or written with much higher bandwidth than pageable memory"]
    #[doc = " obtained with functions such as ::malloc(). Allocating excessive amounts of"]
    #[doc = " pinned memory may degrade system performance, since it reduces the amount"]
    #[doc = " of memory available to the system for paging. As a result, this function is"]
    #[doc = " best used sparingly to allocate staging areas for data exchange between"]
    #[doc = " host and device."]
    #[doc = ""]
    #[doc = " The \\p Flags parameter enables different options to be specified that"]
    #[doc = " affect the allocation, as follows."]
    #[doc = ""]
    #[doc = " - ::CU_MEMHOSTALLOC_PORTABLE: The memory returned by this call will be"]
    #[doc = "   considered as pinned memory by all CUDA contexts, not just the one that"]
    #[doc = "   performed the allocation."]
    #[doc = ""]
    #[doc = " - ::CU_MEMHOSTALLOC_DEVICEMAP: Maps the allocation into the CUDA address"]
    #[doc = "   space. The device pointer to the memory may be obtained by calling"]
    #[doc = "   ::cuMemHostGetDevicePointer()."]
    #[doc = ""]
    #[doc = " - ::CU_MEMHOSTALLOC_WRITECOMBINED: Allocates the memory as write-combined"]
    #[doc = "   (WC). WC memory can be transferred across the PCI Express bus more"]
    #[doc = "   quickly on some system configurations, but cannot be read efficiently by"]
    #[doc = "   most CPUs. WC memory is a good option for buffers that will be written by"]
    #[doc = "   the CPU and read by the GPU via mapped pinned memory or host->device"]
    #[doc = "   transfers."]
    #[doc = ""]
    #[doc = " All of these flags are orthogonal to one another: a developer may allocate"]
    #[doc = " memory that is portable, mapped and/or write-combined with no restrictions."]
    #[doc = ""]
    #[doc = " The ::CU_MEMHOSTALLOC_DEVICEMAP flag may be specified on CUDA contexts for"]
    #[doc = " devices that do not support mapped pinned memory. The failure is deferred"]
    #[doc = " to ::cuMemHostGetDevicePointer() because the memory may be mapped into"]
    #[doc = " other CUDA contexts via the ::CU_MEMHOSTALLOC_PORTABLE flag."]
    #[doc = ""]
    #[doc = " The memory allocated by this function must be freed with ::cuMemFreeHost()."]
    #[doc = ""]
    #[doc = " Note all host memory allocated using ::cuMemHostAlloc() will automatically"]
    #[doc = " be immediately accessible to all contexts on all devices which support unified"]
    #[doc = " addressing (as may be queried using ::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING)."]
    #[doc = " Unless the flag ::CU_MEMHOSTALLOC_WRITECOMBINED is specified, the device pointer"]
    #[doc = " that may be used to access this host memory from those contexts is always equal"]
    #[doc = " to the returned host pointer \\p *pp.  If the flag ::CU_MEMHOSTALLOC_WRITECOMBINED"]
    #[doc = " is specified, then the function ::cuMemHostGetDevicePointer() must be used"]
    #[doc = " to query the device pointer, even if the context supports unified addressing."]
    #[doc = " See \\ref CUDA_UNIFIED for additional details."]
    #[doc = ""]
    #[doc = " \\param pp       - Returned host pointer to page-locked memory"]
    #[doc = " \\param bytesize - Requested allocation size in bytes"]
    #[doc = " \\param Flags    - Flags for allocation request"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,"]
    #[doc = " ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,"]
    #[doc = " ::cudaHostAlloc"]
    pub fn cuMemHostAlloc(
        pp: *mut *mut ::std::os::raw::c_void,
        bytesize: size_t,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostGetDevicePointer_v2(
        pdptr: *mut CUdeviceptr,
        p: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Passes back flags that were used for a pinned allocation"]
    #[doc = ""]
    #[doc = " Passes back the flags \\p pFlags that were specified when allocating"]
    #[doc = " the pinned host buffer \\p p allocated by ::cuMemHostAlloc."]
    #[doc = ""]
    #[doc = " ::cuMemHostGetFlags() will fail if the pointer does not reside in"]
    #[doc = " an allocation performed by ::cuMemAllocHost() or ::cuMemHostAlloc()."]
    #[doc = ""]
    #[doc = " \\param pFlags - Returned flags word"]
    #[doc = " \\param p     - Host pointer"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemAllocHost,"]
    #[doc = " ::cuMemHostAlloc,"]
    #[doc = " ::cudaHostGetFlags"]
    pub fn cuMemHostGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        p: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates memory that will be automatically managed by the Unified Memory system"]
    #[doc = ""]
    #[doc = " Allocates \\p bytesize bytes of managed memory on the device and returns in"]
    #[doc = " \\p *dptr a pointer to the allocated memory. If the device doesn't support"]
    #[doc = " allocating managed memory, ::CUDA_ERROR_NOT_SUPPORTED is returned. Support"]
    #[doc = " for managed memory can be queried using the device attribute"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY. The allocated memory is suitably"]
    #[doc = " aligned for any kind of variable. The memory is not cleared. If \\p bytesize"]
    #[doc = " is 0, ::cuMemAllocManaged returns ::CUDA_ERROR_INVALID_VALUE. The pointer"]
    #[doc = " is valid on the CPU and on all GPUs in the system that support managed memory."]
    #[doc = " All accesses to this pointer must obey the Unified Memory programming model."]
    #[doc = ""]
    #[doc = " \\p flags specifies the default stream association for this allocation."]
    #[doc = " \\p flags must be one of ::CU_MEM_ATTACH_GLOBAL or ::CU_MEM_ATTACH_HOST. If"]
    #[doc = " ::CU_MEM_ATTACH_GLOBAL is specified, then this memory is accessible from"]
    #[doc = " any stream on any device. If ::CU_MEM_ATTACH_HOST is specified, then the"]
    #[doc = " allocation should not be accessed from devices that have a zero value for the"]
    #[doc = " device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS; an explicit call to"]
    #[doc = " ::cuStreamAttachMemAsync will be required to enable access on such devices."]
    #[doc = ""]
    #[doc = " If the association is later changed via ::cuStreamAttachMemAsync to"]
    #[doc = " a single stream, the default association as specifed during ::cuMemAllocManaged"]
    #[doc = " is restored when that stream is destroyed. For __managed__ variables, the"]
    #[doc = " default association is always ::CU_MEM_ATTACH_GLOBAL. Note that destroying a"]
    #[doc = " stream is an asynchronous operation, and as a result, the change to default"]
    #[doc = " association won't happen until all work in the stream has completed."]
    #[doc = ""]
    #[doc = " Memory allocated with ::cuMemAllocManaged should be released with ::cuMemFree."]
    #[doc = ""]
    #[doc = " Device memory oversubscription is possible for GPUs that have a non-zero value for the"]
    #[doc = " device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS. Managed memory on"]
    #[doc = " such GPUs may be evicted from device memory to host memory at any time by the Unified"]
    #[doc = " Memory driver in order to make room for other allocations."]
    #[doc = ""]
    #[doc = " In a multi-GPU system where all GPUs have a non-zero value for the device attribute"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS, managed memory may not be populated when this"]
    #[doc = " API returns and instead may be populated on access. In such systems, managed memory can"]
    #[doc = " migrate to any processor's memory at any time. The Unified Memory driver will employ heuristics to"]
    #[doc = " maintain data locality and prevent excessive page faults to the extent possible. The application"]
    #[doc = " can also guide the driver about memory usage patterns via ::cuMemAdvise. The application"]
    #[doc = " can also explicitly migrate memory to a desired processor's memory via"]
    #[doc = " ::cuMemPrefetchAsync."]
    #[doc = ""]
    #[doc = " In a multi-GPU system where all of the GPUs have a zero value for the device attribute"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS and all the GPUs have peer-to-peer support"]
    #[doc = " with each other, the physical storage for managed memory is created on the GPU which is active"]
    #[doc = " at the time ::cuMemAllocManaged is called. All other GPUs will reference the data at reduced"]
    #[doc = " bandwidth via peer mappings over the PCIe bus. The Unified Memory driver does not migrate"]
    #[doc = " memory among such GPUs."]
    #[doc = ""]
    #[doc = " In a multi-GPU system where not all GPUs have peer-to-peer support with each other and"]
    #[doc = " where the value of the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS"]
    #[doc = " is zero for at least one of those GPUs, the location chosen for physical storage of managed"]
    #[doc = " memory is system-dependent."]
    #[doc = " - On Linux, the location chosen will be device memory as long as the current set of active"]
    #[doc = " contexts are on devices that either have peer-to-peer support with each other or have a"]
    #[doc = " non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS."]
    #[doc = " If there is an active context on a GPU that does not have a non-zero value for that device"]
    #[doc = " attribute and it does not have peer-to-peer support with the other devices that have active"]
    #[doc = " contexts on them, then the location for physical storage will be 'zero-copy' or host memory."]
    #[doc = " Note that this means that managed memory that is located in device memory is migrated to"]
    #[doc = " host memory if a new context is created on a GPU that doesn't have a non-zero value for"]
    #[doc = " the device attribute and does not support peer-to-peer with at least one of the other devices"]
    #[doc = " that has an active context. This in turn implies that context creation may fail if there is"]
    #[doc = " insufficient host memory to migrate all managed allocations."]
    #[doc = " - On Windows, the physical storage is always created in 'zero-copy' or host memory."]
    #[doc = " All GPUs will reference the data at reduced bandwidth over the PCIe bus. In these"]
    #[doc = " circumstances, use of the environment variable CUDA_VISIBLE_DEVICES is recommended to"]
    #[doc = " restrict CUDA to only use those GPUs that have peer-to-peer support."]
    #[doc = " Alternatively, users can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a"]
    #[doc = " non-zero value to force the driver to always use device memory for physical storage."]
    #[doc = " When this environment variable is set to a non-zero value, all contexts created in"]
    #[doc = " that process on devices that support managed memory have to be peer-to-peer compatible"]
    #[doc = " with each other. Context creation will fail if a context is created on a device that"]
    #[doc = " supports managed memory and is not peer-to-peer compatible with any of the other"]
    #[doc = " managed memory supporting devices on which contexts were previously created, even if"]
    #[doc = " those contexts have been destroyed. These environment variables are described"]
    #[doc = " in the CUDA programming guide under the \"CUDA environment variables\" section."]
    #[doc = " - On ARM, managed memory is not available on discrete gpu with Drive PX-2."]
    #[doc = ""]
    #[doc = " \\param dptr     - Returned device pointer"]
    #[doc = " \\param bytesize - Requested allocation size in bytes"]
    #[doc = " \\param flags    - Must be one of ::CU_MEM_ATTACH_GLOBAL or ::CU_MEM_ATTACH_HOST"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,"]
    #[doc = " ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,"]
    #[doc = " ::cuDeviceGetAttribute, ::cuStreamAttachMemAsync,"]
    #[doc = " ::cudaMallocManaged"]
    pub fn cuMemAllocManaged(
        dptr: *mut CUdeviceptr,
        bytesize: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a compute device"]
    #[doc = ""]
    #[doc = " Returns in \\p *device a device handle given a PCI bus ID string."]
    #[doc = ""]
    #[doc = " \\param dev      - Returned device handle"]
    #[doc = ""]
    #[doc = " \\param pciBusId - String in one of the following forms:"]
    #[doc = " [domain]:[bus]:[device].[function]"]
    #[doc = " [domain]:[bus]:[device]"]
    #[doc = " [bus]:[device].[function]"]
    #[doc = " where \\p domain, \\p bus, \\p device, and \\p function are all hexadecimal values"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetPCIBusId,"]
    #[doc = " ::cudaDeviceGetByPCIBusId"]
    pub fn cuDeviceGetByPCIBusId(
        dev: *mut CUdevice,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a PCI Bus Id string for the device"]
    #[doc = ""]
    #[doc = " Returns an ASCII string identifying the device \\p dev in the NULL-terminated"]
    #[doc = " string pointed to by \\p pciBusId. \\p len specifies the maximum length of the"]
    #[doc = " string that may be returned."]
    #[doc = ""]
    #[doc = " \\param pciBusId - Returned identifier string for the device in the following format"]
    #[doc = " [domain]:[bus]:[device].[function]"]
    #[doc = " where \\p domain, \\p bus, \\p device, and \\p function are all hexadecimal values."]
    #[doc = " pciBusId should be large enough to store 13 characters including the NULL-terminator."]
    #[doc = ""]
    #[doc = " \\param len      - Maximum length of string to store in \\p name"]
    #[doc = ""]
    #[doc = " \\param dev      - Device to get identifier string for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceGet,"]
    #[doc = " ::cuDeviceGetAttribute,"]
    #[doc = " ::cuDeviceGetByPCIBusId,"]
    #[doc = " ::cudaDeviceGetPCIBusId"]
    pub fn cuDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets an interprocess handle for a previously allocated event"]
    #[doc = ""]
    #[doc = " Takes as input a previously allocated event. This event must have been"]
    #[doc = " created with the ::CU_EVENT_INTERPROCESS and ::CU_EVENT_DISABLE_TIMING"]
    #[doc = " flags set. This opaque handle may be copied into other processes and"]
    #[doc = " opened with ::cuIpcOpenEventHandle to allow efficient hardware"]
    #[doc = " synchronization between GPU work in different processes."]
    #[doc = ""]
    #[doc = " After the event has been opened in the importing process,"]
    #[doc = " ::cuEventRecord, ::cuEventSynchronize, ::cuStreamWaitEvent and"]
    #[doc = " ::cuEventQuery may be used in either process. Performing operations"]
    #[doc = " on the imported event after the exported event has been freed"]
    #[doc = " with ::cuEventDestroy will result in undefined behavior."]
    #[doc = ""]
    #[doc = " IPC functionality is restricted to devices with support for unified"]
    #[doc = " addressing on Linux and Windows operating systems."]
    #[doc = " IPC functionality on Windows is restricted to GPUs in TCC mode"]
    #[doc = ""]
    #[doc = " \\param pHandle - Pointer to a user allocated CUipcEventHandle"]
    #[doc = "                    in which to return the opaque event handle"]
    #[doc = " \\param event   - Event allocated with ::CU_EVENT_INTERPROCESS and"]
    #[doc = "                    ::CU_EVENT_DISABLE_TIMING flags."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_MAP_FAILED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuEventCreate,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cuEventSynchronize,"]
    #[doc = " ::cuEventQuery,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuIpcOpenEventHandle,"]
    #[doc = " ::cuIpcGetMemHandle,"]
    #[doc = " ::cuIpcOpenMemHandle,"]
    #[doc = " ::cuIpcCloseMemHandle,"]
    #[doc = " ::cudaIpcGetEventHandle"]
    pub fn cuIpcGetEventHandle(pHandle: *mut CUipcEventHandle, event: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Opens an interprocess event handle for use in the current process"]
    #[doc = ""]
    #[doc = " Opens an interprocess event handle exported from another process with"]
    #[doc = " ::cuIpcGetEventHandle. This function returns a ::CUevent that behaves like"]
    #[doc = " a locally created event with the ::CU_EVENT_DISABLE_TIMING flag specified."]
    #[doc = " This event must be freed with ::cuEventDestroy."]
    #[doc = ""]
    #[doc = " Performing operations on the imported event after the exported event has"]
    #[doc = " been freed with ::cuEventDestroy will result in undefined behavior."]
    #[doc = ""]
    #[doc = " IPC functionality is restricted to devices with support for unified"]
    #[doc = " addressing on Linux and Windows operating systems."]
    #[doc = " IPC functionality on Windows is restricted to GPUs in TCC mode"]
    #[doc = ""]
    #[doc = " \\param phEvent - Returns the imported event"]
    #[doc = " \\param handle  - Interprocess handle to open"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_MAP_FAILED,"]
    #[doc = " ::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuEventCreate,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cuEventSynchronize,"]
    #[doc = " ::cuEventQuery,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuIpcGetEventHandle,"]
    #[doc = " ::cuIpcGetMemHandle,"]
    #[doc = " ::cuIpcOpenMemHandle,"]
    #[doc = " ::cuIpcCloseMemHandle,"]
    #[doc = " ::cudaIpcOpenEventHandle"]
    pub fn cuIpcOpenEventHandle(phEvent: *mut CUevent, handle: CUipcEventHandle) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets an interprocess memory handle for an existing device memory"]
    #[doc = " allocation"]
    #[doc = ""]
    #[doc = " Takes a pointer to the base of an existing device memory allocation created"]
    #[doc = " with ::cuMemAlloc and exports it for use in another process. This is a"]
    #[doc = " lightweight operation and may be called multiple times on an allocation"]
    #[doc = " without adverse effects."]
    #[doc = ""]
    #[doc = " If a region of memory is freed with ::cuMemFree and a subsequent call"]
    #[doc = " to ::cuMemAlloc returns memory with the same device address,"]
    #[doc = " ::cuIpcGetMemHandle will return a unique handle for the"]
    #[doc = " new memory."]
    #[doc = ""]
    #[doc = " IPC functionality is restricted to devices with support for unified"]
    #[doc = " addressing on Linux and Windows operating systems."]
    #[doc = " IPC functionality on Windows is restricted to GPUs in TCC mode"]
    #[doc = ""]
    #[doc = " \\param pHandle - Pointer to user allocated ::CUipcMemHandle to return"]
    #[doc = "                    the handle in."]
    #[doc = " \\param dptr    - Base pointer to previously allocated device memory"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_MAP_FAILED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemAlloc,"]
    #[doc = " ::cuMemFree,"]
    #[doc = " ::cuIpcGetEventHandle,"]
    #[doc = " ::cuIpcOpenEventHandle,"]
    #[doc = " ::cuIpcOpenMemHandle,"]
    #[doc = " ::cuIpcCloseMemHandle,"]
    #[doc = " ::cudaIpcGetMemHandle"]
    pub fn cuIpcGetMemHandle(pHandle: *mut CUipcMemHandle, dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuIpcOpenMemHandle_v2(
        pdptr: *mut CUdeviceptr,
        handle: CUipcMemHandle,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Attempts to close memory mapped with ::cuIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " Decrements the reference count of the memory returned by ::cuIpcOpenMemHandle by 1."]
    #[doc = " When the reference count reaches 0, this API unmaps the memory. The original allocation"]
    #[doc = " in the exporting process as well as imported mappings in other processes"]
    #[doc = " will be unaffected."]
    #[doc = ""]
    #[doc = " Any resources used to enable peer access will be freed if this is the"]
    #[doc = " last mapping using them."]
    #[doc = ""]
    #[doc = " IPC functionality is restricted to devices with support for unified"]
    #[doc = " addressing on Linux and Windows operating systems."]
    #[doc = " IPC functionality on Windows is restricted to GPUs in TCC mode"]
    #[doc = ""]
    #[doc = " \\param dptr - Device pointer returned by ::cuIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_MAP_FAILED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\sa"]
    #[doc = " ::cuMemAlloc,"]
    #[doc = " ::cuMemFree,"]
    #[doc = " ::cuIpcGetEventHandle,"]
    #[doc = " ::cuIpcOpenEventHandle,"]
    #[doc = " ::cuIpcGetMemHandle,"]
    #[doc = " ::cuIpcOpenMemHandle,"]
    #[doc = " ::cudaIpcCloseMemHandle"]
    pub fn cuIpcCloseMemHandle(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemHostRegister_v2(
        p: *mut ::std::os::raw::c_void,
        bytesize: size_t,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unregisters a memory range that was registered with cuMemHostRegister."]
    #[doc = ""]
    #[doc = " Unmaps the memory range whose base address is specified by \\p p, and makes"]
    #[doc = " it pageable again."]
    #[doc = ""]
    #[doc = " The base address must be the same one specified to ::cuMemHostRegister()."]
    #[doc = ""]
    #[doc = " \\param p - Host pointer to memory to unregister"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemHostRegister,"]
    #[doc = " ::cudaHostUnregister"]
    pub fn cuMemHostUnregister(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory"]
    #[doc = ""]
    #[doc = " Copies data between two pointers."]
    #[doc = " \\p dst and \\p src are base pointers of the destination and source, respectively."]
    #[doc = " \\p ByteCount specifies the number of bytes to copy."]
    #[doc = " Note that this function infers the type of the transfer (host to host, host to"]
    #[doc = "   device, device to device, or device to host) from the pointer values.  This"]
    #[doc = "   function is only allowed in contexts which support unified addressing."]
    #[doc = ""]
    #[doc = " \\param dst - Destination unified virtual address space pointer"]
    #[doc = " \\param src - Source unified virtual address space pointer"]
    #[doc = " \\param ByteCount - Size of memory copy in bytes"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_sync"]
    #[doc = " \\note_memcpy"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,"]
    #[doc = " ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,"]
    #[doc = " ::cudaMemcpy,"]
    #[doc = " ::cudaMemcpyToSymbol,"]
    #[doc = " ::cudaMemcpyFromSymbol"]
    pub fn cuMemcpy(dst: CUdeviceptr, src: CUdeviceptr, ByteCount: size_t) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies device memory between two contexts"]
    #[doc = ""]
    #[doc = " Copies from device memory in one context to device memory in another"]
    #[doc = " context. \\p dstDevice is the base device pointer of the destination memory"]
    #[doc = " and \\p dstContext is the destination context.  \\p srcDevice is the base"]
    #[doc = " device pointer of the source memory and \\p srcContext is the source pointer."]
    #[doc = " \\p ByteCount specifies the number of bytes to copy."]
    #[doc = ""]
    #[doc = " \\param dstDevice  - Destination device pointer"]
    #[doc = " \\param dstContext - Destination context"]
    #[doc = " \\param srcDevice  - Source device pointer"]
    #[doc = " \\param srcContext - Source context"]
    #[doc = " \\param ByteCount  - Size of memory copy in bytes"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_sync"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemcpyDtoD, ::cuMemcpy3DPeer, ::cuMemcpyDtoDAsync, ::cuMemcpyPeerAsync,"]
    #[doc = " ::cuMemcpy3DPeerAsync,"]
    #[doc = " ::cudaMemcpyPeer"]
    pub fn cuMemcpyPeer(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoD_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoD_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoA_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoD_v2(
        dstDevice: CUdeviceptr,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoA_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoA_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2D_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DUnaligned_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3D_v2(pCopy: *const CUDA_MEMCPY3D) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory between contexts"]
    #[doc = ""]
    #[doc = " Perform a 3D memory copy according to the parameters specified in"]
    #[doc = " \\p pCopy.  See the definition of the ::CUDA_MEMCPY3D_PEER structure"]
    #[doc = " for documentation of its parameters."]
    #[doc = ""]
    #[doc = " \\param pCopy - Parameters for the memory copy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_sync"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemcpyDtoD, ::cuMemcpyPeer, ::cuMemcpyDtoDAsync, ::cuMemcpyPeerAsync,"]
    #[doc = " ::cuMemcpy3DPeerAsync,"]
    #[doc = " ::cudaMemcpy3DPeer"]
    pub fn cuMemcpy3DPeer(pCopy: *const CUDA_MEMCPY3D_PEER) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory asynchronously"]
    #[doc = ""]
    #[doc = " Copies data between two pointers."]
    #[doc = " \\p dst and \\p src are base pointers of the destination and source, respectively."]
    #[doc = " \\p ByteCount specifies the number of bytes to copy."]
    #[doc = " Note that this function infers the type of the transfer (host to host, host to"]
    #[doc = "   device, device to device, or device to host) from the pointer values.  This"]
    #[doc = "   function is only allowed in contexts which support unified addressing."]
    #[doc = ""]
    #[doc = " \\param dst       - Destination unified virtual address space pointer"]
    #[doc = " \\param src       - Source unified virtual address space pointer"]
    #[doc = " \\param ByteCount - Size of memory copy in bytes"]
    #[doc = " \\param hStream   - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_async"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\note_memcpy"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,"]
    #[doc = " ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,"]
    #[doc = " ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,"]
    #[doc = " ::cuMemsetD32, ::cuMemsetD32Async,"]
    #[doc = " ::cudaMemcpyAsync,"]
    #[doc = " ::cudaMemcpyToSymbolAsync,"]
    #[doc = " ::cudaMemcpyFromSymbolAsync"]
    pub fn cuMemcpyAsync(
        dst: CUdeviceptr,
        src: CUdeviceptr,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies device memory between two contexts asynchronously."]
    #[doc = ""]
    #[doc = " Copies from device memory in one context to device memory in another"]
    #[doc = " context. \\p dstDevice is the base device pointer of the destination memory"]
    #[doc = " and \\p dstContext is the destination context.  \\p srcDevice is the base"]
    #[doc = " device pointer of the source memory and \\p srcContext is the source pointer."]
    #[doc = " \\p ByteCount specifies the number of bytes to copy."]
    #[doc = ""]
    #[doc = " \\param dstDevice  - Destination device pointer"]
    #[doc = " \\param dstContext - Destination context"]
    #[doc = " \\param srcDevice  - Source device pointer"]
    #[doc = " \\param srcContext - Source context"]
    #[doc = " \\param ByteCount  - Size of memory copy in bytes"]
    #[doc = " \\param hStream    - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_async"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemcpyDtoD, ::cuMemcpyPeer, ::cuMemcpy3DPeer, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpy3DPeerAsync,"]
    #[doc = " ::cudaMemcpyPeerAsync"]
    pub fn cuMemcpyPeerAsync(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoAAsync_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DAsync_v2(pCopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DAsync_v2(pCopy: *const CUDA_MEMCPY3D, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory between contexts asynchronously."]
    #[doc = ""]
    #[doc = " Perform a 3D memory copy according to the parameters specified in"]
    #[doc = " \\p pCopy.  See the definition of the ::CUDA_MEMCPY3D_PEER structure"]
    #[doc = " for documentation of its parameters."]
    #[doc = ""]
    #[doc = " \\param pCopy - Parameters for the memory copy"]
    #[doc = " \\param hStream - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_async"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemcpyDtoD, ::cuMemcpyPeer, ::cuMemcpyDtoDAsync, ::cuMemcpyPeerAsync,"]
    #[doc = " ::cuMemcpy3DPeerAsync,"]
    #[doc = " ::cudaMemcpy3DPeerAsync"]
    pub fn cuMemcpy3DPeerAsync(pCopy: *const CUDA_MEMCPY3D_PEER, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD8_v2(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD16_v2(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD32_v2(
        dstDevice: CUdeviceptr,
        ui: ::std::os::raw::c_uint,
        N: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D8_v2(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        uc: ::std::os::raw::c_uchar,
        Width: size_t,
        Height: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D16_v2(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        us: ::std::os::raw::c_ushort,
        Width: size_t,
        Height: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D32_v2(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        ui: ::std::os::raw::c_uint,
        Width: size_t,
        Height: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory"]
    #[doc = ""]
    #[doc = " Sets the memory range of \\p N 8-bit values to the specified value"]
    #[doc = " \\p uc."]
    #[doc = ""]
    #[doc = " \\param dstDevice - Destination device pointer"]
    #[doc = " \\param uc        - Value to set"]
    #[doc = " \\param N         - Number of elements"]
    #[doc = " \\param hStream   - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_memset"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,"]
    #[doc = " ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,"]
    #[doc = " ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD16Async,"]
    #[doc = " ::cuMemsetD32, ::cuMemsetD32Async,"]
    #[doc = " ::cudaMemsetAsync"]
    pub fn cuMemsetD8Async(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory"]
    #[doc = ""]
    #[doc = " Sets the memory range of \\p N 16-bit values to the specified value"]
    #[doc = " \\p us. The \\p dstDevice pointer must be two byte aligned."]
    #[doc = ""]
    #[doc = " \\param dstDevice - Destination device pointer"]
    #[doc = " \\param us        - Value to set"]
    #[doc = " \\param N         - Number of elements"]
    #[doc = " \\param hStream   - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_memset"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,"]
    #[doc = " ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,"]
    #[doc = " ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16,"]
    #[doc = " ::cuMemsetD32, ::cuMemsetD32Async,"]
    #[doc = " ::cudaMemsetAsync"]
    pub fn cuMemsetD16Async(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory"]
    #[doc = ""]
    #[doc = " Sets the memory range of \\p N 32-bit values to the specified value"]
    #[doc = " \\p ui. The \\p dstDevice pointer must be four byte aligned."]
    #[doc = ""]
    #[doc = " \\param dstDevice - Destination device pointer"]
    #[doc = " \\param ui        - Value to set"]
    #[doc = " \\param N         - Number of elements"]
    #[doc = " \\param hStream   - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_memset"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,"]
    #[doc = " ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,"]
    #[doc = " ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async, ::cuMemsetD32,"]
    #[doc = " ::cudaMemsetAsync"]
    pub fn cuMemsetD32Async(
        dstDevice: CUdeviceptr,
        ui: ::std::os::raw::c_uint,
        N: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory"]
    #[doc = ""]
    #[doc = " Sets the 2D memory range of \\p Width 8-bit values to the specified value"]
    #[doc = " \\p uc. \\p Height specifies the number of rows to set, and \\p dstPitch"]
    #[doc = " specifies the number of bytes between each row. This function performs"]
    #[doc = " fastest when the pitch is one that has been passed back by"]
    #[doc = " ::cuMemAllocPitch()."]
    #[doc = ""]
    #[doc = " \\param dstDevice - Destination device pointer"]
    #[doc = " \\param dstPitch  - Pitch of destination device pointer(Unused if \\p Height is 1)"]
    #[doc = " \\param uc        - Value to set"]
    #[doc = " \\param Width     - Width of row"]
    #[doc = " \\param Height    - Number of rows"]
    #[doc = " \\param hStream   - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_memset"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8,"]
    #[doc = " ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,"]
    #[doc = " ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,"]
    #[doc = " ::cuMemsetD32, ::cuMemsetD32Async,"]
    #[doc = " ::cudaMemset2DAsync"]
    pub fn cuMemsetD2D8Async(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        uc: ::std::os::raw::c_uchar,
        Width: size_t,
        Height: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory"]
    #[doc = ""]
    #[doc = " Sets the 2D memory range of \\p Width 16-bit values to the specified value"]
    #[doc = " \\p us. \\p Height specifies the number of rows to set, and \\p dstPitch"]
    #[doc = " specifies the number of bytes between each row. The \\p dstDevice pointer"]
    #[doc = " and \\p dstPitch offset must be two byte aligned. This function performs"]
    #[doc = " fastest when the pitch is one that has been passed back by"]
    #[doc = " ::cuMemAllocPitch()."]
    #[doc = ""]
    #[doc = " \\param dstDevice - Destination device pointer"]
    #[doc = " \\param dstPitch  - Pitch of destination device pointer(Unused if \\p Height is 1)"]
    #[doc = " \\param us        - Value to set"]
    #[doc = " \\param Width     - Width of row"]
    #[doc = " \\param Height    - Number of rows"]
    #[doc = " \\param hStream   - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_memset"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,"]
    #[doc = " ::cuMemsetD2D16, ::cuMemsetD2D32, ::cuMemsetD2D32Async,"]
    #[doc = " ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,"]
    #[doc = " ::cuMemsetD32, ::cuMemsetD32Async,"]
    #[doc = " ::cudaMemset2DAsync"]
    pub fn cuMemsetD2D16Async(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        us: ::std::os::raw::c_ushort,
        Width: size_t,
        Height: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory"]
    #[doc = ""]
    #[doc = " Sets the 2D memory range of \\p Width 32-bit values to the specified value"]
    #[doc = " \\p ui. \\p Height specifies the number of rows to set, and \\p dstPitch"]
    #[doc = " specifies the number of bytes between each row. The \\p dstDevice pointer"]
    #[doc = " and \\p dstPitch offset must be four byte aligned. This function performs"]
    #[doc = " fastest when the pitch is one that has been passed back by"]
    #[doc = " ::cuMemAllocPitch()."]
    #[doc = ""]
    #[doc = " \\param dstDevice - Destination device pointer"]
    #[doc = " \\param dstPitch  - Pitch of destination device pointer(Unused if \\p Height is 1)"]
    #[doc = " \\param ui        - Value to set"]
    #[doc = " \\param Width     - Width of row"]
    #[doc = " \\param Height    - Number of rows"]
    #[doc = " \\param hStream   - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_memset"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,"]
    #[doc = " ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32,"]
    #[doc = " ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,"]
    #[doc = " ::cuMemsetD32, ::cuMemsetD32Async,"]
    #[doc = " ::cudaMemset2DAsync"]
    pub fn cuMemsetD2D32Async(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        ui: ::std::os::raw::c_uint,
        Width: size_t,
        Height: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the layout properties of a sparse CUDA array"]
    #[doc = ""]
    #[doc = " Returns the layout properties of a sparse CUDA array in \\p sparseProperties"]
    #[doc = " If the CUDA array is not allocated with flag ::CUDA_ARRAY3D_SPARSE"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE will be returned."]
    #[doc = ""]
    #[doc = " If the returned value in ::CUDA_ARRAY_SPARSE_PROPERTIES::flags contains ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL,"]
    #[doc = " then ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize represents the total size of the array. Otherwise, it will be zero."]
    #[doc = " Also, the returned value in ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailFirstLevel is always zero."]
    #[doc = " Note that the \\p array must have been allocated using ::cuArrayCreate or ::cuArray3DCreate. For CUDA arrays obtained"]
    #[doc = " using ::cuMipmappedArrayGetLevel, ::CUDA_ERROR_INVALID_VALUE will be returned. Instead, ::cuMipmappedArrayGetSparseProperties"]
    #[doc = " must be used to obtain the sparse properties of the entire CUDA mipmapped array to which \\p array belongs to."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\param[out] sparseProperties - Pointer to ::CUDA_ARRAY_SPARSE_PROPERTIES"]
    #[doc = " \\param[in] array - CUDA array to get the sparse properties of"]
    #[doc = " \\sa ::cuMipmappedArrayGetSparseProperties, ::cuMemMapArrayAsync"]
    pub fn cuArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        array: CUarray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the layout properties of a sparse CUDA mipmapped array"]
    #[doc = ""]
    #[doc = " Returns the sparse array layout properties in \\p sparseProperties"]
    #[doc = " If the CUDA mipmapped array is not allocated with flag ::CUDA_ARRAY3D_SPARSE"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE will be returned."]
    #[doc = ""]
    #[doc = " For non-layered CUDA mipmapped arrays, ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize returns the"]
    #[doc = " size of the mip tail region. The mip tail region includes all mip levels whose width, height or depth"]
    #[doc = " is less than that of the tile."]
    #[doc = " For layered CUDA mipmapped arrays, if ::CUDA_ARRAY_SPARSE_PROPERTIES::flags contains ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL,"]
    #[doc = " then ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize specifies the size of the mip tail of all layers combined."]
    #[doc = " Otherwise, ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize specifies mip tail size per layer."]
    #[doc = " The returned value of ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailFirstLevel is valid only if ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize is non-zero."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\param[out] sparseProperties - Pointer to ::CUDA_ARRAY_SPARSE_PROPERTIES"]
    #[doc = " \\param[in] mipmap - CUDA mipmapped array to get the sparse properties of"]
    #[doc = " \\sa ::cuArrayGetSparseProperties, ::cuMemMapArrayAsync"]
    pub fn cuMipmappedArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        mipmap: CUmipmappedArray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets a CUDA array plane from a CUDA array"]
    #[doc = ""]
    #[doc = " Returns in \\p pPlaneArray a CUDA array that represents a single format plane"]
    #[doc = " of the CUDA array \\p hArray."]
    #[doc = ""]
    #[doc = " If \\p planeIdx is greater than the maximum number of planes in this array or if the array does"]
    #[doc = " not have a multi-planar format e.g: ::CU_AD_FORMAT_NV12, then ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = " Note that if the \\p hArray has format ::CU_AD_FORMAT_NV12, then passing in 0 for \\p planeIdx returns"]
    #[doc = " a CUDA array of the same size as \\p hArray but with one channel and ::CU_AD_FORMAT_UNSIGNED_INT8 as its format."]
    #[doc = " If 1 is passed for \\p planeIdx, then the returned CUDA array has half the height and width"]
    #[doc = " of \\p hArray with two channels and ::CU_AD_FORMAT_UNSIGNED_INT8 as its format."]
    #[doc = ""]
    #[doc = " \\param pPlaneArray   - Returned CUDA array referenced by the \\p planeIdx"]
    #[doc = " \\param hArray        - Multiplanar CUDA array"]
    #[doc = " \\param planeIdx      - Plane index"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuArrayCreate,"]
    #[doc = " ::cudaGetArrayPlane"]
    pub fn cuArrayGetPlane(
        pPlaneArray: *mut CUarray,
        hArray: CUarray,
        planeIdx: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a CUDA array"]
    #[doc = ""]
    #[doc = " Destroys the CUDA array \\p hArray."]
    #[doc = ""]
    #[doc = " \\param hArray - Array to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_ARRAY_IS_MAPPED,"]
    #[doc = " ::CUDA_ERROR_CONTEXT_IS_DESTROYED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,"]
    #[doc = " ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,"]
    #[doc = " ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,"]
    #[doc = " ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,"]
    #[doc = " ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,"]
    #[doc = " ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,"]
    #[doc = " ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,"]
    #[doc = " ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,"]
    #[doc = " ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,"]
    #[doc = " ::cudaFreeArray"]
    pub fn cuArrayDestroy(hArray: CUarray) -> CUresult;
}
extern "C" {
    pub fn cuArray3DCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArray3DGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY3D_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a CUDA mipmapped array"]
    #[doc = ""]
    #[doc = " Creates a CUDA mipmapped array according to the ::CUDA_ARRAY3D_DESCRIPTOR structure"]
    #[doc = " \\p pMipmappedArrayDesc and returns a handle to the new CUDA mipmapped array in \\p *pHandle."]
    #[doc = " \\p numMipmapLevels specifies the number of mipmap levels to be allocated. This value is"]
    #[doc = " clamped to the range [1, 1 + floor(log2(max(width, height, depth)))]."]
    #[doc = ""]
    #[doc = " The ::CUDA_ARRAY3D_DESCRIPTOR is defined as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef struct {"]
    #[doc = "unsigned int Width;"]
    #[doc = "unsigned int Height;"]
    #[doc = "unsigned int Depth;"]
    #[doc = "CUarray_format Format;"]
    #[doc = "unsigned int NumChannels;"]
    #[doc = "unsigned int Flags;"]
    #[doc = "} CUDA_ARRAY3D_DESCRIPTOR;"]
    #[doc = " \\endcode"]
    #[doc = " where:"]
    #[doc = ""]
    #[doc = " - \\p Width, \\p Height, and \\p Depth are the width, height, and depth of the"]
    #[doc = " CUDA array (in elements); the following types of CUDA arrays can be allocated:"]
    #[doc = "     - A 1D mipmapped array is allocated if \\p Height and \\p Depth extents are both zero."]
    #[doc = "     - A 2D mipmapped array is allocated if only \\p Depth extent is zero."]
    #[doc = "     - A 3D mipmapped array is allocated if all three extents are non-zero."]
    #[doc = "     - A 1D layered CUDA mipmapped array is allocated if only \\p Height is zero and the"]
    #[doc = "       ::CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 1D array. The number"]
    #[doc = "       of layers is determined by the depth extent."]
    #[doc = "     - A 2D layered CUDA mipmapped array is allocated if all three extents are non-zero and"]
    #[doc = "       the ::CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 2D array. The number"]
    #[doc = "       of layers is determined by the depth extent."]
    #[doc = "     - A cubemap CUDA mipmapped array is allocated if all three extents are non-zero and the"]
    #[doc = "       ::CUDA_ARRAY3D_CUBEMAP flag is set. \\p Width must be equal to \\p Height, and"]
    #[doc = "       \\p Depth must be six. A cubemap is a special type of 2D layered CUDA array,"]
    #[doc = "       where the six layers represent the six faces of a cube. The order of the six"]
    #[doc = "       layers in memory is the same as that listed in ::CUarray_cubemap_face."]
    #[doc = "     - A cubemap layered CUDA mipmapped array is allocated if all three extents are non-zero,"]
    #[doc = "       and both, ::CUDA_ARRAY3D_CUBEMAP and ::CUDA_ARRAY3D_LAYERED flags are set."]
    #[doc = "       \\p Width must be equal to \\p Height, and \\p Depth must be a multiple of six."]
    #[doc = "       A cubemap layered CUDA array is a special type of 2D layered CUDA array that"]
    #[doc = "       consists of a collection of cubemaps. The first six layers represent the first"]
    #[doc = "       cubemap, the next six layers form the second cubemap, and so on."]
    #[doc = ""]
    #[doc = " - ::Format specifies the format of the elements; ::CUarray_format is"]
    #[doc = " defined as:"]
    #[doc = " \\code"]
    #[doc = "typedef enum CUarray_format_enum {"]
    #[doc = "CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,"]
    #[doc = "CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,"]
    #[doc = "CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,"]
    #[doc = "CU_AD_FORMAT_SIGNED_INT8 = 0x08,"]
    #[doc = "CU_AD_FORMAT_SIGNED_INT16 = 0x09,"]
    #[doc = "CU_AD_FORMAT_SIGNED_INT32 = 0x0a,"]
    #[doc = "CU_AD_FORMAT_HALF = 0x10,"]
    #[doc = "CU_AD_FORMAT_FLOAT = 0x20"]
    #[doc = "} CUarray_format;"]
    #[doc = "  \\endcode"]
    #[doc = ""]
    #[doc = " - \\p NumChannels specifies the number of packed components per CUDA array"]
    #[doc = " element; it may be 1, 2, or 4;"]
    #[doc = ""]
    #[doc = " - ::Flags may be set to"]
    #[doc = "   - ::CUDA_ARRAY3D_LAYERED to enable creation of layered CUDA mipmapped arrays. If this flag is set,"]
    #[doc = "     \\p Depth specifies the number of layers, not the depth of a 3D array."]
    #[doc = "   - ::CUDA_ARRAY3D_SURFACE_LDST to enable surface references to be bound to individual mipmap levels of"]
    #[doc = "     the CUDA mipmapped array. If this flag is not set, ::cuSurfRefSetArray will fail when attempting to"]
    #[doc = "     bind a mipmap level of the CUDA mipmapped array to a surface reference."]
    #[doc = "   - ::CUDA_ARRAY3D_CUBEMAP to enable creation of mipmapped cubemaps. If this flag is set, \\p Width must be"]
    #[doc = "     equal to \\p Height, and \\p Depth must be six. If the ::CUDA_ARRAY3D_LAYERED flag is also set,"]
    #[doc = "     then \\p Depth must be a multiple of six."]
    #[doc = "   - ::CUDA_ARRAY3D_TEXTURE_GATHER to indicate that the CUDA mipmapped array will be used for texture gather."]
    #[doc = "     Texture gather can only be performed on 2D CUDA mipmapped arrays."]
    #[doc = ""]
    #[doc = " \\p Width, \\p Height and \\p Depth must meet certain size requirements as listed in the following table."]
    #[doc = " All values are specified in elements. Note that for brevity's sake, the full name of the device attribute"]
    #[doc = " is not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH refers to the device attribute"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH."]
    #[doc = ""]
    #[doc = " <table>"]
    #[doc = " <tr><td><b>CUDA array type</b></td>"]
    #[doc = " <td><b>Valid extents that must always be met<br>{(width range in elements), (height range),"]
    #[doc = " (depth range)}</b></td>"]
    #[doc = " <td><b>Valid extents with CUDA_ARRAY3D_SURFACE_LDST set<br>"]
    #[doc = " {(width range in elements), (height range), (depth range)}</b></td></tr>"]
    #[doc = " <tr><td>1D</td>"]
    #[doc = " <td><small>{ (1,TEXTURE1D_MIPMAPPED_WIDTH), 0, 0 }</small></td>"]
    #[doc = " <td><small>{ (1,SURFACE1D_WIDTH), 0, 0 }</small></td></tr>"]
    #[doc = " <tr><td>2D</td>"]
    #[doc = " <td><small>{ (1,TEXTURE2D_MIPMAPPED_WIDTH), (1,TEXTURE2D_MIPMAPPED_HEIGHT), 0 }</small></td>"]
    #[doc = " <td><small>{ (1,SURFACE2D_WIDTH), (1,SURFACE2D_HEIGHT), 0 }</small></td></tr>"]
    #[doc = " <tr><td>3D</td>"]
    #[doc = " <td><small>{ (1,TEXTURE3D_WIDTH), (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) }"]
    #[doc = " <br>OR<br>{ (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE),"]
    #[doc = " (1,TEXTURE3D_DEPTH_ALTERNATE) }</small></td>"]
    #[doc = " <td><small>{ (1,SURFACE3D_WIDTH), (1,SURFACE3D_HEIGHT),"]
    #[doc = " (1,SURFACE3D_DEPTH) }</small></td></tr>"]
    #[doc = " <tr><td>1D Layered</td>"]
    #[doc = " <td><small>{ (1,TEXTURE1D_LAYERED_WIDTH), 0,"]
    #[doc = " (1,TEXTURE1D_LAYERED_LAYERS) }</small></td>"]
    #[doc = " <td><small>{ (1,SURFACE1D_LAYERED_WIDTH), 0,"]
    #[doc = " (1,SURFACE1D_LAYERED_LAYERS) }</small></td></tr>"]
    #[doc = " <tr><td>2D Layered</td>"]
    #[doc = " <td><small>{ (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT),"]
    #[doc = " (1,TEXTURE2D_LAYERED_LAYERS) }</small></td>"]
    #[doc = " <td><small>{ (1,SURFACE2D_LAYERED_WIDTH), (1,SURFACE2D_LAYERED_HEIGHT),"]
    #[doc = " (1,SURFACE2D_LAYERED_LAYERS) }</small></td></tr>"]
    #[doc = " <tr><td>Cubemap</td>"]
    #[doc = " <td><small>{ (1,TEXTURECUBEMAP_WIDTH), (1,TEXTURECUBEMAP_WIDTH), 6 }</small></td>"]
    #[doc = " <td><small>{ (1,SURFACECUBEMAP_WIDTH),"]
    #[doc = " (1,SURFACECUBEMAP_WIDTH), 6 }</small></td></tr>"]
    #[doc = " <tr><td>Cubemap Layered</td>"]
    #[doc = " <td><small>{ (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH),"]
    #[doc = " (1,TEXTURECUBEMAP_LAYERED_LAYERS) }</small></td>"]
    #[doc = " <td><small>{ (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_WIDTH),"]
    #[doc = " (1,SURFACECUBEMAP_LAYERED_LAYERS) }</small></td></tr>"]
    #[doc = " </table>"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param pHandle             - Returned mipmapped array"]
    #[doc = " \\param pMipmappedArrayDesc - mipmapped array descriptor"]
    #[doc = " \\param numMipmapLevels     - Number of mipmap levels"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMipmappedArrayDestroy,"]
    #[doc = " ::cuMipmappedArrayGetLevel,"]
    #[doc = " ::cuArrayCreate,"]
    #[doc = " ::cudaMallocMipmappedArray"]
    pub fn cuMipmappedArrayCreate(
        pHandle: *mut CUmipmappedArray,
        pMipmappedArrayDesc: *const CUDA_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets a mipmap level of a CUDA mipmapped array"]
    #[doc = ""]
    #[doc = " Returns in \\p *pLevelArray a CUDA array that represents a single mipmap level"]
    #[doc = " of the CUDA mipmapped array \\p hMipmappedArray."]
    #[doc = ""]
    #[doc = " If \\p level is greater than the maximum number of levels in this mipmapped array,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = " \\param pLevelArray     - Returned mipmap level CUDA array"]
    #[doc = " \\param hMipmappedArray - CUDA mipmapped array"]
    #[doc = " \\param level           - Mipmap level"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMipmappedArrayCreate,"]
    #[doc = " ::cuMipmappedArrayDestroy,"]
    #[doc = " ::cuArrayCreate,"]
    #[doc = " ::cudaGetMipmappedArrayLevel"]
    pub fn cuMipmappedArrayGetLevel(
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a CUDA mipmapped array"]
    #[doc = ""]
    #[doc = " Destroys the CUDA mipmapped array \\p hMipmappedArray."]
    #[doc = ""]
    #[doc = " \\param hMipmappedArray - Mipmapped array to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_ARRAY_IS_MAPPED,"]
    #[doc = " ::CUDA_ERROR_CONTEXT_IS_DESTROYED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMipmappedArrayCreate,"]
    #[doc = " ::cuMipmappedArrayGetLevel,"]
    #[doc = " ::cuArrayCreate,"]
    #[doc = " ::cudaFreeMipmappedArray"]
    pub fn cuMipmappedArrayDestroy(hMipmappedArray: CUmipmappedArray) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocate an address range reservation."]
    #[doc = ""]
    #[doc = " Reserves a virtual address range based on the given parameters, giving"]
    #[doc = " the starting address of the range in \\p ptr.  This API requires a system that"]
    #[doc = " supports UVA.  The size and address parameters must be a multiple of the"]
    #[doc = " host page size and the alignment must be a power of two or zero for default"]
    #[doc = " alignment."]
    #[doc = ""]
    #[doc = " \\param[out] ptr       - Resulting pointer to start of virtual address range allocated"]
    #[doc = " \\param[in]  size      - Size of the reserved virtual address range requested"]
    #[doc = " \\param[in]  alignment - Alignment of the reserved virtual address range requested"]
    #[doc = " \\param[in]  addr      - Fixed starting address range requested"]
    #[doc = " \\param[in]  flags     - Currently unused, must be zero"]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAddressFree"]
    pub fn cuMemAddressReserve(
        ptr: *mut CUdeviceptr,
        size: size_t,
        alignment: size_t,
        addr: CUdeviceptr,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Free an address range reservation."]
    #[doc = ""]
    #[doc = " Frees a virtual address range reserved by cuMemAddressReserve.  The size"]
    #[doc = " must match what was given to memAddressReserve and the ptr given must"]
    #[doc = " match what was returned from memAddressReserve."]
    #[doc = ""]
    #[doc = " \\param[in] ptr  - Starting address of the virtual address range to free"]
    #[doc = " \\param[in] size - Size of the virtual address region to free"]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAddressReserve"]
    pub fn cuMemAddressFree(ptr: CUdeviceptr, size: size_t) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a CUDA memory handle representing a memory allocation of a given size described by the given properties"]
    #[doc = ""]
    #[doc = " This creates a memory allocation on the target device specified through the"]
    #[doc = " \\p prop strcuture. The created allocation will not have any device or host"]
    #[doc = " mappings. The generic memory \\p handle for the allocation can be"]
    #[doc = " mapped to the address space of calling process via ::cuMemMap. This handle"]
    #[doc = " cannot be transmitted directly to other processes (see"]
    #[doc = " ::cuMemExportToShareableHandle).  On Windows, the caller must also pass"]
    #[doc = " an LPSECURITYATTRIBUTE in \\p prop to be associated with this handle which"]
    #[doc = " limits or allows access to this handle for a recepient process (see"]
    #[doc = " ::CUmemAllocationProp::win32HandleMetaData for more).  The \\p size of this"]
    #[doc = " allocation must be a multiple of the the value given via"]
    #[doc = " ::cuMemGetAllocationGranularity with the ::CU_MEM_ALLOC_GRANULARITY_MINIMUM"]
    #[doc = " flag."]
    #[doc = " If ::CUmemAllocationProp::allocFlags::usage contains ::CU_MEM_CREATE_USAGE_TILE_POOL flag then"]
    #[doc = " the memory allocation is intended only to be used as backing tile pool for sparse CUDA arrays"]
    #[doc = " and sparse CUDA mipmapped arrays."]
    #[doc = " (see ::cuMemMapArrayAsync)."]
    #[doc = ""]
    #[doc = " \\param[out] handle - Value of handle returned. All operations on this allocation are to be performed using this handle."]
    #[doc = " \\param[in]  size   - Size of the allocation requested"]
    #[doc = " \\param[in]  prop   - Properties of the allocation to create."]
    #[doc = " \\param[in]  flags  - flags for future use, must be zero now."]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemRelease, ::cuMemExportToShareableHandle, ::cuMemImportFromShareableHandle"]
    pub fn cuMemCreate(
        handle: *mut CUmemGenericAllocationHandle,
        size: size_t,
        prop: *const CUmemAllocationProp,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate."]
    #[doc = ""]
    #[doc = " Frees the memory that was allocated on a device through cuMemCreate."]
    #[doc = ""]
    #[doc = " The memory allocation will be freed when all outstanding mappings to the memory"]
    #[doc = " are unmapped and when all outstanding references to the handle (including it's"]
    #[doc = " shareable counterparts) are also released. The generic memory handle can be"]
    #[doc = " freed when there are still outstanding mappings made with this handle. Each"]
    #[doc = " time a recepient process imports a shareable handle, it needs to pair it with"]
    #[doc = " ::cuMemRelease for the handle to be freed.  If \\p handle is not a valid handle"]
    #[doc = " the behavior is undefined."]
    #[doc = ""]
    #[doc = " \\param[in] handle Value of handle which was returned previously by cuMemCreate."]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemCreate"]
    pub fn cuMemRelease(handle: CUmemGenericAllocationHandle) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps an allocation handle to a reserved virtual address range."]
    #[doc = ""]
    #[doc = " Maps bytes of memory represented by \\p handle starting from byte \\p offset to"]
    #[doc = " \\p size to address range [\\p addr, \\p addr + \\p size]. This range must be an"]
    #[doc = " address reservation previously reserved with ::cuMemAddressReserve, and"]
    #[doc = " \\p offset + \\p size must be less than the size of the memory allocation."]
    #[doc = " Both \\p ptr, \\p size, and \\p offset must be a multiple of the value given via"]
    #[doc = " ::cuMemGetAllocationGranularity with the ::CU_MEM_ALLOC_GRANULARITY_MINIMUM flag."]
    #[doc = ""]
    #[doc = " Please note calling ::cuMemMap does not make the address accessible,"]
    #[doc = " the caller needs to update accessibility of a contiguous mapped VA"]
    #[doc = " range by calling ::cuMemSetAccess."]
    #[doc = ""]
    #[doc = " Once a recipient process obtains a shareable memory handle"]
    #[doc = " from ::cuMemImportFromShareableHandle, the process must"]
    #[doc = " use ::cuMemMap to map the memory into its address ranges before"]
    #[doc = " setting accessibility with ::cuMemSetAccess."]
    #[doc = ""]
    #[doc = " ::cuMemMap can only create mappings on VA range reservations"]
    #[doc = " that are not currently mapped."]
    #[doc = ""]
    #[doc = " \\param[in] ptr    - Address where memory will be mapped."]
    #[doc = " \\param[in] size   - Size of the memory mapping."]
    #[doc = " \\param[in] offset - Offset into the memory represented by"]
    #[doc = "                   - \\p handle from which to start mapping"]
    #[doc = "                   - Note: currently must be zero."]
    #[doc = " \\param[in] handle - Handle to a shareable memory"]
    #[doc = " \\param[in] flags  - flags for future use, must be zero now."]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemUnmap, ::cuMemSetAccess, ::cuMemCreate, ::cuMemAddressReserve, ::cuMemImportFromShareableHandle"]
    pub fn cuMemMap(
        ptr: CUdeviceptr,
        size: size_t,
        offset: size_t,
        handle: CUmemGenericAllocationHandle,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays"]
    #[doc = ""]
    #[doc = " Performs map or unmap operations on subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays."]
    #[doc = " Each operation is specified by a ::CUarrayMapInfo entry in the \\p mapInfoList array of size \\p count."]
    #[doc = " The structure ::CUarrayMapInfo is defined as follow:"]
    #[doc = "\\code"]
    #[doc = "typedef struct CUarrayMapInfo_st {"]
    #[doc = "CUresourcetype resourceType;"]
    #[doc = "union {"]
    #[doc = "CUmipmappedArray mipmap;"]
    #[doc = "CUarray array;"]
    #[doc = "} resource;"]
    #[doc = ""]
    #[doc = "CUarraySparseSubresourceType subresourceType;"]
    #[doc = "union {"]
    #[doc = "struct {"]
    #[doc = "unsigned int level;"]
    #[doc = "unsigned int layer;"]
    #[doc = "unsigned int offsetX;"]
    #[doc = "unsigned int offsetY;"]
    #[doc = "unsigned int offsetZ;"]
    #[doc = "unsigned int extentWidth;"]
    #[doc = "unsigned int extentHeight;"]
    #[doc = "unsigned int extentDepth;"]
    #[doc = "} sparseLevel;"]
    #[doc = "struct {"]
    #[doc = "unsigned int layer;"]
    #[doc = "unsigned long long offset;"]
    #[doc = "unsigned long long size;"]
    #[doc = "} miptail;"]
    #[doc = "} subresource;"]
    #[doc = ""]
    #[doc = "CUmemOperationType memOperationType;"]
    #[doc = ""]
    #[doc = "CUmemHandleType memHandleType;"]
    #[doc = "union {"]
    #[doc = "CUmemGenericAllocationHandle memHandle;"]
    #[doc = "} memHandle;"]
    #[doc = ""]
    #[doc = "unsigned long long offset;"]
    #[doc = "unsigned int deviceBitMask;"]
    #[doc = "unsigned int flags;"]
    #[doc = "unsigned int reserved[2];"]
    #[doc = "} CUarrayMapInfo;"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = " where ::CUarrayMapInfo::resourceType specifies the type of resource to be operated on."]
    #[doc = " If ::CUarrayMapInfo::resourceType is set to ::CUresourcetype::CU_RESOURCE_TYPE_ARRAY then"]
    #[doc = " ::CUarrayMapInfo::resource::array must be set to a valid sparse CUDA array handle."]
    #[doc = " The CUDA array must be either a 2D, 2D layered or 3D CUDA array and must have been allocated using"]
    #[doc = " ::cuArrayCreate or ::cuArray3DCreate with the flag ::CUDA_ARRAY3D_SPARSE."]
    #[doc = " For CUDA arrays obtained using ::cuMipmappedArrayGetLevel, ::CUDA_ERROR_INVALID_VALUE will be returned."]
    #[doc = " If ::CUarrayMapInfo::resourceType is set to ::CUresourcetype::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY"]
    #[doc = " then ::CUarrayMapInfo::resource::mipmap must be set to a valid sparse CUDA mipmapped array handle."]
    #[doc = " The CUDA mipmapped array must be either a 2D, 2D layered or 3D CUDA mipmapped array and must have been"]
    #[doc = " allocated using ::cuMipmappedArrayCreate with the flag ::CUDA_ARRAY3D_SPARSE."]
    #[doc = ""]
    #[doc = " ::CUarrayMapInfo::subresourceType specifies the type of subresource within the resource."]
    #[doc = " ::CUarraySparseSubresourceType_enum is defined as:"]
    #[doc = "\\code"]
    #[doc = "typedef enum CUarraySparseSubresourceType_enum {"]
    #[doc = "CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,"]
    #[doc = "CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1"]
    #[doc = "} CUarraySparseSubresourceType;"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = " where ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL indicates a"]
    #[doc = " sparse-miplevel which spans at least one tile in every dimension. The remaining miplevels which"]
    #[doc = " are too small to span at least one tile in any dimension constitute the mip tail region as indicated by"]
    #[doc = " ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL subresource type."]
    #[doc = ""]
    #[doc = " If ::CUarrayMapInfo::subresourceType is set to ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL"]
    #[doc = " then ::CUarrayMapInfo::subresource::sparseLevel struct must contain valid array subregion offsets and extents."]
    #[doc = " The ::CUarrayMapInfo::subresource::sparseLevel::offsetX, ::CUarrayMapInfo::subresource::sparseLevel::offsetY"]
    #[doc = " and ::CUarrayMapInfo::subresource::sparseLevel::offsetZ must specify valid X, Y and Z offsets respectively."]
    #[doc = " The ::CUarrayMapInfo::subresource::sparseLevel::extentWidth, ::CUarrayMapInfo::subresource::sparseLevel::extentHeight"]
    #[doc = " and ::CUarrayMapInfo::subresource::sparseLevel::extentDepth must specify valid width, height and depth extents respectively."]
    #[doc = " These offsets and extents must be aligned to the corresponding tile dimension."]
    #[doc = " For CUDA mipmapped arrays ::CUarrayMapInfo::subresource::sparseLevel::level must specify a valid mip level index. Otherwise,"]
    #[doc = " must be zero."]
    #[doc = " For layered CUDA arrays and layered CUDA mipmapped arrays ::CUarrayMapInfo::subresource::sparseLevel::layer must specify a valid layer index. Otherwise,"]
    #[doc = " must be zero."]
    #[doc = " ::CUarrayMapInfo::subresource::sparseLevel::offsetZ must be zero and ::CUarrayMapInfo::subresource::sparseLevel::extentDepth"]
    #[doc = " must be set to 1 for 2D and 2D layered CUDA arrays and CUDA mipmapped arrays."]
    #[doc = " Tile extents can be obtained by calling ::cuArrayGetSparseProperties and ::cuMipmappedArrayGetSparseProperties"]
    #[doc = ""]
    #[doc = " If ::CUarrayMapInfo::subresourceType is set to ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL"]
    #[doc = " then ::CUarrayMapInfo::subresource::miptail struct must contain valid mip tail offset in"]
    #[doc = " ::CUarrayMapInfo::subresource::miptail::offset and size in ::CUarrayMapInfo::subresource::miptail::size."]
    #[doc = " Both, mip tail offset and mip tail size must be aligned to the tile size."]
    #[doc = " For layered CUDA mipmapped arrays which don't have the flag ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL set in ::CUDA_ARRAY_SPARSE_PROPERTIES::flags"]
    #[doc = " as returned by ::cuMipmappedArrayGetSparseProperties, ::CUarrayMapInfo::subresource::miptail::layer must specify a valid layer index."]
    #[doc = " Otherwise, must be zero."]
    #[doc = ""]
    #[doc = " ::CUarrayMapInfo::memOperationType specifies the type of operation. ::CUmemOperationType is defined as:"]
    #[doc = "\\code"]
    #[doc = "typedef enum CUmemOperationType_enum {"]
    #[doc = "CU_MEM_OPERATION_TYPE_MAP = 1,"]
    #[doc = "CU_MEM_OPERATION_TYPE_UNMAP = 2"]
    #[doc = "} CUmemOperationType;"]
    #[doc = "\\endcode"]
    #[doc = " If ::CUarrayMapInfo::memOperationType is set to ::CUmemOperationType::CU_MEM_OPERATION_TYPE_MAP then the subresource"]
    #[doc = " will be mapped onto the tile pool memory specified by ::CUarrayMapInfo::memHandle at offset ::CUarrayMapInfo::offset."]
    #[doc = " The tile pool allocation has to be created by specifying the ::CU_MEM_CREATE_USAGE_TILE_POOL flag when calling ::cuMemCreate. Also,"]
    #[doc = " ::CUarrayMapInfo::memHandleType must be set to ::CUmemHandleType::CU_MEM_HANDLE_TYPE_GENERIC."]
    #[doc = ""]
    #[doc = " If ::CUarrayMapInfo::memOperationType is set to ::CUmemOperationType::CU_MEM_OPERATION_TYPE_UNMAP then an unmapping operation"]
    #[doc = " is performed. ::CUarrayMapInfo::memHandle must be NULL."]
    #[doc = ""]
    #[doc = " ::CUarrayMapInfo::deviceBitMask specifies the list of devices that must map or unmap physical memory."]
    #[doc = " Currently, this mask must have exactly one bit set, and the corresponding device must match the device associated with the stream."]
    #[doc = " If ::CUarrayMapInfo::memOperationType is set to ::CUmemOperationType::CU_MEM_OPERATION_TYPE_MAP, the device must also match"]
    #[doc = " the device associated with the tile pool memory allocation as specified by ::CUarrayMapInfo::memHandle."]
    #[doc = ""]
    #[doc = " ::CUarrayMapInfo::flags and ::CUarrayMapInfo::reserved[] are unused and must be set to zero."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = ""]
    #[doc = " \\param[in] mapInfoList - List of ::CUarrayMapInfo"]
    #[doc = " \\param[in] count       - Count of ::CUarrayMapInfo  in \\p mapInfoList"]
    #[doc = " \\param[in] hStream     - Stream identifier for the stream to use for map or unmap operations"]
    #[doc = ""]
    #[doc = " \\sa ::cuMipmappedArrayCreate, ::cuArrayCreate, ::cuArray3DCreate, ::cuMemCreate, ::cuArrayGetSparseProperties, ::cuMipmappedArrayGetSparseProperties"]
    pub fn cuMemMapArrayAsync(
        mapInfoList: *mut CUarrayMapInfo,
        count: ::std::os::raw::c_uint,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unmap the backing memory of a given address range."]
    #[doc = ""]
    #[doc = " The range must be the entire contiguous address range that was mapped to.  In"]
    #[doc = " other words, ::cuMemUnmap cannot unmap a sub-range of an address range mapped"]
    #[doc = " by ::cuMemCreate / ::cuMemMap.  Any backing memory allocations will be freed"]
    #[doc = " if there are no existing mappings and there are no unreleased memory handles."]
    #[doc = ""]
    #[doc = " When ::cuMemUnmap returns successfully the address range is converted to an"]
    #[doc = " address reservation and can be used for a future calls to ::cuMemMap.  Any new"]
    #[doc = " mapping to this virtual address will need to have access granted through"]
    #[doc = " ::cuMemSetAccess, as all mappings start with no accessibility setup."]
    #[doc = ""]
    #[doc = " \\param[in] ptr  - Starting address for the virtual address range to unmap"]
    #[doc = " \\param[in] size - Size of the virtual address range to unmap"]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_sync"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemCreate, ::cuMemAddressReserve"]
    pub fn cuMemUnmap(ptr: CUdeviceptr, size: size_t) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set the access flags for each location specified in \\p desc for the given virtual address range"]
    #[doc = ""]
    #[doc = " Given the virtual address range via \\p ptr and \\p size, and the locations"]
    #[doc = " in the array given by \\p desc and \\p count, set the access flags for the"]
    #[doc = " target locations.  The range must be a fully mapped address range"]
    #[doc = " containing all allocations created by ::cuMemMap / ::cuMemCreate."]
    #[doc = ""]
    #[doc = " \\param[in] ptr   - Starting address for the virtual address range"]
    #[doc = " \\param[in] size  - Length of the virtual address range"]
    #[doc = " \\param[in] desc  - Array of ::CUmemAccessDesc that describe how to change the"]
    #[doc = "                  - mapping for each location specified"]
    #[doc = " \\param[in] count - Number of ::CUmemAccessDesc in \\p desc"]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_sync"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemSetAccess, ::cuMemCreate, :cuMemMap"]
    pub fn cuMemSetAccess(
        ptr: CUdeviceptr,
        size: size_t,
        desc: *const CUmemAccessDesc,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get the access \\p flags set for the given \\p location and \\p ptr"]
    #[doc = ""]
    #[doc = " \\param[out] flags   - Flags set for this location"]
    #[doc = " \\param[in] location - Location in which to check the flags for"]
    #[doc = " \\param[in] ptr      - Address in which to check the access flags for"]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemSetAccess"]
    pub fn cuMemGetAccess(
        flags: *mut ::std::os::raw::c_ulonglong,
        location: *const CUmemLocation,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Exports an allocation to a requested shareable handle type"]
    #[doc = ""]
    #[doc = " Given a CUDA memory handle, create a shareable memory"]
    #[doc = " allocation handle that can be used to share the memory with other"]
    #[doc = " processes. The recipient process can convert the shareable handle back into a"]
    #[doc = " CUDA memory handle using ::cuMemImportFromShareableHandle and map"]
    #[doc = " it with ::cuMemMap. The implementation of what this handle is and how it"]
    #[doc = " can be transferred is defined by the requested handle type in \\p handleType"]
    #[doc = ""]
    #[doc = " Once all shareable handles are closed and the allocation is released, the allocated"]
    #[doc = " memory referenced will be released back to the OS and uses of the CUDA handle afterward"]
    #[doc = " will lead to undefined behavior."]
    #[doc = ""]
    #[doc = " This API can also be used in conjunction with other APIs (e.g. Vulkan, OpenGL)"]
    #[doc = " that support importing memory from the shareable type"]
    #[doc = ""]
    #[doc = " \\param[out] shareableHandle - Pointer to the location in which to store the requested handle type"]
    #[doc = " \\param[in] handle           - CUDA handle for the memory allocation"]
    #[doc = " \\param[in] handleType       - Type of shareable handle requested (defines type and size of the \\p shareableHandle output parameter)"]
    #[doc = " \\param[in] flags            - Reserved, must be zero"]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemImportFromShareableHandle"]
    pub fn cuMemExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        handle: CUmemGenericAllocationHandle,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Imports an allocation from a requested shareable handle type."]
    #[doc = ""]
    #[doc = " If the current process cannot support the memory described by this shareable"]
    #[doc = " handle, this API will error as CUDA_ERROR_NOT_SUPPORTED."]
    #[doc = ""]
    #[doc = " \\note Importing shareable handles exported from some graphics APIs(VUlkan, OpenGL, etc)"]
    #[doc = " created on devices under an SLI group may not be supported, and thus this API will"]
    #[doc = " return CUDA_ERROR_NOT_SUPPORTED."]
    #[doc = " There is no guarantee that the contents of \\p handle will be the same CUDA memory handle"]
    #[doc = " for the same given OS shareable handle, or the same underlying allocation."]
    #[doc = ""]
    #[doc = " \\param[out] handle       - CUDA Memory handle for the memory allocation."]
    #[doc = " \\param[in]  osHandle     - Shareable Handle representing the memory allocation that is to be imported."]
    #[doc = " \\param[in]  shHandleType - handle type of the exported handle ::CUmemAllocationHandleType."]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemExportToShareableHandle, ::cuMemMap, ::cuMemRelease"]
    pub fn cuMemImportFromShareableHandle(
        handle: *mut CUmemGenericAllocationHandle,
        osHandle: *mut ::std::os::raw::c_void,
        shHandleType: CUmemAllocationHandleType,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Calculates either the minimal or recommended granularity"]
    #[doc = ""]
    #[doc = " Calculates either the minimal or recommended granularity"]
    #[doc = " for a given allocation specification and returns it in granularity.  This"]
    #[doc = " granularity can be used as a multiple for alignment, size, or address mapping."]
    #[doc = ""]
    #[doc = " \\param[out] granularity Returned granularity."]
    #[doc = " \\param[in]  prop Property for which to determine the granularity for"]
    #[doc = " \\param[in]  option Determines which granularity to return"]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemCreate, ::cuMemMap"]
    pub fn cuMemGetAllocationGranularity(
        granularity: *mut size_t,
        prop: *const CUmemAllocationProp,
        option: CUmemAllocationGranularity_flags,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retrieve the contents of the property structure defining properties for this handle"]
    #[doc = ""]
    #[doc = " \\param[out] prop  - Pointer to a properties structure which will hold the information about this handle"]
    #[doc = " \\param[in] handle - Handle which to perform the query on"]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemCreate, ::cuMemImportFromShareableHandle"]
    pub fn cuMemGetAllocationPropertiesFromHandle(
        prop: *mut CUmemAllocationProp,
        handle: CUmemGenericAllocationHandle,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Given an address \\p addr, returns the allocation handle of the backing memory allocation."]
    #[doc = ""]
    #[doc = " The handle is guaranteed to be the same handle value used to map the memory. If the address"]
    #[doc = " requested is not mapped, the function will fail. The returned handle must be released with"]
    #[doc = " corresponding number of calls to ::cuMemRelease."]
    #[doc = ""]
    #[doc = " \\note The address \\p addr, can be any address in a range previously mapped"]
    #[doc = " by ::cuMemMap, and not necessarily the start address."]
    #[doc = ""]
    #[doc = " \\param[out] handle CUDA Memory handle for the backing memory allocation."]
    #[doc = " \\param[in] addr Memory address to query, that has been mapped previously."]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_PERMITTED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemCreate, ::cuMemRelease, ::cuMemMap"]
    pub fn cuMemRetainAllocationHandle(
        handle: *mut CUmemGenericAllocationHandle,
        addr: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Frees memory with stream ordered semantics"]
    #[doc = ""]
    #[doc = " Inserts a free operation into \\p hStream."]
    #[doc = " The allocation must not be accessed after stream execution reaches the free."]
    #[doc = " After this API returns, accessing the memory from any subsequent work launched on the GPU"]
    #[doc = " or querying its pointer attributes results in undefined behavior."]
    #[doc = ""]
    #[doc = " \\note During stream capture, this function results in the creation of a free node and"]
    #[doc = "       must therefore be passed the address of a graph allocation."]
    #[doc = ""]
    #[doc = " \\param dptr - memory to free"]
    #[doc = " \\param hStream - The stream establishing the stream ordering contract."]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT (default stream specified with no current context),"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    pub fn cuMemFreeAsync(dptr: CUdeviceptr, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates memory with stream ordered semantics"]
    #[doc = ""]
    #[doc = " Inserts an allocation operation into \\p hStream."]
    #[doc = " A pointer to the allocated memory is returned immediately in *dptr."]
    #[doc = " The allocation must not be accessed until the the allocation operation completes."]
    #[doc = " The allocation comes from the memory pool current to the stream's device."]
    #[doc = ""]
    #[doc = " \\note The default memory pool of a device contains device memory from that device."]
    #[doc = " \\note Basic stream ordering allows future work submitted into the same stream to use the allocation."]
    #[doc = "       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation"]
    #[doc = "       operation completes before work submitted in a separate stream runs."]
    #[doc = " \\note During stream capture, this function results in the creation of an allocation node.  In this case,"]
    #[doc = "       the allocation is owned by the graph instead of the memory pool. The memory pool's properties"]
    #[doc = "       are used to set the node's creation parameters."]
    #[doc = ""]
    #[doc = " \\param[out] dptr    - Returned device pointer"]
    #[doc = " \\param[in] bytesize - Number of bytes to allocate"]
    #[doc = " \\param[in] hStream  - The stream establishing the stream ordering contract and the memory pool to allocate from"]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT (default stream specified with no current context),"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocFromPoolAsync, ::cuMemFreeAsync, ::cuDeviceSetMemPool,"]
    #[doc = "     ::cuDeviceGetDefaultMemPool, ::cuDeviceGetMemPool, ::cuMemPoolCreate,"]
    #[doc = "     ::cuMemPoolSetAccess, ::cuMemPoolSetAttribute"]
    pub fn cuMemAllocAsync(dptr: *mut CUdeviceptr, bytesize: size_t, hStream: CUstream)
        -> CUresult;
}
extern "C" {
    #[doc = " \\brief Tries to release memory back to the OS"]
    #[doc = ""]
    #[doc = " Releases memory back to the OS until the pool contains fewer than minBytesToKeep"]
    #[doc = " reserved bytes, or there is no more memory that the allocator can safely release."]
    #[doc = " The allocator cannot release OS allocations that back outstanding asynchronous allocations."]
    #[doc = " The OS allocations may happen at different granularity from the user allocations."]
    #[doc = ""]
    #[doc = " \\note: Allocations that have not been freed count as outstanding."]
    #[doc = " \\note: Allocations that have been asynchronously freed but whose completion has"]
    #[doc = "        not been observed on the host (eg. by a synchronize) can count as outstanding."]
    #[doc = ""]
    #[doc = " \\param[in] pool           - The memory pool to trim"]
    #[doc = " \\param[in] minBytesToKeep - If the pool has less than minBytesToKeep reserved,"]
    #[doc = " the TrimTo operation is a no-op.  Otherwise the pool will be guaranteed to have"]
    #[doc = " at least minBytesToKeep bytes reserved after the operation."]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,"]
    #[doc = "     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolTrimTo(pool: CUmemoryPool, minBytesToKeep: size_t) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets attributes of a memory pool"]
    #[doc = ""]
    #[doc = " Supported attributes are:"]
    #[doc = " - ::CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: (value type = cuuint64_t)"]
    #[doc = "                    Amount of reserved memory in bytes to hold onto before trying"]
    #[doc = "                    to release memory back to the OS. When more than the release"]
    #[doc = "                    threshold bytes of memory are held by the memory pool, the"]
    #[doc = "                    allocator will try to release memory back to the OS on the"]
    #[doc = "                    next call to stream, event or context synchronize. (default 0)"]
    #[doc = " - ::CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES: (value type = int)"]
    #[doc = "                    Allow ::cuMemAllocAsync to use memory asynchronously freed"]
    #[doc = "                    in another stream as long as a stream ordering dependency"]
    #[doc = "                    of the allocating stream on the free action exists."]
    #[doc = "                    Cuda events and null stream interactions can create the required"]
    #[doc = "                    stream ordered dependencies. (default enabled)"]
    #[doc = " - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC: (value type = int)"]
    #[doc = "                    Allow reuse of already completed frees when there is no dependency"]
    #[doc = "                    between the free and allocation. (default enabled)"]
    #[doc = " - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES: (value type = int)"]
    #[doc = "                    Allow ::cuMemAllocAsync to insert new stream dependencies"]
    #[doc = "                    in order to establish the stream ordering required to reuse"]
    #[doc = "                    a piece of memory released by ::cuMemFreeAsync (default enabled)."]
    #[doc = " - ::CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: (value type = cuuint64_t)"]
    #[doc = "                    Reset the high watermark that tracks the amount of backing memory that was"]
    #[doc = "                    allocated for the memory pool. It is illegal to set this attribute to a non-zero value."]
    #[doc = " - ::CU_MEMPOOL_ATTR_USED_MEM_HIGH: (value type = cuuint64_t)"]
    #[doc = "                    Reset the high watermark that tracks the amount of used memory that was"]
    #[doc = "                    allocated for the memory pool."]
    #[doc = ""]
    #[doc = " \\param[in] pool  - The memory pool to modify"]
    #[doc = " \\param[in] attr  - The attribute to modify"]
    #[doc = " \\param[in] value - Pointer to the value to assign"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,"]
    #[doc = "     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolSetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets attributes of a memory pool"]
    #[doc = ""]
    #[doc = " Supported attributes are:"]
    #[doc = " - ::CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: (value type = cuuint64_t)"]
    #[doc = "                    Amount of reserved memory in bytes to hold onto before trying"]
    #[doc = "                    to release memory back to the OS. When more than the release"]
    #[doc = "                    threshold bytes of memory are held by the memory pool, the"]
    #[doc = "                    allocator will try to release memory back to the OS on the"]
    #[doc = "                    next call to stream, event or context synchronize. (default 0)"]
    #[doc = " - ::CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES: (value type = int)"]
    #[doc = "                    Allow ::cuMemAllocAsync to use memory asynchronously freed"]
    #[doc = "                    in another stream as long as a stream ordering dependency"]
    #[doc = "                    of the allocating stream on the free action exists."]
    #[doc = "                    Cuda events and null stream interactions can create the required"]
    #[doc = "                    stream ordered dependencies. (default enabled)"]
    #[doc = " - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC: (value type = int)"]
    #[doc = "                    Allow reuse of already completed frees when there is no dependency"]
    #[doc = "                    between the free and allocation. (default enabled)"]
    #[doc = " - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES: (value type = int)"]
    #[doc = "                    Allow ::cuMemAllocAsync to insert new stream dependencies"]
    #[doc = "                    in order to establish the stream ordering required to reuse"]
    #[doc = "                    a piece of memory released by ::cuMemFreeAsync (default enabled)."]
    #[doc = " - ::CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT: (value type = cuuint64_t)"]
    #[doc = "                    Amount of backing memory currently allocated for the mempool"]
    #[doc = " - ::CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: (value type = cuuint64_t)"]
    #[doc = "                    High watermark of backing memory allocated for the mempool since the"]
    #[doc = "                    last time it was reset."]
    #[doc = " - ::CU_MEMPOOL_ATTR_USED_MEM_CURRENT: (value type = cuuint64_t)"]
    #[doc = "                    Amount of memory from the pool that is currently in use by the application."]
    #[doc = " - ::CU_MEMPOOL_ATTR_USED_MEM_HIGH: (value type = cuuint64_t)"]
    #[doc = "                    High watermark of the amount of memory from the pool that was in use by the application."]
    #[doc = ""]
    #[doc = " \\param[in] pool   - The memory pool to get attributes of"]
    #[doc = " \\param[in] attr   - The attribute to get"]
    #[doc = " \\param[out] value - Retrieved value"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,"]
    #[doc = "     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolGetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Controls visibility of pools between devices"]
    #[doc = ""]
    #[doc = " \\param[in] pool  - The pool being modified"]
    #[doc = " \\param[in] map   - Array of access descriptors. Each descriptor instructs the access to enable for a single gpu."]
    #[doc = " \\param[in] count - Number of descriptors in the map array."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,"]
    #[doc = "     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolSetAccess(
        pool: CUmemoryPool,
        map: *const CUmemAccessDesc,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the accessibility of a pool from a device"]
    #[doc = ""]
    #[doc = " Returns the accessibility of the pool's memory from the specified location."]
    #[doc = ""]
    #[doc = " \\param[out] flags   - the accessibility of the pool from the specified location"]
    #[doc = " \\param[in] memPool  - the pool being queried"]
    #[doc = " \\param[in] location - the location accessing the pool"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,"]
    #[doc = "     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolGetAccess(
        flags: *mut CUmemAccess_flags,
        memPool: CUmemoryPool,
        location: *mut CUmemLocation,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memory pool"]
    #[doc = ""]
    #[doc = " Creates a CUDA memory pool and returns the handle in \\p pool.  The \\p poolProps determines"]
    #[doc = " the properties of the pool such as the backing device and IPC capabilities."]
    #[doc = ""]
    #[doc = " By default, the pool's memory will be accessible from the device it is allocated on."]
    #[doc = ""]
    #[doc = " \\note Specifying CU_MEM_HANDLE_TYPE_NONE creates a memory pool that will not support IPC."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = ""]
    #[doc = " \\sa ::cuDeviceSetMemPool, ::cuDeviceGetMemPool, ::cuDeviceGetDefaultMemPool,"]
    #[doc = "     ::cuMemAllocFromPoolAsync, ::cuMemPoolExportToShareableHandle"]
    pub fn cuMemPoolCreate(pool: *mut CUmemoryPool, poolProps: *const CUmemPoolProps) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys the specified memory pool"]
    #[doc = ""]
    #[doc = " If any pointers obtained from this pool haven't been freed or"]
    #[doc = " the pool has free operations that haven't completed"]
    #[doc = " when ::cuMemPoolDestroy is invoked, the function will return immediately and the"]
    #[doc = " resources associated with the pool will be released automatically"]
    #[doc = " once there are no more outstanding allocations."]
    #[doc = ""]
    #[doc = " Destroying the current mempool of a device sets the default mempool of"]
    #[doc = " that device as the current mempool for that device."]
    #[doc = ""]
    #[doc = " \\note A device's default memory pool cannot be destroyed."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemFreeAsync, ::cuDeviceSetMemPool, ::cuDeviceGetMemPool,"]
    #[doc = "     ::cuDeviceGetDefaultMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolDestroy(pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates memory from a specified pool with stream ordered semantics."]
    #[doc = ""]
    #[doc = " Inserts an allocation operation into \\p hStream."]
    #[doc = " A pointer to the allocated memory is returned immediately in *dptr."]
    #[doc = " The allocation must not be accessed until the the allocation operation completes."]
    #[doc = " The allocation comes from the specified memory pool."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = "    -  The specified memory pool may be from a device different than that of the specified \\p hStream."]
    #[doc = ""]
    #[doc = "    -  Basic stream ordering allows future work submitted into the same stream to use the allocation."]
    #[doc = "       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation"]
    #[doc = "       operation completes before work submitted in a separate stream runs."]
    #[doc = ""]
    #[doc = " \\note During stream capture, this function results in the creation of an allocation node.  In this case,"]
    #[doc = "       the allocation is owned by the graph instead of the memory pool. The memory pool's properties"]
    #[doc = "       are used to set the node's creation parameters."]
    #[doc = ""]
    #[doc = " \\param[out] dptr    - Returned device pointer"]
    #[doc = " \\param[in] bytesize - Number of bytes to allocate"]
    #[doc = " \\param[in] pool     - The pool to allocate from"]
    #[doc = " \\param[in] hStream  - The stream establishing the stream ordering semantic"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT (default stream specified with no current context),"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,"]
    #[doc = "     ::cuDeviceGetMemPool, ::cuMemPoolCreate, ::cuMemPoolSetAccess,"]
    #[doc = "     ::cuMemPoolSetAttribute"]
    pub fn cuMemAllocFromPoolAsync(
        dptr: *mut CUdeviceptr,
        bytesize: size_t,
        pool: CUmemoryPool,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Exports a memory pool to the requested handle type."]
    #[doc = ""]
    #[doc = " Given an IPC capable mempool, create an OS handle to share the pool with another process."]
    #[doc = " A recipient process can convert the shareable handle into a mempool with ::cuMemPoolImportFromShareableHandle."]
    #[doc = " Individual pointers can then be shared with the ::cuMemPoolExportPointer and ::cuMemPoolImportPointer APIs."]
    #[doc = " The implementation of what the shareable handle is and how it can be transferred is defined by the requested"]
    #[doc = " handle type."]
    #[doc = ""]
    #[doc = " \\note: To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than CU_MEM_HANDLE_TYPE_NONE."]
    #[doc = ""]
    #[doc = " \\param[out] handle_out  - Returned OS handle"]
    #[doc = " \\param[in] pool         - pool to export"]
    #[doc = " \\param[in] handleType   - the type of handle to create"]
    #[doc = " \\param[in] flags        - must be 0"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemPoolImportFromShareableHandle, ::cuMemPoolExportPointer,"]
    #[doc = "     ::cuMemPoolImportPointer, ::cuMemAllocAsync, ::cuMemFreeAsync,"]
    #[doc = "     ::cuDeviceGetDefaultMemPool, ::cuDeviceGetMemPool, ::cuMemPoolCreate,"]
    #[doc = "     ::cuMemPoolSetAccess, ::cuMemPoolSetAttribute"]
    pub fn cuMemPoolExportToShareableHandle(
        handle_out: *mut ::std::os::raw::c_void,
        pool: CUmemoryPool,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief imports a memory pool from a shared handle."]
    #[doc = ""]
    #[doc = " Specific allocations can be imported from the imported pool with cuMemPoolImportPointer."]
    #[doc = ""]
    #[doc = " \\note Imported memory pools do not support creating new allocations."]
    #[doc = "       As such imported memory pools may not be used in cuDeviceSetMemPool"]
    #[doc = "       or ::cuMemAllocFromPoolAsync calls."]
    #[doc = ""]
    #[doc = " \\param[out] pool_out    - Returned memory pool"]
    #[doc = " \\param[in] handle       - OS handle of the pool to open"]
    #[doc = " \\param[in] handleType   - The type of handle being imported"]
    #[doc = " \\param[in] flags        - must be 0"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemPoolExportToShareableHandle, ::cuMemPoolExportPointer, ::cuMemPoolImportPointer"]
    pub fn cuMemPoolImportFromShareableHandle(
        pool_out: *mut CUmemoryPool,
        handle: *mut ::std::os::raw::c_void,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Export data to share a memory pool allocation between processes."]
    #[doc = ""]
    #[doc = " Constructs \\p shareData_out for sharing a specific allocation from an already shared memory pool."]
    #[doc = " The recipient process can import the allocation with the ::cuMemPoolImportPointer api."]
    #[doc = " The data is not a handle and may be shared through any IPC mechanism."]
    #[doc = ""]
    #[doc = " \\param[out] shareData_out - Returned export data"]
    #[doc = " \\param[in] ptr            - pointer to memory being exported"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemPoolExportToShareableHandle, ::cuMemPoolImportFromShareableHandle, ::cuMemPoolImportPointer"]
    pub fn cuMemPoolExportPointer(
        shareData_out: *mut CUmemPoolPtrExportData,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Import a memory pool allocation from another process."]
    #[doc = ""]
    #[doc = " Returns in \\p ptr_out a pointer to the imported memory."]
    #[doc = " The imported memory must not be accessed before the allocation operation completes"]
    #[doc = " in the exporting process. The imported memory must be freed from all importing processes before"]
    #[doc = " being freed in the exporting process. The pointer may be freed with cuMemFree"]
    #[doc = " or cuMemFreeAsync.  If cuMemFreeAsync is used, the free must be completed"]
    #[doc = " on the importing process before the free operation on the exporting process."]
    #[doc = ""]
    #[doc = " \\note The cuMemFreeAsync api may be used in the exporting process before"]
    #[doc = "       the cuMemFreeAsync operation completes in its stream as long as the"]
    #[doc = "       cuMemFreeAsync in the exporting process specifies a stream with"]
    #[doc = "       a stream dependency on the importing process's cuMemFreeAsync."]
    #[doc = ""]
    #[doc = " \\param[out] ptr_out  - pointer to imported memory"]
    #[doc = " \\param[in] pool      - pool from which to import"]
    #[doc = " \\param[in] shareData - data specifying the memory to import"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemPoolExportToShareableHandle, ::cuMemPoolImportFromShareableHandle, ::cuMemPoolExportPointer"]
    pub fn cuMemPoolImportPointer(
        ptr_out: *mut CUdeviceptr,
        pool: CUmemoryPool,
        shareData: *mut CUmemPoolPtrExportData,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about a pointer"]
    #[doc = ""]
    #[doc = " The supported attributes are:"]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_CONTEXT:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data the ::CUcontext in which \\p ptr was allocated or"]
    #[doc = "      registered."]
    #[doc = "      The type of \\p data must be ::CUcontext *."]
    #[doc = ""]
    #[doc = "      If \\p ptr was not allocated by, mapped by, or registered with"]
    #[doc = "      a ::CUcontext which uses unified virtual addressing then"]
    #[doc = "      ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_MEMORY_TYPE:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data the physical memory type of the memory that"]
    #[doc = "      \\p ptr addresses as a ::CUmemorytype enumerated value."]
    #[doc = "      The type of \\p data must be unsigned int."]
    #[doc = ""]
    #[doc = "      If \\p ptr addresses device memory then \\p *data is set to"]
    #[doc = "      ::CU_MEMORYTYPE_DEVICE.  The particular ::CUdevice on which the"]
    #[doc = "      memory resides is the ::CUdevice of the ::CUcontext returned by the"]
    #[doc = "      ::CU_POINTER_ATTRIBUTE_CONTEXT attribute of \\p ptr."]
    #[doc = ""]
    #[doc = "      If \\p ptr addresses host memory then \\p *data is set to"]
    #[doc = "      ::CU_MEMORYTYPE_HOST."]
    #[doc = ""]
    #[doc = "      If \\p ptr was not allocated by, mapped by, or registered with"]
    #[doc = "      a ::CUcontext which uses unified virtual addressing then"]
    #[doc = "      ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = "      If the current ::CUcontext does not support unified virtual"]
    #[doc = "      addressing then ::CUDA_ERROR_INVALID_CONTEXT is returned."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_DEVICE_POINTER:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data the device pointer value through which"]
    #[doc = "      \\p ptr may be accessed by kernels running in the current"]
    #[doc = "      ::CUcontext."]
    #[doc = "      The type of \\p data must be CUdeviceptr *."]
    #[doc = ""]
    #[doc = "      If there exists no device pointer value through which"]
    #[doc = "      kernels running in the current ::CUcontext may access"]
    #[doc = "      \\p ptr then ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = "      If there is no current ::CUcontext then"]
    #[doc = "      ::CUDA_ERROR_INVALID_CONTEXT is returned."]
    #[doc = ""]
    #[doc = "      Except in the exceptional disjoint addressing cases discussed"]
    #[doc = "      below, the value returned in \\p *data will equal the input"]
    #[doc = "      value \\p ptr."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_HOST_POINTER:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data the host pointer value through which"]
    #[doc = "      \\p ptr may be accessed by by the host program."]
    #[doc = "      The type of \\p data must be void **."]
    #[doc = "      If there exists no host pointer value through which"]
    #[doc = "      the host program may directly access \\p ptr then"]
    #[doc = "      ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = "      Except in the exceptional disjoint addressing cases discussed"]
    #[doc = "      below, the value returned in \\p *data will equal the input"]
    #[doc = "      value \\p ptr."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_P2P_TOKENS:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data two tokens for use with the nv-p2p.h Linux"]
    #[doc = "      kernel interface. \\p data must be a struct of type"]
    #[doc = "      CUDA_POINTER_ATTRIBUTE_P2P_TOKENS."]
    #[doc = ""]
    #[doc = "      \\p ptr must be a pointer to memory obtained from :cuMemAlloc()."]
    #[doc = "      Note that p2pToken and vaSpaceToken are only valid for the"]
    #[doc = "      lifetime of the source allocation. A subsequent allocation at"]
    #[doc = "      the same address may return completely different tokens."]
    #[doc = "      Querying this attribute has a side effect of setting the attribute"]
    #[doc = "      ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS for the region of memory that"]
    #[doc = "      \\p ptr points to."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS:"]
    #[doc = ""]
    #[doc = "      A boolean attribute which when set, ensures that synchronous memory operations"]
    #[doc = "      initiated on the region of memory that \\p ptr points to will always synchronize."]
    #[doc = "      See further documentation in the section titled \"API synchronization behavior\""]
    #[doc = "      to learn more about cases when synchronous memory operations can"]
    #[doc = "      exhibit asynchronous behavior."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_BUFFER_ID:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data a buffer ID which is guaranteed to be unique within the process."]
    #[doc = "      \\p data must point to an unsigned long long."]
    #[doc = ""]
    #[doc = "      \\p ptr must be a pointer to memory obtained from a CUDA memory allocation API."]
    #[doc = "      Every memory allocation from any of the CUDA memory allocation APIs will"]
    #[doc = "      have a unique ID over a process lifetime. Subsequent allocations do not reuse IDs"]
    #[doc = "      from previous freed allocations. IDs are only unique within a single process."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_IS_MANAGED:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data a boolean that indicates whether the pointer points to"]
    #[doc = "      managed memory or not."]
    #[doc = ""]
    #[doc = "      If \\p ptr is not a valid CUDA pointer then ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data an integer representing a device ordinal of a device against"]
    #[doc = "      which the memory was allocated or registered."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data a boolean that indicates if this pointer maps to"]
    #[doc = "      an allocation that is suitable for ::cudaIpcGetMemHandle."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_RANGE_START_ADDR:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data the starting address for the allocation referenced"]
    #[doc = "      by the device pointer \\p ptr.  Note that this is not necessarily the"]
    #[doc = "      address of the mapped region, but the address of the mappable address"]
    #[doc = "      range \\p ptr references (e.g. from ::cuMemAddressReserve)."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_RANGE_SIZE:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data the size for the allocation referenced by the device"]
    #[doc = "      pointer \\p ptr.  Note that this is not necessarily the size of the mapped"]
    #[doc = "      region, but the size of the mappable address range \\p ptr references"]
    #[doc = "      (e.g. from ::cuMemAddressReserve).  To retrieve the size of the mapped"]
    #[doc = "      region, see ::cuMemGetAddressRange"]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_MAPPED:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data a boolean that indicates if this pointer is in a"]
    #[doc = "      valid address range that is mapped to a backing allocation."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES:"]
    #[doc = ""]
    #[doc = "      Returns a bitmask of the allowed handle types for an allocation that may"]
    #[doc = "      be passed to ::cuMemExportToShareableHandle."]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE:"]
    #[doc = ""]
    #[doc = "      Returns in \\p *data the handle to the mempool that the allocation was obtained from."]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = ""]
    #[doc = " Note that for most allocations in the unified virtual address space"]
    #[doc = " the host and device pointer for accessing the allocation will be the"]
    #[doc = " same.  The exceptions to this are"]
    #[doc = "  - user memory registered using ::cuMemHostRegister"]
    #[doc = "  - host memory allocated using ::cuMemHostAlloc with the"]
    #[doc = "    ::CU_MEMHOSTALLOC_WRITECOMBINED flag"]
    #[doc = " For these types of allocation there will exist separate, disjoint host"]
    #[doc = " and device addresses for accessing the allocation.  In particular"]
    #[doc = "  - The host address will correspond to an invalid unmapped device address"]
    #[doc = "    (which will result in an exception if accessed from the device)"]
    #[doc = "  - The device address will correspond to an invalid unmapped host address"]
    #[doc = "    (which will result in an exception if accessed from the host)."]
    #[doc = " For these types of allocations, querying ::CU_POINTER_ATTRIBUTE_HOST_POINTER"]
    #[doc = " and ::CU_POINTER_ATTRIBUTE_DEVICE_POINTER may be used to retrieve the host"]
    #[doc = " and device addresses from either address."]
    #[doc = ""]
    #[doc = " \\param data      - Returned pointer attribute value"]
    #[doc = " \\param attribute - Pointer attribute to query"]
    #[doc = " \\param ptr       - Pointer"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuPointerSetAttribute,"]
    #[doc = " ::cuMemAlloc,"]
    #[doc = " ::cuMemFree,"]
    #[doc = " ::cuMemAllocHost,"]
    #[doc = " ::cuMemFreeHost,"]
    #[doc = " ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostRegister,"]
    #[doc = " ::cuMemHostUnregister,"]
    #[doc = " ::cudaPointerGetAttributes"]
    pub fn cuPointerGetAttribute(
        data: *mut ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Prefetches memory to the specified destination device"]
    #[doc = ""]
    #[doc = " Prefetches memory to the specified destination device.  \\p devPtr is the"]
    #[doc = " base device pointer of the memory to be prefetched and \\p dstDevice is the"]
    #[doc = " destination device. \\p count specifies the number of bytes to copy. \\p hStream"]
    #[doc = " is the stream in which the operation is enqueued. The memory range must refer"]
    #[doc = " to managed memory allocated via ::cuMemAllocManaged or declared via __managed__ variables."]
    #[doc = ""]
    #[doc = " Passing in CU_DEVICE_CPU for \\p dstDevice will prefetch the data to host memory. If"]
    #[doc = " \\p dstDevice is a GPU, then the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS"]
    #[doc = " must be non-zero. Additionally, \\p hStream must be associated with a device that has a"]
    #[doc = " non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS."]
    #[doc = ""]
    #[doc = " The start address and end address of the memory range will be rounded down and rounded up"]
    #[doc = " respectively to be aligned to CPU page size before the prefetch operation is enqueued"]
    #[doc = " in the stream."]
    #[doc = ""]
    #[doc = " If no physical memory has been allocated for this region, then this memory region"]
    #[doc = " will be populated and mapped on the destination device. If there's insufficient"]
    #[doc = " memory to prefetch the desired region, the Unified Memory driver may evict pages from other"]
    #[doc = " ::cuMemAllocManaged allocations to host memory in order to make room. Device memory"]
    #[doc = " allocated using ::cuMemAlloc or ::cuArrayCreate will not be evicted."]
    #[doc = ""]
    #[doc = " By default, any mappings to the previous location of the migrated pages are removed and"]
    #[doc = " mappings for the new location are only setup on \\p dstDevice. The exact behavior however"]
    #[doc = " also depends on the settings applied to this memory range via ::cuMemAdvise as described"]
    #[doc = " below:"]
    #[doc = ""]
    #[doc = " If ::CU_MEM_ADVISE_SET_READ_MOSTLY was set on any subset of this memory range,"]
    #[doc = " then that subset will create a read-only copy of the pages on \\p dstDevice."]
    #[doc = ""]
    #[doc = " If ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION was called on any subset of this memory"]
    #[doc = " range, then the pages will be migrated to \\p dstDevice even if \\p dstDevice is not the"]
    #[doc = " preferred location of any pages in the memory range."]
    #[doc = ""]
    #[doc = " If ::CU_MEM_ADVISE_SET_ACCESSED_BY was called on any subset of this memory range,"]
    #[doc = " then mappings to those pages from all the appropriate processors are updated to"]
    #[doc = " refer to the new location if establishing such a mapping is possible. Otherwise,"]
    #[doc = " those mappings are cleared."]
    #[doc = ""]
    #[doc = " Note that this API is not required for functionality and only serves to improve performance"]
    #[doc = " by allowing the application to migrate data to a suitable location before it is accessed."]
    #[doc = " Memory accesses to this range are always coherent and are allowed even when the data is"]
    #[doc = " actively being migrated."]
    #[doc = ""]
    #[doc = " Note that this function is asynchronous with respect to the host and all work"]
    #[doc = " on other devices."]
    #[doc = ""]
    #[doc = " \\param devPtr    - Pointer to be prefetched"]
    #[doc = " \\param count     - Size in bytes"]
    #[doc = " \\param dstDevice - Destination device to prefetch to"]
    #[doc = " \\param hStream    - Stream to enqueue prefetch operation"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_async"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemcpy, ::cuMemcpyPeer, ::cuMemcpyAsync,"]
    #[doc = " ::cuMemcpy3DPeerAsync, ::cuMemAdvise,"]
    #[doc = " ::cudaMemPrefetchAsync"]
    pub fn cuMemPrefetchAsync(
        devPtr: CUdeviceptr,
        count: size_t,
        dstDevice: CUdevice,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Advise about the usage of a given memory range"]
    #[doc = ""]
    #[doc = " Advise the Unified Memory subsystem about the usage pattern for the memory range"]
    #[doc = " starting at \\p devPtr with a size of \\p count bytes. The start address and end address of the memory"]
    #[doc = " range will be rounded down and rounded up respectively to be aligned to CPU page size before the"]
    #[doc = " advice is applied. The memory range must refer to managed memory allocated via ::cuMemAllocManaged"]
    #[doc = " or declared via __managed__ variables. The memory range could also refer to system-allocated pageable"]
    #[doc = " memory provided it represents a valid, host-accessible region of memory and all additional constraints"]
    #[doc = " imposed by \\p advice as outlined below are also satisfied. Specifying an invalid system-allocated pageable"]
    #[doc = " memory range results in an error being returned."]
    #[doc = ""]
    #[doc = " The \\p advice parameter can take the following values:"]
    #[doc = " - ::CU_MEM_ADVISE_SET_READ_MOSTLY: This implies that the data is mostly going to be read"]
    #[doc = " from and only occasionally written to. Any read accesses from any processor to this region will create a"]
    #[doc = " read-only copy of at least the accessed pages in that processor's memory. Additionally, if ::cuMemPrefetchAsync"]
    #[doc = " is called on this region, it will create a read-only copy of the data on the destination processor."]
    #[doc = " If any processor writes to this region, all copies of the corresponding page will be invalidated"]
    #[doc = " except for the one where the write occurred. The \\p device argument is ignored for this advice."]
    #[doc = " Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU"]
    #[doc = " that has a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS."]
    #[doc = " Also, if a context is created on a device that does not have the device attribute"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS set, then read-duplication will not occur until"]
    #[doc = " all such contexts are destroyed."]
    #[doc = " If the memory region refers to valid system-allocated pageable memory, then the accessing device must"]
    #[doc = " have a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS for a read-only"]
    #[doc = " copy to be created on that device. Note however that if the accessing device also has a non-zero value for the"]
    #[doc = " device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES, then setting this advice"]
    #[doc = " will not create a read-only copy when that device accesses this memory region."]
    #[doc = ""]
    #[doc = " - ::CU_MEM_ADVISE_UNSET_READ_MOSTLY:  Undoes the effect of ::CU_MEM_ADVISE_SET_READ_MOSTLY and also prevents the"]
    #[doc = " Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated"]
    #[doc = " copies of the data will be collapsed into a single copy. The location for the collapsed"]
    #[doc = " copy will be the preferred location if the page has a preferred location and one of the read-duplicated"]
    #[doc = " copies was resident at that location. Otherwise, the location chosen is arbitrary."]
    #[doc = ""]
    #[doc = " - ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION: This advice sets the preferred location for the"]
    #[doc = " data to be the memory belonging to \\p device. Passing in CU_DEVICE_CPU for \\p device sets the"]
    #[doc = " preferred location as host memory. If \\p device is a GPU, then it must have a non-zero value for the"]
    #[doc = " device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS. Setting the preferred location"]
    #[doc = " does not cause data to migrate to that location immediately. Instead, it guides the migration policy"]
    #[doc = " when a fault occurs on that memory region. If the data is already in its preferred location and the"]
    #[doc = " faulting processor can establish a mapping without requiring the data to be migrated, then"]
    #[doc = " data migration will be avoided. On the other hand, if the data is not in its preferred location"]
    #[doc = " or if a direct mapping cannot be established, then it will be migrated to the processor accessing"]
    #[doc = " it. It is important to note that setting the preferred location does not prevent data prefetching"]
    #[doc = " done using ::cuMemPrefetchAsync."]
    #[doc = " Having a preferred location can override the page thrash detection and resolution logic in the Unified"]
    #[doc = " Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device"]
    #[doc = " memory, the page may eventually be pinned to host memory by the Unified Memory driver. But"]
    #[doc = " if the preferred location is set as device memory, then the page will continue to thrash indefinitely."]
    #[doc = " If ::CU_MEM_ADVISE_SET_READ_MOSTLY is also set on this memory region or any subset of it, then the"]
    #[doc = " policies associated with that advice will override the policies of this advice, unless read accesses from"]
    #[doc = " \\p device will not result in a read-only copy being created on that device as outlined in description for"]
    #[doc = " the advice ::CU_MEM_ADVISE_SET_READ_MOSTLY."]
    #[doc = " If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero"]
    #[doc = " value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS. Additionally, if \\p device has"]
    #[doc = " a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES,"]
    #[doc = " then this call has no effect. Note however that this behavior may change in the future."]
    #[doc = ""]
    #[doc = " - ::CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION: Undoes the effect of ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION"]
    #[doc = " and changes the preferred location to none."]
    #[doc = ""]
    #[doc = " - ::CU_MEM_ADVISE_SET_ACCESSED_BY: This advice implies that the data will be accessed by \\p device."]
    #[doc = " Passing in ::CU_DEVICE_CPU for \\p device will set the advice for the CPU. If \\p device is a GPU, then"]
    #[doc = " the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS must be non-zero."]
    #[doc = " This advice does not cause data migration and has no impact on the location of the data per se. Instead,"]
    #[doc = " it causes the data to always be mapped in the specified processor's page tables, as long as the"]
    #[doc = " location of the data permits a mapping to be established. If the data gets migrated for any reason,"]
    #[doc = " the mappings are updated accordingly."]
    #[doc = " This advice is recommended in scenarios where data locality is not important, but avoiding faults is."]
    #[doc = " Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the"]
    #[doc = " data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data"]
    #[doc = " over to the other GPUs is not as important because the accesses are infrequent and the overhead of"]
    #[doc = " migration may be too high. But preventing faults can still help improve performance, and so having"]
    #[doc = " a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated"]
    #[doc = " to host memory because the CPU typically cannot access device memory directly. Any GPU that had the"]
    #[doc = " ::CU_MEM_ADVISE_SET_ACCESSED_BY flag set for this data will now have its mapping updated to point to the"]
    #[doc = " page in host memory."]
    #[doc = " If ::CU_MEM_ADVISE_SET_READ_MOSTLY is also set on this memory region or any subset of it, then the"]
    #[doc = " policies associated with that advice will override the policies of this advice. Additionally, if the"]
    #[doc = " preferred location of this memory region or any subset of it is also \\p device, then the policies"]
    #[doc = " associated with ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION will override the policies of this advice."]
    #[doc = " If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero"]
    #[doc = " value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS. Additionally, if \\p device has"]
    #[doc = " a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES,"]
    #[doc = " then this call has no effect."]
    #[doc = ""]
    #[doc = " - ::CU_MEM_ADVISE_UNSET_ACCESSED_BY: Undoes the effect of ::CU_MEM_ADVISE_SET_ACCESSED_BY. Any mappings to"]
    #[doc = " the data from \\p device may be removed at any time causing accesses to result in non-fatal page faults."]
    #[doc = " If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero"]
    #[doc = " value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS. Additionally, if \\p device has"]
    #[doc = " a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES,"]
    #[doc = " then this call has no effect."]
    #[doc = ""]
    #[doc = " \\param devPtr - Pointer to memory to set the advice for"]
    #[doc = " \\param count  - Size in bytes of the memory range"]
    #[doc = " \\param advice - Advice to be applied for the specified memory range"]
    #[doc = " \\param device - Device to apply the advice for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_async"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemcpy, ::cuMemcpyPeer, ::cuMemcpyAsync,"]
    #[doc = " ::cuMemcpy3DPeerAsync, ::cuMemPrefetchAsync,"]
    #[doc = " ::cudaMemAdvise"]
    pub fn cuMemAdvise(
        devPtr: CUdeviceptr,
        count: size_t,
        advice: CUmem_advise,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query an attribute of a given memory range"]
    #[doc = ""]
    #[doc = " Query an attribute about the memory range starting at \\p devPtr with a size of \\p count bytes. The"]
    #[doc = " memory range must refer to managed memory allocated via ::cuMemAllocManaged or declared via"]
    #[doc = " __managed__ variables."]
    #[doc = ""]
    #[doc = " The \\p attribute parameter can take the following values:"]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY: If this attribute is specified, \\p data will be interpreted"]
    #[doc = " as a 32-bit integer, and \\p dataSize must be 4. The result returned will be 1 if all pages in the given"]
    #[doc = " memory range have read-duplication enabled, or 0 otherwise."]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION: If this attribute is specified, \\p data will be"]
    #[doc = " interpreted as a 32-bit integer, and \\p dataSize must be 4. The result returned will be a GPU device"]
    #[doc = " id if all pages in the memory range have that GPU as their preferred location, or it will be CU_DEVICE_CPU"]
    #[doc = " if all pages in the memory range have the CPU as their preferred location, or it will be CU_DEVICE_INVALID"]
    #[doc = " if either all the pages don't have the same preferred location or some of the pages don't have a"]
    #[doc = " preferred location at all. Note that the actual location of the pages in the memory range at the time of"]
    #[doc = " the query may be different from the preferred location."]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY: If this attribute is specified, \\p data will be interpreted"]
    #[doc = " as an array of 32-bit integers, and \\p dataSize must be a non-zero multiple of 4. The result returned"]
    #[doc = " will be a list of device ids that had ::CU_MEM_ADVISE_SET_ACCESSED_BY set for that entire memory range."]
    #[doc = " If any device does not have that advice set for the entire memory range, that device will not be included."]
    #[doc = " If \\p data is larger than the number of devices that have that advice set for that memory range,"]
    #[doc = " CU_DEVICE_INVALID will be returned in all the extra space provided. For ex., if \\p dataSize is 12"]
    #[doc = " (i.e. \\p data has 3 elements) and only device 0 has the advice set, then the result returned will be"]
    #[doc = " { 0, CU_DEVICE_INVALID, CU_DEVICE_INVALID }. If \\p data is smaller than the number of devices that have"]
    #[doc = " that advice set, then only as many devices will be returned as can fit in the array. There is no"]
    #[doc = " guarantee on which specific devices will be returned, however."]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION: If this attribute is specified, \\p data will be"]
    #[doc = " interpreted as a 32-bit integer, and \\p dataSize must be 4. The result returned will be the last location"]
    #[doc = " to which all pages in the memory range were prefetched explicitly via ::cuMemPrefetchAsync. This will either be"]
    #[doc = " a GPU id or CU_DEVICE_CPU depending on whether the last location for prefetch was a GPU or the CPU"]
    #[doc = " respectively. If any page in the memory range was never explicitly prefetched or if all pages were not"]
    #[doc = " prefetched to the same location, CU_DEVICE_INVALID will be returned. Note that this simply returns the"]
    #[doc = " last location that the applicaton requested to prefetch the memory range to. It gives no indication as to"]
    #[doc = " whether the prefetch operation to that location has completed or even begun."]
    #[doc = ""]
    #[doc = " \\param data      - A pointers to a memory location where the result"]
    #[doc = "                    of each attribute query will be written to."]
    #[doc = " \\param dataSize  - Array containing the size of data"]
    #[doc = " \\param attribute - The attribute to query"]
    #[doc = " \\param devPtr    - Start of the range to query"]
    #[doc = " \\param count     - Size of the range to query"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = " \\note_async"]
    #[doc = " \\note_null_stream"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemRangeGetAttributes, ::cuMemPrefetchAsync,"]
    #[doc = " ::cuMemAdvise,"]
    #[doc = " ::cudaMemRangeGetAttribute"]
    pub fn cuMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        dataSize: size_t,
        attribute: CUmem_range_attribute,
        devPtr: CUdeviceptr,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query attributes of a given memory range."]
    #[doc = ""]
    #[doc = " Query attributes of the memory range starting at \\p devPtr with a size of \\p count bytes. The"]
    #[doc = " memory range must refer to managed memory allocated via ::cuMemAllocManaged or declared via"]
    #[doc = " __managed__ variables. The \\p attributes array will be interpreted to have \\p numAttributes"]
    #[doc = " entries. The \\p dataSizes array will also be interpreted to have \\p numAttributes entries."]
    #[doc = " The results of the query will be stored in \\p data."]
    #[doc = ""]
    #[doc = " The list of supported attributes are given below. Please refer to ::cuMemRangeGetAttribute for"]
    #[doc = " attribute descriptions and restrictions."]
    #[doc = ""]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY"]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION"]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY"]
    #[doc = " - ::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION"]
    #[doc = ""]
    #[doc = " \\param data          - A two-dimensional array containing pointers to memory"]
    #[doc = "                        locations where the result of each attribute query will be written to."]
    #[doc = " \\param dataSizes     - Array containing the sizes of each result"]
    #[doc = " \\param attributes    - An array of attributes to query"]
    #[doc = "                        (numAttributes and the number of attributes in this array should match)"]
    #[doc = " \\param numAttributes - Number of attributes to query"]
    #[doc = " \\param devPtr        - Start of the range to query"]
    #[doc = " \\param count         - Size of the range to query"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuMemRangeGetAttribute, ::cuMemAdvise,"]
    #[doc = " ::cuMemPrefetchAsync,"]
    #[doc = " ::cudaMemRangeGetAttributes"]
    pub fn cuMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        dataSizes: *mut size_t,
        attributes: *mut CUmem_range_attribute,
        numAttributes: size_t,
        devPtr: CUdeviceptr,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set attributes on a previously allocated memory region"]
    #[doc = ""]
    #[doc = " The supported attributes are:"]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS:"]
    #[doc = ""]
    #[doc = "      A boolean attribute that can either be set (1) or unset (0). When set,"]
    #[doc = "      the region of memory that \\p ptr points to is guaranteed to always synchronize"]
    #[doc = "      memory operations that are synchronous. If there are some previously initiated"]
    #[doc = "      synchronous memory operations that are pending when this attribute is set, the"]
    #[doc = "      function does not return until those memory operations are complete."]
    #[doc = "      See further documentation in the section titled \"API synchronization behavior\""]
    #[doc = "      to learn more about cases when synchronous memory operations can"]
    #[doc = "      exhibit asynchronous behavior."]
    #[doc = "      \\p value will be considered as a pointer to an unsigned integer to which this attribute is to be set."]
    #[doc = ""]
    #[doc = " \\param value     - Pointer to memory containing the value to be set"]
    #[doc = " \\param attribute - Pointer attribute to set"]
    #[doc = " \\param ptr       - Pointer to a memory region allocated using CUDA memory allocation APIs"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuPointerGetAttribute,"]
    #[doc = " ::cuPointerGetAttributes,"]
    #[doc = " ::cuMemAlloc,"]
    #[doc = " ::cuMemFree,"]
    #[doc = " ::cuMemAllocHost,"]
    #[doc = " ::cuMemFreeHost,"]
    #[doc = " ::cuMemHostAlloc,"]
    #[doc = " ::cuMemHostRegister,"]
    #[doc = " ::cuMemHostUnregister"]
    pub fn cuPointerSetAttribute(
        value: *const ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about a pointer."]
    #[doc = ""]
    #[doc = " The supported attributes are (refer to ::cuPointerGetAttribute for attribute descriptions and restrictions):"]
    #[doc = ""]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_CONTEXT"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_MEMORY_TYPE"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_DEVICE_POINTER"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_HOST_POINTER"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_BUFFER_ID"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_IS_MANAGED"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_RANGE_START_ADDR"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_RANGE_SIZE"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_MAPPED"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES"]
    #[doc = " - ::CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE"]
    #[doc = ""]
    #[doc = " \\param numAttributes - Number of attributes to query"]
    #[doc = " \\param attributes    - An array of attributes to query"]
    #[doc = "                      (numAttributes and the number of attributes in this array should match)"]
    #[doc = " \\param data          - A two-dimensional array containing pointers to memory"]
    #[doc = "                      locations where the result of each attribute query will be written to."]
    #[doc = " \\param ptr           - Pointer to query"]
    #[doc = ""]
    #[doc = " Unlike ::cuPointerGetAttribute, this function will not return an error when the \\p ptr"]
    #[doc = " encountered is not a valid CUDA pointer. Instead, the attributes are assigned default NULL values"]
    #[doc = " and CUDA_SUCCESS is returned."]
    #[doc = ""]
    #[doc = " If \\p ptr was not allocated by, mapped by, or registered with a ::CUcontext which uses UVA"]
    #[doc = " (Unified Virtual Addressing), ::CUDA_ERROR_INVALID_CONTEXT is returned."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuPointerGetAttribute,"]
    #[doc = " ::cuPointerSetAttribute,"]
    #[doc = " ::cudaPointerGetAttributes"]
    pub fn cuPointerGetAttributes(
        numAttributes: ::std::os::raw::c_uint,
        attributes: *mut CUpointer_attribute,
        data: *mut *mut ::std::os::raw::c_void,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a stream"]
    #[doc = ""]
    #[doc = " Creates a stream and returns a handle in \\p phStream.  The \\p Flags argument"]
    #[doc = " determines behaviors of the stream."]
    #[doc = ""]
    #[doc = " Valid values for \\p Flags are:"]
    #[doc = " - ::CU_STREAM_DEFAULT: Default stream creation flag."]
    #[doc = " - ::CU_STREAM_NON_BLOCKING: Specifies that work running in the created"]
    #[doc = "   stream may run concurrently with work in stream 0 (the NULL stream), and that"]
    #[doc = "   the created stream should perform no implicit synchronization with stream 0."]
    #[doc = ""]
    #[doc = " \\param phStream - Returned newly created stream"]
    #[doc = " \\param Flags    - Parameters for stream creation"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamDestroy,"]
    #[doc = " ::cuStreamCreateWithPriority,"]
    #[doc = " ::cuStreamGetPriority,"]
    #[doc = " ::cuStreamGetFlags,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamAddCallback,"]
    #[doc = " ::cudaStreamCreate,"]
    #[doc = " ::cudaStreamCreateWithFlags"]
    pub fn cuStreamCreate(phStream: *mut CUstream, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a stream with the given priority"]
    #[doc = ""]
    #[doc = " Creates a stream with the specified priority and returns a handle in \\p phStream."]
    #[doc = " This API alters the scheduler priority of work in the stream. Work in a higher"]
    #[doc = " priority stream may preempt work already executing in a low priority stream."]
    #[doc = ""]
    #[doc = " \\p priority follows a convention where lower numbers represent higher priorities."]
    #[doc = " '0' represents default priority. The range of meaningful numerical priorities can"]
    #[doc = " be queried using ::cuCtxGetStreamPriorityRange. If the specified priority is"]
    #[doc = " outside the numerical range returned by ::cuCtxGetStreamPriorityRange,"]
    #[doc = " it will automatically be clamped to the lowest or the highest number in the range."]
    #[doc = ""]
    #[doc = " \\param phStream    - Returned newly created stream"]
    #[doc = " \\param flags       - Flags for stream creation. See ::cuStreamCreate for a list of"]
    #[doc = "                      valid flags"]
    #[doc = " \\param priority    - Stream priority. Lower numbers represent higher priorities."]
    #[doc = "                      See ::cuCtxGetStreamPriorityRange for more information about"]
    #[doc = "                      meaningful stream priorities that can be passed."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\note Stream priorities are supported only on GPUs"]
    #[doc = " with compute capability 3.5 or higher."]
    #[doc = ""]
    #[doc = " \\note In the current implementation, only compute kernels launched in"]
    #[doc = " priority streams are affected by the stream's priority. Stream priorities have"]
    #[doc = " no effect on host-to-device and device-to-host memory operations."]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamDestroy,"]
    #[doc = " ::cuStreamCreate,"]
    #[doc = " ::cuStreamGetPriority,"]
    #[doc = " ::cuCtxGetStreamPriorityRange,"]
    #[doc = " ::cuStreamGetFlags,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamAddCallback,"]
    #[doc = " ::cudaStreamCreateWithPriority"]
    pub fn cuStreamCreateWithPriority(
        phStream: *mut CUstream,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query the priority of a given stream"]
    #[doc = ""]
    #[doc = " Query the priority of a stream created using ::cuStreamCreate or ::cuStreamCreateWithPriority"]
    #[doc = " and return the priority in \\p priority. Note that if the stream was created with a"]
    #[doc = " priority outside the numerical range returned by ::cuCtxGetStreamPriorityRange,"]
    #[doc = " this function returns the clamped priority."]
    #[doc = " See ::cuStreamCreateWithPriority for details about priority clamping."]
    #[doc = ""]
    #[doc = " \\param hStream    - Handle to the stream to be queried"]
    #[doc = " \\param priority   - Pointer to a signed integer in which the stream's priority is returned"]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamDestroy,"]
    #[doc = " ::cuStreamCreate,"]
    #[doc = " ::cuStreamCreateWithPriority,"]
    #[doc = " ::cuCtxGetStreamPriorityRange,"]
    #[doc = " ::cuStreamGetFlags,"]
    #[doc = " ::cudaStreamGetPriority"]
    pub fn cuStreamGetPriority(hStream: CUstream, priority: *mut ::std::os::raw::c_int)
        -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query the flags of a given stream"]
    #[doc = ""]
    #[doc = " Query the flags of a stream created using ::cuStreamCreate or ::cuStreamCreateWithPriority"]
    #[doc = " and return the flags in \\p flags."]
    #[doc = ""]
    #[doc = " \\param hStream    - Handle to the stream to be queried"]
    #[doc = " \\param flags      - Pointer to an unsigned integer in which the stream's flags are returned"]
    #[doc = "                     The value returned in \\p flags is a logical 'OR' of all flags that"]
    #[doc = "                     were used while creating this stream. See ::cuStreamCreate for the list"]
    #[doc = "                     of valid flags"]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamDestroy,"]
    #[doc = " ::cuStreamCreate,"]
    #[doc = " ::cuStreamGetPriority,"]
    #[doc = " ::cudaStreamGetFlags"]
    pub fn cuStreamGetFlags(hStream: CUstream, flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query the context associated with a stream"]
    #[doc = ""]
    #[doc = " Returns the CUDA context that the stream is associated with."]
    #[doc = ""]
    #[doc = " The stream handle \\p hStream can refer to any of the following:"]
    #[doc = " <ul>"]
    #[doc = "   <li>a stream created via any of the CUDA driver APIs such as ::cuStreamCreate"]
    #[doc = "   and ::cuStreamCreateWithPriority, or their runtime API equivalents such as"]
    #[doc = "   ::cudaStreamCreate, ::cudaStreamCreateWithFlags and ::cudaStreamCreateWithPriority."]
    #[doc = "   The returned context is the context that was active in the calling thread when the"]
    #[doc = "   stream was created. Passing an invalid handle will result in undefined behavior.</li>"]
    #[doc = "   <li>any of the special streams such as the NULL stream, ::CU_STREAM_LEGACY and"]
    #[doc = "   ::CU_STREAM_PER_THREAD. The runtime API equivalents of these are also accepted,"]
    #[doc = "   which are NULL, ::cudaStreamLegacy and ::cudaStreamPerThread respectively."]
    #[doc = "   Specifying any of the special handles will return the context current to the"]
    #[doc = "   calling thread. If no context is current to the calling thread,"]
    #[doc = "   ::CUDA_ERROR_INVALID_CONTEXT is returned.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " \\param hStream - Handle to the stream to be queried"]
    #[doc = " \\param pctx    - Returned context associated with the stream"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamDestroy,"]
    #[doc = " ::cuStreamCreateWithPriority,"]
    #[doc = " ::cuStreamGetPriority,"]
    #[doc = " ::cuStreamGetFlags,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamAddCallback,"]
    #[doc = " ::cudaStreamCreate,"]
    #[doc = " ::cudaStreamCreateWithFlags"]
    pub fn cuStreamGetCtx(hStream: CUstream, pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Make a compute stream wait on an event"]
    #[doc = ""]
    #[doc = " Makes all future work submitted to \\p hStream wait for all work captured in"]
    #[doc = " \\p hEvent.  See ::cuEventRecord() for details on what is captured by an event."]
    #[doc = " The synchronization will be performed efficiently on the device when applicable."]
    #[doc = " \\p hEvent may be from a different context or device than \\p hStream."]
    #[doc = ""]
    #[doc = " flags include:"]
    #[doc = " - ::CU_EVENT_WAIT_DEFAULT: Default event creation flag."]
    #[doc = " - ::CU_EVENT_WAIT_EXTERNAL: Event is captured in the graph as an external"]
    #[doc = "   event node when performing stream capture. This flag is invalid outside"]
    #[doc = "   of stream capture."]
    #[doc = ""]
    #[doc = " \\param hStream - Stream to wait"]
    #[doc = " \\param hEvent  - Event to wait on (may not be NULL)"]
    #[doc = " \\param Flags   - See ::CUevent_capture_flags"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamCreate,"]
    #[doc = " ::cuEventRecord,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamAddCallback,"]
    #[doc = " ::cuStreamDestroy,"]
    #[doc = " ::cudaStreamWaitEvent"]
    pub fn cuStreamWaitEvent(
        hStream: CUstream,
        hEvent: CUevent,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Add a callback to a compute stream"]
    #[doc = ""]
    #[doc = " \\note This function is slated for eventual deprecation and removal. If"]
    #[doc = " you do not require the callback to execute in case of a device error,"]
    #[doc = " consider using ::cuLaunchHostFunc. Additionally, this function is not"]
    #[doc = " supported with ::cuStreamBeginCapture and ::cuStreamEndCapture, unlike"]
    #[doc = " ::cuLaunchHostFunc."]
    #[doc = ""]
    #[doc = " Adds a callback to be called on the host after all currently enqueued"]
    #[doc = " items in the stream have completed.  For each"]
    #[doc = " cuStreamAddCallback call, the callback will be executed exactly once."]
    #[doc = " The callback will block later work in the stream until it is finished."]
    #[doc = ""]
    #[doc = " The callback may be passed ::CUDA_SUCCESS or an error code.  In the event"]
    #[doc = " of a device error, all subsequently executed callbacks will receive an"]
    #[doc = " appropriate ::CUresult."]
    #[doc = ""]
    #[doc = " Callbacks must not make any CUDA API calls.  Attempting to use a CUDA API"]
    #[doc = " will result in ::CUDA_ERROR_NOT_PERMITTED.  Callbacks must not perform any"]
    #[doc = " synchronization that may depend on outstanding device work or other callbacks"]
    #[doc = " that are not mandated to run earlier.  Callbacks without a mandated order"]
    #[doc = " (in independent streams) execute in undefined order and may be serialized."]
    #[doc = ""]
    #[doc = " For the purposes of Unified Memory, callback execution makes a number of"]
    #[doc = " guarantees:"]
    #[doc = " <ul>"]
    #[doc = "   <li>The callback stream is considered idle for the duration of the"]
    #[doc = "   callback.  Thus, for example, a callback may always use memory attached"]
    #[doc = "   to the callback stream.</li>"]
    #[doc = "   <li>The start of execution of a callback has the same effect as"]
    #[doc = "   synchronizing an event recorded in the same stream immediately prior to"]
    #[doc = "   the callback.  It thus synchronizes streams which have been \"joined\""]
    #[doc = "   prior to the callback.</li>"]
    #[doc = "   <li>Adding device work to any stream does not have the effect of making"]
    #[doc = "   the stream active until all preceding host functions and stream callbacks"]
    #[doc = "   have executed.  Thus, for"]
    #[doc = "   example, a callback might use global attached memory even if work has"]
    #[doc = "   been added to another stream, if the work has been ordered behind the"]
    #[doc = "   callback with an event.</li>"]
    #[doc = "   <li>Completion of a callback does not cause a stream to become"]
    #[doc = "   active except as described above.  The callback stream will remain idle"]
    #[doc = "   if no device work follows the callback, and will remain idle across"]
    #[doc = "   consecutive callbacks without device work in between.  Thus, for example,"]
    #[doc = "   stream synchronization can be done by signaling from a callback at the"]
    #[doc = "   end of the stream.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " \\param hStream  - Stream to add callback to"]
    #[doc = " \\param callback - The function to call once preceding stream operations are complete"]
    #[doc = " \\param userData - User specified data to be passed to the callback function"]
    #[doc = " \\param flags    - Reserved for future use, must be 0"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamCreate,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamDestroy,"]
    #[doc = " ::cuMemAllocManaged,"]
    #[doc = " ::cuStreamAttachMemAsync,"]
    #[doc = " ::cuStreamLaunchHostFunc,"]
    #[doc = " ::cudaStreamAddCallback"]
    pub fn cuStreamAddCallback(
        hStream: CUstream,
        callback: CUstreamCallback,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBeginCapture_v2(hStream: CUstream, mode: CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Swaps the stream capture interaction mode for a thread"]
    #[doc = ""]
    #[doc = " Sets the calling thread's stream capture interaction mode to the value contained"]
    #[doc = " in \\p *mode, and overwrites \\p *mode with the previous mode for the thread. To"]
    #[doc = " facilitate deterministic behavior across function or module boundaries, callers"]
    #[doc = " are encouraged to use this API in a push-pop fashion: \\code"]
    #[doc = "CUstreamCaptureMode mode = desiredMode;"]
    #[doc = "cuThreadExchangeStreamCaptureMode(&mode);"]
    #[doc = "..."]
    #[doc = "cuThreadExchangeStreamCaptureMode(&mode); // restore previous mode"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " During stream capture (see ::cuStreamBeginCapture), some actions, such as a call"]
    #[doc = " to ::cudaMalloc, may be unsafe. In the case of ::cudaMalloc, the operation is"]
    #[doc = " not enqueued asynchronously to a stream, and is not observed by stream capture."]
    #[doc = " Therefore, if the sequence of operations captured via ::cuStreamBeginCapture"]
    #[doc = " depended on the allocation being replayed whenever the graph is launched, the"]
    #[doc = " captured graph would be invalid."]
    #[doc = ""]
    #[doc = " Therefore, stream capture places restrictions on API calls that can be made within"]
    #[doc = " or concurrently to a ::cuStreamBeginCapture-::cuStreamEndCapture sequence. This"]
    #[doc = " behavior can be controlled via this API and flags to ::cuStreamBeginCapture."]
    #[doc = ""]
    #[doc = " A thread's mode is one of the following:"]
    #[doc = " - \\p CU_STREAM_CAPTURE_MODE_GLOBAL: This is the default mode. If the local thread has"]
    #[doc = "   an ongoing capture sequence that was not initiated with"]
    #[doc = "   \\p CU_STREAM_CAPTURE_MODE_RELAXED at \\p cuStreamBeginCapture, or if any other thread"]
    #[doc = "   has a concurrent capture sequence initiated with \\p CU_STREAM_CAPTURE_MODE_GLOBAL,"]
    #[doc = "   this thread is prohibited from potentially unsafe API calls."]
    #[doc = " - \\p CU_STREAM_CAPTURE_MODE_THREAD_LOCAL: If the local thread has an ongoing capture"]
    #[doc = "   sequence not initiated with \\p CU_STREAM_CAPTURE_MODE_RELAXED, it is prohibited"]
    #[doc = "   from potentially unsafe API calls. Concurrent capture sequences in other threads"]
    #[doc = "   are ignored."]
    #[doc = " - \\p CU_STREAM_CAPTURE_MODE_RELAXED: The local thread is not prohibited from potentially"]
    #[doc = "   unsafe API calls. Note that the thread is still prohibited from API calls which"]
    #[doc = "   necessarily conflict with stream capture, for example, attempting ::cuEventQuery"]
    #[doc = "   on an event that was last recorded inside a capture sequence."]
    #[doc = ""]
    #[doc = " \\param mode - Pointer to mode value to swap with the current mode"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuStreamBeginCapture"]
    pub fn cuThreadExchangeStreamCaptureMode(mode: *mut CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Ends capture on a stream, returning the captured graph"]
    #[doc = ""]
    #[doc = " End capture on \\p hStream, returning the captured graph via \\p phGraph."]
    #[doc = " Capture must have been initiated on \\p hStream via a call to ::cuStreamBeginCapture."]
    #[doc = " If capture was invalidated, due to a violation of the rules of stream capture, then"]
    #[doc = " a NULL graph will be returned."]
    #[doc = ""]
    #[doc = " If the \\p mode argument to ::cuStreamBeginCapture was not"]
    #[doc = " ::CU_STREAM_CAPTURE_MODE_RELAXED, this call must be from the same thread as"]
    #[doc = " ::cuStreamBeginCapture."]
    #[doc = ""]
    #[doc = " \\param hStream - Stream to query"]
    #[doc = " \\param phGraph - The captured graph"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuStreamCreate,"]
    #[doc = " ::cuStreamBeginCapture,"]
    #[doc = " ::cuStreamIsCapturing"]
    pub fn cuStreamEndCapture(hStream: CUstream, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a stream's capture status"]
    #[doc = ""]
    #[doc = " Return the capture status of \\p hStream via \\p captureStatus. After a successful"]
    #[doc = " call, \\p *captureStatus will contain one of the following:"]
    #[doc = " - ::CU_STREAM_CAPTURE_STATUS_NONE: The stream is not capturing."]
    #[doc = " - ::CU_STREAM_CAPTURE_STATUS_ACTIVE: The stream is capturing."]
    #[doc = " - ::CU_STREAM_CAPTURE_STATUS_INVALIDATED: The stream was capturing but an error"]
    #[doc = "   has invalidated the capture sequence. The capture sequence must be terminated"]
    #[doc = "   with ::cuStreamEndCapture on the stream where it was initiated in order to"]
    #[doc = "   continue using \\p hStream."]
    #[doc = ""]
    #[doc = " Note that, if this is called on ::CU_STREAM_LEGACY (the \"null stream\") while"]
    #[doc = " a blocking stream in the same context is capturing, it will return"]
    #[doc = " ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT and \\p *captureStatus is unspecified"]
    #[doc = " after the call. The blocking stream capture is not invalidated."]
    #[doc = ""]
    #[doc = " When a blocking stream is capturing, the legacy stream is in an"]
    #[doc = " unusable state until the blocking stream capture is terminated. The legacy"]
    #[doc = " stream is not supported for stream capture, but attempted use would have an"]
    #[doc = " implicit dependency on the capturing stream(s)."]
    #[doc = ""]
    #[doc = " \\param hStream       - Stream to query"]
    #[doc = " \\param captureStatus - Returns the stream's capture status"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuStreamCreate,"]
    #[doc = " ::cuStreamBeginCapture,"]
    #[doc = " ::cuStreamEndCapture"]
    pub fn cuStreamIsCapturing(
        hStream: CUstream,
        captureStatus: *mut CUstreamCaptureStatus,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query capture status of a stream"]
    #[doc = ""]
    #[doc = " Note there is a later version of this API, ::cuStreamGetCaptureInfo_v2. It will"]
    #[doc = " supplant this version in 12.0, which is retained for minor version compatibility."]
    #[doc = ""]
    #[doc = " Query the capture status of a stream and and get an id for"]
    #[doc = " the capture sequence, which is unique over the lifetime of the process."]
    #[doc = ""]
    #[doc = " If called on ::CU_STREAM_LEGACY (the \"null stream\") while a stream not created"]
    #[doc = " with ::CU_STREAM_NON_BLOCKING is capturing, returns ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT."]
    #[doc = ""]
    #[doc = " A valid id is returned only if both of the following are true:"]
    #[doc = " - the call returns CUDA_SUCCESS"]
    #[doc = " - captureStatus is set to ::CU_STREAM_CAPTURE_STATUS_ACTIVE"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuStreamGetCaptureInfo_v2,"]
    #[doc = " ::cuStreamBeginCapture,"]
    #[doc = " ::cuStreamIsCapturing"]
    pub fn cuStreamGetCaptureInfo(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query a stream's capture state (11.3+)"]
    #[doc = ""]
    #[doc = " Query stream state related to stream capture."]
    #[doc = ""]
    #[doc = " If called on ::CU_STREAM_LEGACY (the \"null stream\") while a stream not created"]
    #[doc = " with ::CU_STREAM_NON_BLOCKING is capturing, returns ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT."]
    #[doc = ""]
    #[doc = " Valid data (other than capture status) is returned only if both of the following are true:"]
    #[doc = " - the call returns CUDA_SUCCESS"]
    #[doc = " - the returned capture status is ::CU_STREAM_CAPTURE_STATUS_ACTIVE"]
    #[doc = ""]
    #[doc = " This version of cuStreamGetCaptureInfo is introduced in CUDA 11.3 and will supplant the"]
    #[doc = " previous version in 12.0. Developers requiring compatibility across minor versions to"]
    #[doc = " CUDA 11.0 (driver version 445) should use ::cuStreamGetCaptureInfo or include a fallback"]
    #[doc = " path."]
    #[doc = ""]
    #[doc = " \\param hStream - The stream to query"]
    #[doc = " \\param captureStatus_out - Location to return the capture status of the stream; required"]
    #[doc = " \\param id_out - Optional location to return an id for the capture sequence, which is"]
    #[doc = "           unique over the lifetime of the process"]
    #[doc = " \\param graph_out - Optional location to return the graph being captured into. All"]
    #[doc = "           operations other than destroy and node removal are permitted on the graph"]
    #[doc = "           while the capture sequence is in progress. This API does not transfer"]
    #[doc = "           ownership of the graph, which is transferred or destroyed at"]
    #[doc = "           ::cuStreamEndCapture. Note that the graph handle may be invalidated before"]
    #[doc = "           end of capture for certain errors. Nodes that are or become"]
    #[doc = "           unreachable from the original stream at ::cuStreamEndCapture due to direct"]
    #[doc = "           actions on the graph do not trigger ::CUDA_ERROR_STREAM_CAPTURE_UNJOINED."]
    #[doc = " \\param dependencies_out - Optional location to store a pointer to an array of nodes."]
    #[doc = "           The next node to be captured in the stream will depend on this set of nodes,"]
    #[doc = "           absent operations such as event wait which modify this set. The array pointer"]
    #[doc = "           is valid until the next API call which operates on the stream or until end of"]
    #[doc = "           capture. The node handles may be copied out and are valid until they or the"]
    #[doc = "           graph is destroyed. The driver-owned array may also be passed directly to"]
    #[doc = "           APIs that operate on the graph (not the stream) without copying."]
    #[doc = " \\param numDependencies_out - Optional location to store the size of the array"]
    #[doc = "           returned in dependencies_out."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuStreamGetCaptureInfo,"]
    #[doc = " ::cuStreamBeginCapture,"]
    #[doc = " ::cuStreamIsCapturing,"]
    #[doc = " ::cuStreamUpdateCaptureDependencies"]
    pub fn cuStreamGetCaptureInfo_v2(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        numDependencies_out: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Update the set of dependencies in a capturing stream (11.3+)"]
    #[doc = ""]
    #[doc = " Modifies the dependency set of a capturing stream. The dependency set is the set"]
    #[doc = " of nodes that the next captured node in the stream will depend on."]
    #[doc = ""]
    #[doc = " Valid flags are ::CU_STREAM_ADD_CAPTURE_DEPENDENCIES and"]
    #[doc = " ::CU_STREAM_SET_CAPTURE_DEPENDENCIES. These control whether the set passed to"]
    #[doc = " the API is added to the existing set or replaces it. A flags value of 0 defaults"]
    #[doc = " to ::CU_STREAM_ADD_CAPTURE_DEPENDENCIES."]
    #[doc = ""]
    #[doc = " Nodes that are removed from the dependency set via this API do not result in"]
    #[doc = " ::CUDA_ERROR_STREAM_CAPTURE_UNJOINED if they are unreachable from the stream at"]
    #[doc = " ::cuStreamEndCapture."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_ILLEGAL_STATE if the stream is not capturing."]
    #[doc = ""]
    #[doc = " This API is new in CUDA 11.3. Developers requiring compatibility across minor"]
    #[doc = " versions to CUDA 11.0 should not use this API or provide a fallback."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_ILLEGAL_STATE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuStreamBeginCapture,"]
    #[doc = " ::cuStreamGetCaptureInfo,"]
    #[doc = " ::cuStreamGetCaptureInfo_v2"]
    pub fn cuStreamUpdateCaptureDependencies(
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        numDependencies: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Attach memory to a stream asynchronously"]
    #[doc = ""]
    #[doc = " Enqueues an operation in \\p hStream to specify stream association of"]
    #[doc = " \\p length bytes of memory starting from \\p dptr. This function is a"]
    #[doc = " stream-ordered operation, meaning that it is dependent on, and will"]
    #[doc = " only take effect when, previous work in stream has completed. Any"]
    #[doc = " previous association is automatically replaced."]
    #[doc = ""]
    #[doc = " \\p dptr must point to one of the following types of memories:"]
    #[doc = " - managed memory declared using the __managed__ keyword or allocated with"]
    #[doc = "   ::cuMemAllocManaged."]
    #[doc = " - a valid host-accessible region of system-allocated pageable memory. This"]
    #[doc = "   type of memory may only be specified if the device associated with the"]
    #[doc = "   stream reports a non-zero value for the device attribute"]
    #[doc = "   ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS."]
    #[doc = ""]
    #[doc = " For managed allocations, \\p length must be either zero or the entire"]
    #[doc = " allocation's size. Both indicate that the entire allocation's stream"]
    #[doc = " association is being changed. Currently, it is not possible to change stream"]
    #[doc = " association for a portion of a managed allocation."]
    #[doc = ""]
    #[doc = " For pageable host allocations, \\p length must be non-zero."]
    #[doc = ""]
    #[doc = " The stream association is specified using \\p flags which must be"]
    #[doc = " one of ::CUmemAttach_flags."]
    #[doc = " If the ::CU_MEM_ATTACH_GLOBAL flag is specified, the memory can be accessed"]
    #[doc = " by any stream on any device."]
    #[doc = " If the ::CU_MEM_ATTACH_HOST flag is specified, the program makes a guarantee"]
    #[doc = " that it won't access the memory on the device from any stream on a device that"]
    #[doc = " has a zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS."]
    #[doc = " If the ::CU_MEM_ATTACH_SINGLE flag is specified and \\p hStream is associated with"]
    #[doc = " a device that has a zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS,"]
    #[doc = " the program makes a guarantee that it will only access the memory on the device"]
    #[doc = " from \\p hStream. It is illegal to attach singly to the NULL stream, because the"]
    #[doc = " NULL stream is a virtual global stream and not a specific stream. An error will"]
    #[doc = " be returned in this case."]
    #[doc = ""]
    #[doc = " When memory is associated with a single stream, the Unified Memory system will"]
    #[doc = " allow CPU access to this memory region so long as all operations in \\p hStream"]
    #[doc = " have completed, regardless of whether other streams are active. In effect,"]
    #[doc = " this constrains exclusive ownership of the managed memory region by"]
    #[doc = " an active GPU to per-stream activity instead of whole-GPU activity."]
    #[doc = ""]
    #[doc = " Accessing memory on the device from streams that are not associated with"]
    #[doc = " it will produce undefined results. No error checking is performed by the"]
    #[doc = " Unified Memory system to ensure that kernels launched into other streams"]
    #[doc = " do not access this region."]
    #[doc = ""]
    #[doc = " It is a program's responsibility to order calls to ::cuStreamAttachMemAsync"]
    #[doc = " via events, synchronization or other means to ensure legal access to memory"]
    #[doc = " at all times. Data visibility and coherency will be changed appropriately"]
    #[doc = " for all kernels which follow a stream-association change."]
    #[doc = ""]
    #[doc = " If \\p hStream is destroyed while data is associated with it, the association is"]
    #[doc = " removed and the association reverts to the default visibility of the allocation"]
    #[doc = " as specified at ::cuMemAllocManaged. For __managed__ variables, the default"]
    #[doc = " association is always ::CU_MEM_ATTACH_GLOBAL. Note that destroying a stream is an"]
    #[doc = " asynchronous operation, and as a result, the change to default association won't"]
    #[doc = " happen until all work in the stream has completed."]
    #[doc = ""]
    #[doc = " \\param hStream - Stream in which to enqueue the attach operation"]
    #[doc = " \\param dptr    - Pointer to memory (must be a pointer to managed memory or"]
    #[doc = "                  to a valid host-accessible region of system-allocated"]
    #[doc = "                  pageable memory)"]
    #[doc = " \\param length  - Length of memory"]
    #[doc = " \\param flags   - Must be one of ::CUmemAttach_flags"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamCreate,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamDestroy,"]
    #[doc = " ::cuMemAllocManaged,"]
    #[doc = " ::cudaStreamAttachMemAsync"]
    pub fn cuStreamAttachMemAsync(
        hStream: CUstream,
        dptr: CUdeviceptr,
        length: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Determine status of a compute stream"]
    #[doc = ""]
    #[doc = " Returns ::CUDA_SUCCESS if all operations in the stream specified by"]
    #[doc = " \\p hStream have completed, or ::CUDA_ERROR_NOT_READY if not."]
    #[doc = ""]
    #[doc = " For the purposes of Unified Memory, a return value of ::CUDA_SUCCESS"]
    #[doc = " is equivalent to having called ::cuStreamSynchronize()."]
    #[doc = ""]
    #[doc = " \\param hStream - Stream to query status of"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_READY"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamCreate,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamDestroy,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamAddCallback,"]
    #[doc = " ::cudaStreamQuery"]
    pub fn cuStreamQuery(hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Wait until a stream's tasks are completed"]
    #[doc = ""]
    #[doc = " Waits until the device has completed all operations in the stream specified"]
    #[doc = " by \\p hStream. If the context was created with the"]
    #[doc = " ::CU_CTX_SCHED_BLOCKING_SYNC flag, the CPU thread will block until the"]
    #[doc = " stream is finished with all of its tasks."]
    #[doc = ""]
    #[doc = " \\param hStream - Stream to wait for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = ""]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamCreate,"]
    #[doc = " ::cuStreamDestroy,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamAddCallback,"]
    #[doc = " ::cudaStreamSynchronize"]
    pub fn cuStreamSynchronize(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamDestroy_v2(hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies attributes from source stream to destination stream."]
    #[doc = ""]
    #[doc = " Copies attributes from source stream \\p src to destination stream \\p dst."]
    #[doc = " Both streams must have the same context."]
    #[doc = ""]
    #[doc = " \\param[out] dst Destination stream"]
    #[doc = " \\param[in] src Source stream"]
    #[doc = " For list of attributes see ::CUstreamAttrID"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUaccessPolicyWindow"]
    pub fn cuStreamCopyAttributes(dst: CUstream, src: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries stream attribute."]
    #[doc = ""]
    #[doc = " Queries attribute \\p attr from \\p hStream and stores it in corresponding"]
    #[doc = " member of \\p value_out."]
    #[doc = ""]
    #[doc = " \\param[in] hStream"]
    #[doc = " \\param[in] attr"]
    #[doc = " \\param[out] value_out"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUaccessPolicyWindow"]
    pub fn cuStreamGetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value_out: *mut CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets stream attribute."]
    #[doc = ""]
    #[doc = " Sets attribute \\p attr on \\p hStream from corresponding attribute of"]
    #[doc = " \\p value. The updated attribute will be applied to subsequent work"]
    #[doc = " submitted to the stream. It will not affect previously submitted work."]
    #[doc = ""]
    #[doc = " \\param[out] hStream"]
    #[doc = " \\param[in] attr"]
    #[doc = " \\param[in] value"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUaccessPolicyWindow"]
    pub fn cuStreamSetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value: *const CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an event"]
    #[doc = ""]
    #[doc = " Creates an event *phEvent for the current context with the flags specified via"]
    #[doc = " \\p Flags. Valid flags include:"]
    #[doc = " - ::CU_EVENT_DEFAULT: Default event creation flag."]
    #[doc = " - ::CU_EVENT_BLOCKING_SYNC: Specifies that the created event should use blocking"]
    #[doc = "   synchronization.  A CPU thread that uses ::cuEventSynchronize() to wait on"]
    #[doc = "   an event created with this flag will block until the event has actually"]
    #[doc = "   been recorded."]
    #[doc = " - ::CU_EVENT_DISABLE_TIMING: Specifies that the created event does not need"]
    #[doc = "   to record timing data.  Events created with this flag specified and"]
    #[doc = "   the ::CU_EVENT_BLOCKING_SYNC flag not specified will provide the best"]
    #[doc = "   performance when used with ::cuStreamWaitEvent() and ::cuEventQuery()."]
    #[doc = " - ::CU_EVENT_INTERPROCESS: Specifies that the created event may be used as an"]
    #[doc = "   interprocess event by ::cuIpcGetEventHandle(). ::CU_EVENT_INTERPROCESS must"]
    #[doc = "   be specified along with ::CU_EVENT_DISABLE_TIMING."]
    #[doc = ""]
    #[doc = " \\param phEvent - Returns newly created event"]
    #[doc = " \\param Flags   - Event creation flags"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuEventRecord,"]
    #[doc = " ::cuEventQuery,"]
    #[doc = " ::cuEventSynchronize,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cuEventElapsedTime,"]
    #[doc = " ::cudaEventCreate,"]
    #[doc = " ::cudaEventCreateWithFlags"]
    pub fn cuEventCreate(phEvent: *mut CUevent, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Records an event"]
    #[doc = ""]
    #[doc = " Captures in \\p hEvent the contents of \\p hStream at the time of this call."]
    #[doc = " \\p hEvent and \\p hStream must be from the same context."]
    #[doc = " Calls such as ::cuEventQuery() or ::cuStreamWaitEvent() will then"]
    #[doc = " examine or wait for completion of the work that was captured. Uses of"]
    #[doc = " \\p hStream after this call do not modify \\p hEvent. See note on default"]
    #[doc = " stream behavior for what is captured in the default case."]
    #[doc = ""]
    #[doc = " ::cuEventRecord() can be called multiple times on the same event and"]
    #[doc = " will overwrite the previously captured state. Other APIs such as"]
    #[doc = " ::cuStreamWaitEvent() use the most recently captured state at the time"]
    #[doc = " of the API call, and are not affected by later calls to"]
    #[doc = " ::cuEventRecord(). Before the first call to ::cuEventRecord(), an"]
    #[doc = " event represents an empty set of work, so for example ::cuEventQuery()"]
    #[doc = " would return ::CUDA_SUCCESS."]
    #[doc = ""]
    #[doc = " \\param hEvent  - Event to record"]
    #[doc = " \\param hStream - Stream to record event for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuEventCreate,"]
    #[doc = " ::cuEventQuery,"]
    #[doc = " ::cuEventSynchronize,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cuEventElapsedTime,"]
    #[doc = " ::cudaEventRecord,"]
    #[doc = " ::cuEventRecordWithFlags"]
    pub fn cuEventRecord(hEvent: CUevent, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Records an event"]
    #[doc = ""]
    #[doc = " Captures in \\p hEvent the contents of \\p hStream at the time of this call."]
    #[doc = " \\p hEvent and \\p hStream must be from the same context."]
    #[doc = " Calls such as ::cuEventQuery() or ::cuStreamWaitEvent() will then"]
    #[doc = " examine or wait for completion of the work that was captured. Uses of"]
    #[doc = " \\p hStream after this call do not modify \\p hEvent. See note on default"]
    #[doc = " stream behavior for what is captured in the default case."]
    #[doc = ""]
    #[doc = " ::cuEventRecordWithFlags() can be called multiple times on the same event and"]
    #[doc = " will overwrite the previously captured state. Other APIs such as"]
    #[doc = " ::cuStreamWaitEvent() use the most recently captured state at the time"]
    #[doc = " of the API call, and are not affected by later calls to"]
    #[doc = " ::cuEventRecordWithFlags(). Before the first call to ::cuEventRecordWithFlags(), an"]
    #[doc = " event represents an empty set of work, so for example ::cuEventQuery()"]
    #[doc = " would return ::CUDA_SUCCESS."]
    #[doc = ""]
    #[doc = " flags include:"]
    #[doc = " - ::CU_EVENT_RECORD_DEFAULT: Default event creation flag."]
    #[doc = " - ::CU_EVENT_RECORD_EXTERNAL: Event is captured in the graph as an external"]
    #[doc = "   event node when performing stream capture. This flag is invalid outside"]
    #[doc = "   of stream capture."]
    #[doc = ""]
    #[doc = " \\param hEvent  - Event to record"]
    #[doc = " \\param hStream - Stream to record event for"]
    #[doc = " \\param flags   - See ::CUevent_capture_flags"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuEventCreate,"]
    #[doc = " ::cuEventQuery,"]
    #[doc = " ::cuEventSynchronize,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cuEventElapsedTime,"]
    #[doc = " ::cuEventRecord,"]
    #[doc = " ::cudaEventRecord"]
    pub fn cuEventRecordWithFlags(
        hEvent: CUevent,
        hStream: CUstream,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries an event's status"]
    #[doc = ""]
    #[doc = " Queries the status of all work currently captured by \\p hEvent. See"]
    #[doc = " ::cuEventRecord() for details on what is captured by an event."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_SUCCESS if all captured work has been completed, or"]
    #[doc = " ::CUDA_ERROR_NOT_READY if any captured work is incomplete."]
    #[doc = ""]
    #[doc = " For the purposes of Unified Memory, a return value of ::CUDA_SUCCESS"]
    #[doc = " is equivalent to having called ::cuEventSynchronize()."]
    #[doc = ""]
    #[doc = " \\param hEvent - Event to query"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_READY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuEventCreate,"]
    #[doc = " ::cuEventRecord,"]
    #[doc = " ::cuEventSynchronize,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cuEventElapsedTime,"]
    #[doc = " ::cudaEventQuery"]
    pub fn cuEventQuery(hEvent: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Waits for an event to complete"]
    #[doc = ""]
    #[doc = " Waits until the completion of all work currently captured in \\p hEvent."]
    #[doc = " See ::cuEventRecord() for details on what is captured by an event."]
    #[doc = ""]
    #[doc = " Waiting for an event that was created with the ::CU_EVENT_BLOCKING_SYNC"]
    #[doc = " flag will cause the calling CPU thread to block until the event has"]
    #[doc = " been completed by the device.  If the ::CU_EVENT_BLOCKING_SYNC flag has"]
    #[doc = " not been set, then the CPU thread will busy-wait until the event has"]
    #[doc = " been completed by the device."]
    #[doc = ""]
    #[doc = " \\param hEvent - Event to wait for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuEventCreate,"]
    #[doc = " ::cuEventRecord,"]
    #[doc = " ::cuEventQuery,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cuEventElapsedTime,"]
    #[doc = " ::cudaEventSynchronize"]
    pub fn cuEventSynchronize(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventDestroy_v2(hEvent: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Computes the elapsed time between two events"]
    #[doc = ""]
    #[doc = " Computes the elapsed time between two events (in milliseconds with a"]
    #[doc = " resolution of around 0.5 microseconds)."]
    #[doc = ""]
    #[doc = " If either event was last recorded in a non-NULL stream, the resulting time"]
    #[doc = " may be greater than expected (even if both used the same stream handle). This"]
    #[doc = " happens because the ::cuEventRecord() operation takes place asynchronously"]
    #[doc = " and there is no guarantee that the measured latency is actually just between"]
    #[doc = " the two events. Any number of other different stream operations could execute"]
    #[doc = " in between the two measured events, thus altering the timing in a significant"]
    #[doc = " way."]
    #[doc = ""]
    #[doc = " If ::cuEventRecord() has not been called on either event then"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE is returned. If ::cuEventRecord() has been called"]
    #[doc = " on both events but one or both of them has not yet been completed (that is,"]
    #[doc = " ::cuEventQuery() would return ::CUDA_ERROR_NOT_READY on at least one of the"]
    #[doc = " events), ::CUDA_ERROR_NOT_READY is returned. If either event was created with"]
    #[doc = " the ::CU_EVENT_DISABLE_TIMING flag, then this function will return"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE."]
    #[doc = ""]
    #[doc = " \\param pMilliseconds - Time between \\p hStart and \\p hEnd in ms"]
    #[doc = " \\param hStart        - Starting event"]
    #[doc = " \\param hEnd          - Ending event"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_READY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuEventCreate,"]
    #[doc = " ::cuEventRecord,"]
    #[doc = " ::cuEventQuery,"]
    #[doc = " ::cuEventSynchronize,"]
    #[doc = " ::cuEventDestroy,"]
    #[doc = " ::cudaEventElapsedTime"]
    pub fn cuEventElapsedTime(pMilliseconds: *mut f32, hStart: CUevent, hEnd: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Imports an external memory object"]
    #[doc = ""]
    #[doc = " Imports an externally allocated memory object and returns"]
    #[doc = " a handle to that in \\p extMem_out."]
    #[doc = ""]
    #[doc = " The properties of the handle being imported must be described in"]
    #[doc = " \\p memHandleDesc. The ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC structure"]
    #[doc = " is defined as follows:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {"]
    #[doc = "CUexternalMemoryHandleType type;"]
    #[doc = "union {"]
    #[doc = "int fd;"]
    #[doc = "struct {"]
    #[doc = "void *handle;"]
    #[doc = "const void *name;"]
    #[doc = "} win32;"]
    #[doc = "const void *nvSciBufObject;"]
    #[doc = "} handle;"]
    #[doc = "unsigned long long size;"]
    #[doc = "unsigned int flags;"]
    #[doc = "} CUDA_EXTERNAL_MEMORY_HANDLE_DESC;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " where ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type specifies the type"]
    #[doc = " of handle being imported. ::CUexternalMemoryHandleType is"]
    #[doc = " defined as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef enum CUexternalMemoryHandleType_enum {"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD          = 1,"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32       = 2,"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT   = 3,"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP         = 4,"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE     = 5,"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE     = 6,"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,"]
    #[doc = "CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF           = 8"]
    #[doc = "} CUexternalMemoryHandleType;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD, then"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::fd must be a valid"]
    #[doc = " file descriptor referencing a memory object. Ownership of"]
    #[doc = " the file descriptor is transferred to the CUDA driver when the"]
    #[doc = " handle is imported successfully. Performing any operations on the"]
    #[doc = " file descriptor after it is imported results in undefined behavior."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32, then exactly one"]
    #[doc = " of ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be"]
    #[doc = " NULL. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle"]
    #[doc = " is not NULL, then it must represent a valid shared NT handle that"]
    #[doc = " references a memory object. Ownership of this handle is"]
    #[doc = " not transferred to CUDA after the import operation, so the"]
    #[doc = " application must release the handle using the appropriate system"]
    #[doc = " call. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must point to a NULL-terminated array of"]
    #[doc = " UTF-16 characters that refers to a memory object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT, then"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must"]
    #[doc = " be non-NULL and"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name"]
    #[doc = " must be NULL. The handle specified must be a globally shared KMT"]
    #[doc = " handle. This handle does not hold a reference to the underlying"]
    #[doc = " object, and thus will be invalid when all references to the"]
    #[doc = " memory object are destroyed."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP, then exactly one"]
    #[doc = " of ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be"]
    #[doc = " NULL. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle"]
    #[doc = " is not NULL, then it must represent a valid shared NT handle that"]
    #[doc = " is returned by ID3D12Device::CreateSharedHandle when referring to a"]
    #[doc = " ID3D12Heap object. This handle holds a reference to the underlying"]
    #[doc = " object. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must point to a NULL-terminated array of"]
    #[doc = " UTF-16 characters that refers to a ID3D12Heap object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE, then exactly one"]
    #[doc = " of ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be"]
    #[doc = " NULL. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle"]
    #[doc = " is not NULL, then it must represent a valid shared NT handle that"]
    #[doc = " is returned by ID3D12Device::CreateSharedHandle when referring to a"]
    #[doc = " ID3D12Resource object. This handle holds a reference to the"]
    #[doc = " underlying object. If"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must point to a NULL-terminated array of"]
    #[doc = " UTF-16 characters that refers to a ID3D12Resource object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE, then"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must"]
    #[doc = " represent a valid shared NT handle that is returned by"]
    #[doc = " IDXGIResource1::CreateSharedHandle when referring to a"]
    #[doc = " ID3D11Resource object. If"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must point to a NULL-terminated array of"]
    #[doc = " UTF-16 characters that refers to a ID3D11Resource object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT, then"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must"]
    #[doc = " represent a valid shared KMT handle that is returned by"]
    #[doc = " IDXGIResource::GetSharedHandle when referring to a"]
    #[doc = " ID3D11Resource object and"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name"]
    #[doc = " must be NULL."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF, then"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::nvSciBufObject must be non-NULL"]
    #[doc = " and reference a valid NvSciBuf object."]
    #[doc = " If the NvSciBuf object imported into CUDA is also mapped by other drivers, then the"]
    #[doc = " application must use ::cuWaitExternalSemaphoresAsync or ::cuSignalExternalSemaphoresAsync"]
    #[doc = " as appropriate barriers to maintain coherence between CUDA and the other drivers."]
    #[doc = ""]
    #[doc = " The size of the memory object must be specified in"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::size."]
    #[doc = ""]
    #[doc = " Specifying the flag ::CUDA_EXTERNAL_MEMORY_DEDICATED in"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::flags indicates that the"]
    #[doc = " resource is a dedicated resource. The definition of what a"]
    #[doc = " dedicated resource is outside the scope of this extension."]
    #[doc = " This flag must be set if ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type"]
    #[doc = " is one of the following:"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT"]
    #[doc = ""]
    #[doc = " \\param extMem_out    - Returned handle to an external memory object"]
    #[doc = " \\param memHandleDesc - Memory import handle descriptor"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\note If the Vulkan memory imported into CUDA is mapped on the CPU then the"]
    #[doc = " application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges"]
    #[doc = " as well as appropriate Vulkan pipeline barriers to maintain coherence between"]
    #[doc = " CPU and GPU. For more information on these APIs, please refer to \"Synchronization"]
    #[doc = " and Cache Control\" chapter from Vulkan specification."]
    #[doc = ""]
    #[doc = " \\sa ::cuDestroyExternalMemory,"]
    #[doc = " ::cuExternalMemoryGetMappedBuffer,"]
    #[doc = " ::cuExternalMemoryGetMappedMipmappedArray"]
    pub fn cuImportExternalMemory(
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps a buffer onto an imported memory object"]
    #[doc = ""]
    #[doc = " Maps a buffer onto an imported memory object and returns a device"]
    #[doc = " pointer in \\p devPtr."]
    #[doc = ""]
    #[doc = " The properties of the buffer being mapped must be described in"]
    #[doc = " \\p bufferDesc. The ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC structure is"]
    #[doc = " defined as follows:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {"]
    #[doc = "unsigned long long offset;"]
    #[doc = "unsigned long long size;"]
    #[doc = "unsigned int flags;"]
    #[doc = "} CUDA_EXTERNAL_MEMORY_BUFFER_DESC;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " where ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC::offset is the offset in"]
    #[doc = " the memory object where the buffer's base address is."]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC::size is the size of the buffer."]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC::flags must be zero."]
    #[doc = ""]
    #[doc = " The offset and size have to be suitably aligned to match the"]
    #[doc = " requirements of the external API. Mapping two buffers whose ranges"]
    #[doc = " overlap may or may not result in the same virtual address being"]
    #[doc = " returned for the overlapped portion. In such cases, the application"]
    #[doc = " must ensure that all accesses to that region from the GPU are"]
    #[doc = " volatile. Otherwise writes made via one address are not guaranteed"]
    #[doc = " to be visible via the other address, even if they're issued by the"]
    #[doc = " same thread. It is recommended that applications map the combined"]
    #[doc = " range instead of mapping separate buffers and then apply the"]
    #[doc = " appropriate offsets to the returned pointer to derive the"]
    #[doc = " individual buffers."]
    #[doc = ""]
    #[doc = " The returned pointer \\p devPtr must be freed using ::cuMemFree."]
    #[doc = ""]
    #[doc = " \\param devPtr     - Returned device pointer to buffer"]
    #[doc = " \\param extMem     - Handle to external memory object"]
    #[doc = " \\param bufferDesc - Buffer descriptor"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuImportExternalMemory,"]
    #[doc = " ::cuDestroyExternalMemory,"]
    #[doc = " ::cuExternalMemoryGetMappedMipmappedArray"]
    pub fn cuExternalMemoryGetMappedBuffer(
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps a CUDA mipmapped array onto an external memory object"]
    #[doc = ""]
    #[doc = " Maps a CUDA mipmapped array onto an external object and returns a"]
    #[doc = " handle to it in \\p mipmap."]
    #[doc = ""]
    #[doc = " The properties of the CUDA mipmapped array being mapped must be"]
    #[doc = " described in \\p mipmapDesc. The structure"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC is defined as follows:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {"]
    #[doc = "unsigned long long offset;"]
    #[doc = "CUDA_ARRAY3D_DESCRIPTOR arrayDesc;"]
    #[doc = "unsigned int numLevels;"]
    #[doc = "} CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " where ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::offset is the"]
    #[doc = " offset in the memory object where the base level of the mipmap"]
    #[doc = " chain is."]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::arrayDesc describes"]
    #[doc = " the format, dimensions and type of the base level of the mipmap"]
    #[doc = " chain. For further details on these parameters, please refer to the"]
    #[doc = " documentation for ::cuMipmappedArrayCreate. Note that if the mipmapped"]
    #[doc = " array is bound as a color target in the graphics API, then the flag"]
    #[doc = " ::CUDA_ARRAY3D_COLOR_ATTACHMENT must be specified in"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::arrayDesc::Flags."]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::numLevels specifies"]
    #[doc = " the total number of levels in the mipmap chain."]
    #[doc = ""]
    #[doc = " If \\p extMem was imported from a handle of type ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF, then"]
    #[doc = " ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::numLevels must be equal to 1."]
    #[doc = ""]
    #[doc = " The returned CUDA mipmapped array must be freed using ::cuMipmappedArrayDestroy."]
    #[doc = ""]
    #[doc = " \\param mipmap     - Returned CUDA mipmapped array"]
    #[doc = " \\param extMem     - Handle to external memory object"]
    #[doc = " \\param mipmapDesc - CUDA array descriptor"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuImportExternalMemory,"]
    #[doc = " ::cuDestroyExternalMemory,"]
    #[doc = " ::cuExternalMemoryGetMappedBuffer"]
    pub fn cuExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys an external memory object."]
    #[doc = ""]
    #[doc = " Destroys the specified external memory object. Any existing buffers"]
    #[doc = " and CUDA mipmapped arrays mapped onto this object must no longer be"]
    #[doc = " used and must be explicitly freed using ::cuMemFree and"]
    #[doc = " ::cuMipmappedArrayDestroy respectively."]
    #[doc = ""]
    #[doc = " \\param extMem - External memory object to be destroyed"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuImportExternalMemory,"]
    #[doc = " ::cuExternalMemoryGetMappedBuffer,"]
    #[doc = " ::cuExternalMemoryGetMappedMipmappedArray"]
    pub fn cuDestroyExternalMemory(extMem: CUexternalMemory) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Imports an external semaphore"]
    #[doc = ""]
    #[doc = " Imports an externally allocated synchronization object and returns"]
    #[doc = " a handle to that in \\p extSem_out."]
    #[doc = ""]
    #[doc = " The properties of the handle being imported must be described in"]
    #[doc = " \\p semHandleDesc. The ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC is"]
    #[doc = " defined as follows:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {"]
    #[doc = "CUexternalSemaphoreHandleType type;"]
    #[doc = "union {"]
    #[doc = "int fd;"]
    #[doc = "struct {"]
    #[doc = "void *handle;"]
    #[doc = "const void *name;"]
    #[doc = "} win32;"]
    #[doc = "const void* NvSciSyncObj;"]
    #[doc = "} handle;"]
    #[doc = "unsigned int flags;"]
    #[doc = "} CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " where ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type specifies the type of"]
    #[doc = " handle being imported. ::CUexternalSemaphoreHandleType is defined"]
    #[doc = " as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef enum CUexternalSemaphoreHandleType_enum {"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD                = 1,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32             = 2,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT         = 3,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE              = 4,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE              = 5,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC                = 6,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX        = 7,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT    = 8,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD    = 9,"]
    #[doc = "CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10"]
    #[doc = "} CUexternalSemaphoreHandleType;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD, then"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::fd must be a valid"]
    #[doc = " file descriptor referencing a synchronization object. Ownership of"]
    #[doc = " the file descriptor is transferred to the CUDA driver when the"]
    #[doc = " handle is imported successfully. Performing any operations on the"]
    #[doc = " file descriptor after it is imported results in undefined behavior."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32, then exactly one"]
    #[doc = " of ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be"]
    #[doc = " NULL. If"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle"]
    #[doc = " is not NULL, then it must represent a valid shared NT handle that"]
    #[doc = " references a synchronization object. Ownership of this handle is"]
    #[doc = " not transferred to CUDA after the import operation, so the"]
    #[doc = " application must release the handle using the appropriate system"]
    #[doc = " call. If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must name a valid synchronization object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT, then"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle must"]
    #[doc = " be non-NULL and"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name"]
    #[doc = " must be NULL. The handle specified must be a globally shared KMT"]
    #[doc = " handle. This handle does not hold a reference to the underlying"]
    #[doc = " object, and thus will be invalid when all references to the"]
    #[doc = " synchronization object are destroyed."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE, then exactly one"]
    #[doc = " of ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be"]
    #[doc = " NULL. If"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle"]
    #[doc = " is not NULL, then it must represent a valid shared NT handle that"]
    #[doc = " is returned by ID3D12Device::CreateSharedHandle when referring to a"]
    #[doc = " ID3D12Fence object. This handle holds a reference to the underlying"]
    #[doc = " object. If"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must name a valid synchronization object that"]
    #[doc = " refers to a valid ID3D12Fence object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE, then"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle"]
    #[doc = " represents a valid shared NT handle that is returned by"]
    #[doc = " ID3D11Fence::CreateSharedHandle. If"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must name a valid synchronization object that"]
    #[doc = " refers to a valid ID3D11Fence object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, then"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::nvSciSyncObj"]
    #[doc = " represents a valid NvSciSyncObj."]
    #[doc = ""]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX, then"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle"]
    #[doc = " represents a valid shared NT handle that"]
    #[doc = " is returned by IDXGIResource1::CreateSharedHandle when referring to"]
    #[doc = " a IDXGIKeyedMutex object. If"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must name a valid synchronization object that"]
    #[doc = " refers to a valid IDXGIKeyedMutex object."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT, then"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle"]
    #[doc = " represents a valid shared KMT handle that"]
    #[doc = " is returned by IDXGIResource::GetSharedHandle when referring to"]
    #[doc = " a IDXGIKeyedMutex object and"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must be NULL."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD, then"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::fd must be a valid"]
    #[doc = " file descriptor referencing a synchronization object. Ownership of"]
    #[doc = " the file descriptor is transferred to the CUDA driver when the"]
    #[doc = " handle is imported successfully. Performing any operations on the"]
    #[doc = " file descriptor after it is imported results in undefined behavior."]
    #[doc = ""]
    #[doc = " If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32, then exactly one"]
    #[doc = " of ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be"]
    #[doc = " NULL. If"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle"]
    #[doc = " is not NULL, then it must represent a valid shared NT handle that"]
    #[doc = " references a synchronization object. Ownership of this handle is"]
    #[doc = " not transferred to CUDA after the import operation, so the"]
    #[doc = " application must release the handle using the appropriate system"]
    #[doc = " call. If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name"]
    #[doc = " is not NULL, then it must name a valid synchronization object."]
    #[doc = ""]
    #[doc = " \\param extSem_out    - Returned handle to an external semaphore"]
    #[doc = " \\param semHandleDesc - Semaphore import handle descriptor"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuDestroyExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuImportExternalSemaphore(
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Signals a set of external semaphore objects"]
    #[doc = ""]
    #[doc = " Enqueues a signal operation on a set of externally allocated"]
    #[doc = " semaphore object in the specified stream. The operations will be"]
    #[doc = " executed when all prior operations in the stream complete."]
    #[doc = ""]
    #[doc = " The exact semantics of signaling a semaphore depends on the type of"]
    #[doc = " the object."]
    #[doc = ""]
    #[doc = " If the semaphore object is any one of the following types:"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT"]
    #[doc = " then signaling the semaphore will set it to the signaled state."]
    #[doc = ""]
    #[doc = " If the semaphore object is any one of the following types:"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32"]
    #[doc = " then the semaphore will be set to the value specified in"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::fence::value."]
    #[doc = ""]
    #[doc = " If the semaphore object is of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC"]
    #[doc = " this API sets ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence"]
    #[doc = " to a value that can be used by subsequent waiters of the same NvSciSync object"]
    #[doc = " to order operations with those currently submitted in \\p stream. Such an update"]
    #[doc = " will overwrite previous contents of"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence. By default,"]
    #[doc = " signaling such an external semaphore object causes appropriate memory synchronization"]
    #[doc = " operations to be performed over all external memory objects that are imported as"]
    #[doc = " ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF. This ensures that any subsequent accesses"]
    #[doc = " made by other importers of the same set of NvSciBuf memory object(s) are coherent."]
    #[doc = " These operations can be skipped by specifying the flag"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC, which can be used as a"]
    #[doc = " performance optimization when data coherency is not required. But specifying this"]
    #[doc = " flag in scenarios where data coherency is required results in undefined behavior."]
    #[doc = " Also, for semaphore object of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC,"]
    #[doc = " if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in"]
    #[doc = " ::cuDeviceGetNvSciSyncAttributes to CUDA_NVSCISYNC_ATTR_SIGNAL, this API will return"]
    #[doc = " CUDA_ERROR_NOT_SUPPORTED."]
    #[doc = ""]
    #[doc = " If the semaphore object is any one of the following types:"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT"]
    #[doc = " then the keyed mutex will be released with the key specified in"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_PARAMS::params::keyedmutex::key."]
    #[doc = ""]
    #[doc = " \\param extSemArray - Set of external semaphores to be signaled"]
    #[doc = " \\param paramsArray - Array of semaphore parameters"]
    #[doc = " \\param numExtSems  - Number of semaphores to signal"]
    #[doc = " \\param stream      - Stream to enqueue the signal operations in"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuImportExternalSemaphore,"]
    #[doc = " ::cuDestroyExternalSemaphore,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuSignalExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Waits on a set of external semaphore objects"]
    #[doc = ""]
    #[doc = " Enqueues a wait operation on a set of externally allocated"]
    #[doc = " semaphore object in the specified stream. The operations will be"]
    #[doc = " executed when all prior operations in the stream complete."]
    #[doc = ""]
    #[doc = " The exact semantics of waiting on a semaphore depends on the type"]
    #[doc = " of the object."]
    #[doc = ""]
    #[doc = " If the semaphore object is any one of the following types:"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT"]
    #[doc = " then waiting on the semaphore will wait until the semaphore reaches"]
    #[doc = " the signaled state. The semaphore will then be reset to the"]
    #[doc = " unsignaled state. Therefore for every signal operation, there can"]
    #[doc = " only be one wait operation."]
    #[doc = ""]
    #[doc = " If the semaphore object is any one of the following types:"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32"]
    #[doc = " then waiting on the semaphore will wait until the value of the"]
    #[doc = " semaphore is greater than or equal to"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::fence::value."]
    #[doc = ""]
    #[doc = " If the semaphore object is of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC"]
    #[doc = " then, waiting on the semaphore will wait until the"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence is signaled by the"]
    #[doc = " signaler of the NvSciSyncObj that was associated with this semaphore object."]
    #[doc = " By default, waiting on such an external semaphore object causes appropriate"]
    #[doc = " memory synchronization operations to be performed over all external memory objects"]
    #[doc = " that are imported as ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF. This ensures that"]
    #[doc = " any subsequent accesses made by other importers of the same set of NvSciBuf memory"]
    #[doc = " object(s) are coherent. These operations can be skipped by specifying the flag"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC, which can be used as a"]
    #[doc = " performance optimization when data coherency is not required. But specifying this"]
    #[doc = " flag in scenarios where data coherency is required results in undefined behavior."]
    #[doc = " Also, for semaphore object of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC,"]
    #[doc = " if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in"]
    #[doc = " ::cuDeviceGetNvSciSyncAttributes to CUDA_NVSCISYNC_ATTR_WAIT, this API will return"]
    #[doc = " CUDA_ERROR_NOT_SUPPORTED."]
    #[doc = ""]
    #[doc = " If the semaphore object is any one of the following types:"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX,"]
    #[doc = " ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT"]
    #[doc = " then the keyed mutex will be acquired when it is released with the key"]
    #[doc = " specified in ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::keyedmutex::key"]
    #[doc = " or until the timeout specified by"]
    #[doc = " ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::keyedmutex::timeoutMs"]
    #[doc = " has lapsed. The timeout interval can either be a finite value"]
    #[doc = " specified in milliseconds or an infinite value. In case an infinite"]
    #[doc = " value is specified the timeout never elapses. The windows INFINITE"]
    #[doc = " macro must be used to specify infinite timeout."]
    #[doc = ""]
    #[doc = " \\param extSemArray - External semaphores to be waited on"]
    #[doc = " \\param paramsArray - Array of semaphore parameters"]
    #[doc = " \\param numExtSems  - Number of semaphores to wait on"]
    #[doc = " \\param stream      - Stream to enqueue the wait operations in"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_TIMEOUT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuImportExternalSemaphore,"]
    #[doc = " ::cuDestroyExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync"]
    pub fn cuWaitExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys an external semaphore"]
    #[doc = ""]
    #[doc = " Destroys an external semaphore object and releases any references"]
    #[doc = " to the underlying resource. Any outstanding signals or waits must"]
    #[doc = " have completed before the semaphore is destroyed."]
    #[doc = ""]
    #[doc = " \\param extSem - External semaphore to be destroyed"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuImportExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuDestroyExternalSemaphore(extSem: CUexternalSemaphore) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Wait on a memory location"]
    #[doc = ""]
    #[doc = " Enqueues a synchronization of the stream on the given memory location. Work"]
    #[doc = " ordered after the operation will block until the given condition on the"]
    #[doc = " memory is satisfied. By default, the condition is to wait for"]
    #[doc = " (int32_t)(*addr - value) >= 0, a cyclic greater-or-equal."]
    #[doc = " Other condition types can be specified via \\p flags."]
    #[doc = ""]
    #[doc = " If the memory was registered via ::cuMemHostRegister(), the device pointer"]
    #[doc = " should be obtained with ::cuMemHostGetDevicePointer(). This function cannot"]
    #[doc = " be used with managed memory (::cuMemAllocManaged)."]
    #[doc = ""]
    #[doc = " Support for this can be queried with ::cuDeviceGetAttribute() and"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS."]
    #[doc = ""]
    #[doc = " Support for CU_STREAM_WAIT_VALUE_NOR can be queried with ::cuDeviceGetAttribute() and"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR."]
    #[doc = ""]
    #[doc = " \\param stream The stream to synchronize on the memory location."]
    #[doc = " \\param addr The memory location to wait on."]
    #[doc = " \\param value The value to compare with the memory location."]
    #[doc = " \\param flags See ::CUstreamWaitValue_flags."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamWaitValue64,"]
    #[doc = " ::cuStreamWriteValue32,"]
    #[doc = " ::cuStreamWriteValue64,"]
    #[doc = " ::cuStreamBatchMemOp,"]
    #[doc = " ::cuMemHostRegister,"]
    #[doc = " ::cuStreamWaitEvent"]
    pub fn cuStreamWaitValue32(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Wait on a memory location"]
    #[doc = ""]
    #[doc = " Enqueues a synchronization of the stream on the given memory location. Work"]
    #[doc = " ordered after the operation will block until the given condition on the"]
    #[doc = " memory is satisfied. By default, the condition is to wait for"]
    #[doc = " (int64_t)(*addr - value) >= 0, a cyclic greater-or-equal."]
    #[doc = " Other condition types can be specified via \\p flags."]
    #[doc = ""]
    #[doc = " If the memory was registered via ::cuMemHostRegister(), the device pointer"]
    #[doc = " should be obtained with ::cuMemHostGetDevicePointer()."]
    #[doc = ""]
    #[doc = " Support for this can be queried with ::cuDeviceGetAttribute() and"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS."]
    #[doc = ""]
    #[doc = " \\param stream The stream to synchronize on the memory location."]
    #[doc = " \\param addr The memory location to wait on."]
    #[doc = " \\param value The value to compare with the memory location."]
    #[doc = " \\param flags See ::CUstreamWaitValue_flags."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamWaitValue32,"]
    #[doc = " ::cuStreamWriteValue32,"]
    #[doc = " ::cuStreamWriteValue64,"]
    #[doc = " ::cuStreamBatchMemOp,"]
    #[doc = " ::cuMemHostRegister,"]
    #[doc = " ::cuStreamWaitEvent"]
    pub fn cuStreamWaitValue64(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Write a value to memory"]
    #[doc = ""]
    #[doc = " Write a value to memory. Unless the ::CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER"]
    #[doc = " flag is passed, the write is preceded by a system-wide memory fence,"]
    #[doc = " equivalent to a __threadfence_system() but scoped to the stream"]
    #[doc = " rather than a CUDA thread."]
    #[doc = ""]
    #[doc = " If the memory was registered via ::cuMemHostRegister(), the device pointer"]
    #[doc = " should be obtained with ::cuMemHostGetDevicePointer(). This function cannot"]
    #[doc = " be used with managed memory (::cuMemAllocManaged)."]
    #[doc = ""]
    #[doc = " Support for this can be queried with ::cuDeviceGetAttribute() and"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS."]
    #[doc = ""]
    #[doc = " \\param stream The stream to do the write in."]
    #[doc = " \\param addr The device address to write to."]
    #[doc = " \\param value The value to write."]
    #[doc = " \\param flags See ::CUstreamWriteValue_flags."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamWriteValue64,"]
    #[doc = " ::cuStreamWaitValue32,"]
    #[doc = " ::cuStreamWaitValue64,"]
    #[doc = " ::cuStreamBatchMemOp,"]
    #[doc = " ::cuMemHostRegister,"]
    #[doc = " ::cuEventRecord"]
    pub fn cuStreamWriteValue32(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Write a value to memory"]
    #[doc = ""]
    #[doc = " Write a value to memory. Unless the ::CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER"]
    #[doc = " flag is passed, the write is preceded by a system-wide memory fence,"]
    #[doc = " equivalent to a __threadfence_system() but scoped to the stream"]
    #[doc = " rather than a CUDA thread."]
    #[doc = ""]
    #[doc = " If the memory was registered via ::cuMemHostRegister(), the device pointer"]
    #[doc = " should be obtained with ::cuMemHostGetDevicePointer()."]
    #[doc = ""]
    #[doc = " Support for this can be queried with ::cuDeviceGetAttribute() and"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS."]
    #[doc = ""]
    #[doc = " \\param stream The stream to do the write in."]
    #[doc = " \\param addr The device address to write to."]
    #[doc = " \\param value The value to write."]
    #[doc = " \\param flags See ::CUstreamWriteValue_flags."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamWriteValue32,"]
    #[doc = " ::cuStreamWaitValue32,"]
    #[doc = " ::cuStreamWaitValue64,"]
    #[doc = " ::cuStreamBatchMemOp,"]
    #[doc = " ::cuMemHostRegister,"]
    #[doc = " ::cuEventRecord"]
    pub fn cuStreamWriteValue64(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Batch operations to synchronize the stream via memory operations"]
    #[doc = ""]
    #[doc = " This is a batch version of ::cuStreamWaitValue32() and ::cuStreamWriteValue32()."]
    #[doc = " Batching operations may avoid some performance overhead in both the API call"]
    #[doc = " and the device execution versus adding them to the stream in separate API"]
    #[doc = " calls. The operations are enqueued in the order they appear in the array."]
    #[doc = ""]
    #[doc = " See ::CUstreamBatchMemOpType for the full set of supported operations, and"]
    #[doc = " ::cuStreamWaitValue32(), ::cuStreamWaitValue64(), ::cuStreamWriteValue32(),"]
    #[doc = " and ::cuStreamWriteValue64() for details of specific operations."]
    #[doc = ""]
    #[doc = " Basic support for this can be queried with ::cuDeviceGetAttribute() and"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS. See related APIs for details"]
    #[doc = " on querying support for specific operations."]
    #[doc = ""]
    #[doc = " \\param stream The stream to enqueue the operations in."]
    #[doc = " \\param count The number of operations in the array. Must be less than 256."]
    #[doc = " \\param paramArray The types and parameters of the individual operations."]
    #[doc = " \\param flags Reserved for future expansion; must be 0."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamWaitValue32,"]
    #[doc = " ::cuStreamWaitValue64,"]
    #[doc = " ::cuStreamWriteValue32,"]
    #[doc = " ::cuStreamWriteValue64,"]
    #[doc = " ::cuMemHostRegister"]
    pub fn cuStreamBatchMemOp(
        stream: CUstream,
        count: ::std::os::raw::c_uint,
        paramArray: *mut CUstreamBatchMemOpParams,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about a function"]
    #[doc = ""]
    #[doc = " Returns in \\p *pi the integer value of the attribute \\p attrib on the kernel"]
    #[doc = " given by \\p hfunc. The supported attributes are:"]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK: The maximum number of threads"]
    #[doc = "   per block, beyond which a launch of the function would fail. This number"]
    #[doc = "   depends on both the function and the device on which the function is"]
    #[doc = "   currently loaded."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: The size in bytes of"]
    #[doc = "   statically-allocated shared memory per block required by this function."]
    #[doc = "   This does not include dynamically-allocated shared memory requested by"]
    #[doc = "   the user at runtime."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: The size in bytes of user-allocated"]
    #[doc = "   constant memory required by this function."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: The size in bytes of local memory"]
    #[doc = "   used by each thread of this function."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_NUM_REGS: The number of registers used by each thread"]
    #[doc = "   of this function."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_PTX_VERSION: The PTX virtual architecture version for"]
    #[doc = "   which the function was compiled. This value is the major PTX version * 10"]
    #[doc = "   + the minor PTX version, so a PTX version 1.3 function would return the"]
    #[doc = "   value 13. Note that this may return the undefined value of 0 for cubins"]
    #[doc = "   compiled prior to CUDA 3.0."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_BINARY_VERSION: The binary architecture version for"]
    #[doc = "   which the function was compiled. This value is the major binary"]
    #[doc = "   version * 10 + the minor binary version, so a binary version 1.3 function"]
    #[doc = "   would return the value 13. Note that this will return a value of 10 for"]
    #[doc = "   legacy cubins that do not have a properly-encoded binary architecture"]
    #[doc = "   version."]
    #[doc = " - ::CU_FUNC_CACHE_MODE_CA: The attribute to indicate whether the function has"]
    #[doc = "   been compiled with user specified option \"-Xptxas --dlcm=ca\" set ."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: The maximum size in bytes of"]
    #[doc = "   dynamically-allocated shared memory."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: Preferred shared memory-L1"]
    #[doc = "   cache split ratio in percent of total shared memory."]
    #[doc = ""]
    #[doc = " \\param pi     - Returned attribute value"]
    #[doc = " \\param attrib - Attribute requested"]
    #[doc = " \\param hfunc  - Function to query attribute of"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cudaFuncGetAttributes,"]
    #[doc = " ::cudaFuncSetAttribute"]
    pub fn cuFuncGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUfunction_attribute,
        hfunc: CUfunction,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets information about a function"]
    #[doc = ""]
    #[doc = " This call sets the value of a specified attribute \\p attrib on the kernel given"]
    #[doc = " by \\p hfunc to an integer value specified by \\p val"]
    #[doc = " This function returns CUDA_SUCCESS if the new value of the attribute could be"]
    #[doc = " successfully set. If the set fails, this call will return an error."]
    #[doc = " Not all attributes can have values set. Attempting to set a value on a read-only"]
    #[doc = " attribute will result in an error (CUDA_ERROR_INVALID_VALUE)"]
    #[doc = ""]
    #[doc = " Supported attributes for the cuFuncSetAttribute call are:"]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: This maximum size in bytes of"]
    #[doc = "   dynamically-allocated shared memory. The value should contain the requested"]
    #[doc = "   maximum size of dynamically-allocated shared memory. The sum of this value and"]
    #[doc = "   the function attribute ::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES cannot exceed the"]
    #[doc = "   device attribute ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN."]
    #[doc = "   The maximal size of requestable dynamic shared memory may differ by GPU"]
    #[doc = "   architecture."]
    #[doc = " - ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: On devices where the L1"]
    #[doc = "   cache and shared memory use the same hardware resources, this sets the shared memory"]
    #[doc = "   carveout preference, in percent of the total shared memory."]
    #[doc = "   See ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR"]
    #[doc = "   This is only a hint, and the driver can choose a different ratio if required to execute the function."]
    #[doc = ""]
    #[doc = " \\param hfunc  - Function to query attribute of"]
    #[doc = " \\param attrib - Attribute requested"]
    #[doc = " \\param value   - The value to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cudaFuncGetAttributes,"]
    #[doc = " ::cudaFuncSetAttribute"]
    pub fn cuFuncSetAttribute(
        hfunc: CUfunction,
        attrib: CUfunction_attribute,
        value: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for a device function"]
    #[doc = ""]
    #[doc = " On devices where the L1 cache and shared memory use the same hardware"]
    #[doc = " resources, this sets through \\p config the preferred cache configuration for"]
    #[doc = " the device function \\p hfunc. This is only a preference. The driver will use"]
    #[doc = " the requested configuration if possible, but it is free to choose a different"]
    #[doc = " configuration if required to execute \\p hfunc.  Any context-wide preference"]
    #[doc = " set via ::cuCtxSetCacheConfig() will be overridden by this per-function"]
    #[doc = " setting unless the per-function setting is ::CU_FUNC_CACHE_PREFER_NONE. In"]
    #[doc = " that case, the current context-wide setting will be used."]
    #[doc = ""]
    #[doc = " This setting does nothing on devices where the size of the L1 cache and"]
    #[doc = " shared memory are fixed."]
    #[doc = ""]
    #[doc = " Launching a kernel with a different preference than the most recent"]
    #[doc = " preference setting may insert a device-side synchronization point."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " The supported cache configurations are:"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_SHARED: prefer larger shared memory and smaller L1 cache"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_L1: prefer larger L1 cache and smaller shared memory"]
    #[doc = " - ::CU_FUNC_CACHE_PREFER_EQUAL: prefer equal sized L1 cache and shared memory"]
    #[doc = ""]
    #[doc = " \\param hfunc  - Kernel to configure cache for"]
    #[doc = " \\param config - Requested cache configuration"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cudaFuncSetCacheConfig"]
    pub fn cuFuncSetCacheConfig(hfunc: CUfunction, config: CUfunc_cache) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the shared memory configuration for a device function."]
    #[doc = ""]
    #[doc = " On devices with configurable shared memory banks, this function will"]
    #[doc = " force all subsequent launches of the specified device function to have"]
    #[doc = " the given shared memory bank size configuration. On any given launch of the"]
    #[doc = " function, the shared memory configuration of the device will be temporarily"]
    #[doc = " changed if needed to suit the function's preferred configuration. Changes in"]
    #[doc = " shared memory configuration between subsequent launches of functions,"]
    #[doc = " may introduce a device side synchronization point."]
    #[doc = ""]
    #[doc = " Any per-function setting of shared memory bank size set via"]
    #[doc = " ::cuFuncSetSharedMemConfig will override the context wide setting set with"]
    #[doc = " ::cuCtxSetSharedMemConfig."]
    #[doc = ""]
    #[doc = " Changing the shared memory bank size will not increase shared memory usage"]
    #[doc = " or affect occupancy of kernels, but may have major effects on performance."]
    #[doc = " Larger bank sizes will allow for greater potential bandwidth to shared memory,"]
    #[doc = " but will change what kinds of accesses to shared memory will result in bank"]
    #[doc = " conflicts."]
    #[doc = ""]
    #[doc = " This function will do nothing on devices with fixed shared memory bank size."]
    #[doc = ""]
    #[doc = " The supported bank configurations are:"]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: use the context's shared memory"]
    #[doc = "   configuration when launching this function."]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: set shared memory bank width to"]
    #[doc = "   be natively four bytes when launching this function."]
    #[doc = " - ::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: set shared memory bank width to"]
    #[doc = "   be natively eight bytes when launching this function."]
    #[doc = ""]
    #[doc = " \\param hfunc  - kernel to be given a shared memory config"]
    #[doc = " \\param config - requested shared memory configuration"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuCtxGetSharedMemConfig,"]
    #[doc = " ::cuCtxSetSharedMemConfig,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cudaFuncSetSharedMemConfig"]
    pub fn cuFuncSetSharedMemConfig(hfunc: CUfunction, config: CUsharedconfig) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a module handle"]
    #[doc = ""]
    #[doc = " Returns in \\p *hmod the handle of the module that function \\p hfunc"]
    #[doc = " is located in. The lifetime of the module corresponds to the lifetime of"]
    #[doc = " the context it was loaded in or until the module is explicitly unloaded."]
    #[doc = ""]
    #[doc = " The CUDA runtime manages its own modules loaded into the primary context."]
    #[doc = " If the handle returned by this API refers to a module loaded by the CUDA runtime,"]
    #[doc = " calling ::cuModuleUnload() on that module will result in undefined behavior."]
    #[doc = ""]
    #[doc = " \\param hmod - Returned module handle"]
    #[doc = " \\param hfunc   - Function to retrieve module for"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_FOUND"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    pub fn cuFuncGetModule(hmod: *mut CUmodule, hfunc: CUfunction) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function"]
    #[doc = ""]
    #[doc = " Invokes the kernel \\p f on a \\p gridDimX x \\p gridDimY x \\p gridDimZ"]
    #[doc = " grid of blocks. Each block contains \\p blockDimX x \\p blockDimY x"]
    #[doc = " \\p blockDimZ threads."]
    #[doc = ""]
    #[doc = " \\p sharedMemBytes sets the amount of dynamic shared memory that will be"]
    #[doc = " available to each thread block."]
    #[doc = ""]
    #[doc = " Kernel parameters to \\p f can be specified in one of two ways:"]
    #[doc = ""]
    #[doc = " 1) Kernel parameters can be specified via \\p kernelParams.  If \\p f"]
    #[doc = " has N parameters, then \\p kernelParams needs to be an array of N"]
    #[doc = " pointers.  Each of \\p kernelParams[0] through \\p kernelParams[N-1]"]
    #[doc = " must point to a region of memory from which the actual kernel"]
    #[doc = " parameter will be copied.  The number of kernel parameters and their"]
    #[doc = " offsets and sizes do not need to be specified as that information is"]
    #[doc = " retrieved directly from the kernel's image."]
    #[doc = ""]
    #[doc = " 2) Kernel parameters can also be packaged by the application into"]
    #[doc = " a single buffer that is passed in via the \\p extra parameter."]
    #[doc = " This places the burden on the application of knowing each kernel"]
    #[doc = " parameter's size and alignment/padding within the buffer.  Here is"]
    #[doc = " an example of using the \\p extra parameter in this manner:"]
    #[doc = " \\code"]
    #[doc = "size_t argBufferSize;"]
    #[doc = "char argBuffer[256];"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "void *config[] = {"]
    #[doc = "CU_LAUNCH_PARAM_BUFFER_POINTER, argBuffer,"]
    #[doc = "CU_LAUNCH_PARAM_BUFFER_SIZE,    &argBufferSize,"]
    #[doc = "CU_LAUNCH_PARAM_END"]
    #[doc = "};"]
    #[doc = "status = cuLaunchKernel(f, gx, gy, gz, bx, by, bz, sh, s, NULL, config);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " The \\p extra parameter exists to allow ::cuLaunchKernel to take"]
    #[doc = " additional less commonly used arguments.  \\p extra specifies a list of"]
    #[doc = " names of extra settings and their corresponding values.  Each extra"]
    #[doc = " setting name is immediately followed by the corresponding value.  The"]
    #[doc = " list must be terminated with either NULL or ::CU_LAUNCH_PARAM_END."]
    #[doc = ""]
    #[doc = " - ::CU_LAUNCH_PARAM_END, which indicates the end of the \\p extra"]
    #[doc = "   array;"]
    #[doc = " - ::CU_LAUNCH_PARAM_BUFFER_POINTER, which specifies that the next"]
    #[doc = "   value in \\p extra will be a pointer to a buffer containing all"]
    #[doc = "   the kernel parameters for launching kernel \\p f;"]
    #[doc = " - ::CU_LAUNCH_PARAM_BUFFER_SIZE, which specifies that the next"]
    #[doc = "   value in \\p extra will be a pointer to a size_t containing the"]
    #[doc = "   size of the buffer specified with ::CU_LAUNCH_PARAM_BUFFER_POINTER;"]
    #[doc = ""]
    #[doc = " The error ::CUDA_ERROR_INVALID_VALUE will be returned if kernel"]
    #[doc = " parameters are specified with both \\p kernelParams and \\p extra"]
    #[doc = " (i.e. both \\p kernelParams and \\p extra are non-NULL)."]
    #[doc = ""]
    #[doc = " Calling ::cuLaunchKernel() invalidates the persistent function state"]
    #[doc = " set through the following deprecated APIs:"]
    #[doc = "  ::cuFuncSetBlockShape(),"]
    #[doc = "  ::cuFuncSetSharedSize(),"]
    #[doc = "  ::cuParamSetSize(),"]
    #[doc = "  ::cuParamSeti(),"]
    #[doc = "  ::cuParamSetf(),"]
    #[doc = "  ::cuParamSetv()."]
    #[doc = ""]
    #[doc = " Note that to use ::cuLaunchKernel(), the kernel \\p f must either have"]
    #[doc = " been compiled with toolchain version 3.2 or later so that it will"]
    #[doc = " contain kernel parameter information, or have no kernel parameters."]
    #[doc = " If either of these conditions is not met, then ::cuLaunchKernel() will"]
    #[doc = " return ::CUDA_ERROR_INVALID_IMAGE."]
    #[doc = ""]
    #[doc = " \\param f              - Kernel to launch"]
    #[doc = " \\param gridDimX       - Width of grid in blocks"]
    #[doc = " \\param gridDimY       - Height of grid in blocks"]
    #[doc = " \\param gridDimZ       - Depth of grid in blocks"]
    #[doc = " \\param blockDimX      - X dimension of each thread block"]
    #[doc = " \\param blockDimY      - Y dimension of each thread block"]
    #[doc = " \\param blockDimZ      - Z dimension of each thread block"]
    #[doc = " \\param sharedMemBytes - Dynamic shared-memory size per thread block in bytes"]
    #[doc = " \\param hStream        - Stream identifier"]
    #[doc = " \\param kernelParams   - Array of pointers to kernel parameters"]
    #[doc = " \\param extra          - Extra options"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_IMAGE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_FAILED,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_TIMEOUT,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cudaLaunchKernel"]
    pub fn cuLaunchKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function where thread blocks can cooperate and synchronize as they execute"]
    #[doc = ""]
    #[doc = " Invokes the kernel \\p f on a \\p gridDimX x \\p gridDimY x \\p gridDimZ"]
    #[doc = " grid of blocks. Each block contains \\p blockDimX x \\p blockDimY x"]
    #[doc = " \\p blockDimZ threads."]
    #[doc = ""]
    #[doc = " \\p sharedMemBytes sets the amount of dynamic shared memory that will be"]
    #[doc = " available to each thread block."]
    #[doc = ""]
    #[doc = " The device on which this kernel is invoked must have a non-zero value for"]
    #[doc = " the device attribute ::CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH."]
    #[doc = ""]
    #[doc = " The total number of blocks launched cannot exceed the maximum number of blocks per"]
    #[doc = " multiprocessor as returned by ::cuOccupancyMaxActiveBlocksPerMultiprocessor (or"]
    #[doc = " ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) times the number of multiprocessors"]
    #[doc = " as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT."]
    #[doc = ""]
    #[doc = " The kernel cannot make use of CUDA dynamic parallelism."]
    #[doc = ""]
    #[doc = " Kernel parameters must be specified via \\p kernelParams.  If \\p f"]
    #[doc = " has N parameters, then \\p kernelParams needs to be an array of N"]
    #[doc = " pointers.  Each of \\p kernelParams[0] through \\p kernelParams[N-1]"]
    #[doc = " must point to a region of memory from which the actual kernel"]
    #[doc = " parameter will be copied.  The number of kernel parameters and their"]
    #[doc = " offsets and sizes do not need to be specified as that information is"]
    #[doc = " retrieved directly from the kernel's image."]
    #[doc = ""]
    #[doc = " Calling ::cuLaunchCooperativeKernel() sets persistent function state that is"]
    #[doc = " the same as function state set through ::cuLaunchKernel API"]
    #[doc = ""]
    #[doc = " When the kernel \\p f is launched via ::cuLaunchCooperativeKernel(), the previous"]
    #[doc = " block shape, shared size and parameter info associated with \\p f"]
    #[doc = " is overwritten."]
    #[doc = ""]
    #[doc = " Note that to use ::cuLaunchCooperativeKernel(), the kernel \\p f must either have"]
    #[doc = " been compiled with toolchain version 3.2 or later so that it will"]
    #[doc = " contain kernel parameter information, or have no kernel parameters."]
    #[doc = " If either of these conditions is not met, then ::cuLaunchCooperativeKernel() will"]
    #[doc = " return ::CUDA_ERROR_INVALID_IMAGE."]
    #[doc = ""]
    #[doc = " \\param f              - Kernel to launch"]
    #[doc = " \\param gridDimX       - Width of grid in blocks"]
    #[doc = " \\param gridDimY       - Height of grid in blocks"]
    #[doc = " \\param gridDimZ       - Depth of grid in blocks"]
    #[doc = " \\param blockDimX      - X dimension of each thread block"]
    #[doc = " \\param blockDimY      - Y dimension of each thread block"]
    #[doc = " \\param blockDimZ      - Z dimension of each thread block"]
    #[doc = " \\param sharedMemBytes - Dynamic shared-memory size per thread block in bytes"]
    #[doc = " \\param hStream        - Stream identifier"]
    #[doc = " \\param kernelParams   - Array of pointers to kernel parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_IMAGE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_FAILED,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_TIMEOUT,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,"]
    #[doc = " ::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuLaunchCooperativeKernelMultiDevice,"]
    #[doc = " ::cudaLaunchCooperativeKernel"]
    pub fn cuLaunchCooperativeKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute"]
    #[doc = ""]
    #[doc = " \\deprecated This function is deprecated as of CUDA 11.3."]
    #[doc = ""]
    #[doc = " Invokes kernels as specified in the \\p launchParamsList array where each element"]
    #[doc = " of the array specifies all the parameters required to perform a single kernel launch."]
    #[doc = " These kernels can cooperate and synchronize as they execute. The size of the array is"]
    #[doc = " specified by \\p numDevices."]
    #[doc = ""]
    #[doc = " No two kernels can be launched on the same device. All the devices targeted by this"]
    #[doc = " multi-device launch must be identical. All devices must have a non-zero value for the"]
    #[doc = " device attribute ::CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH."]
    #[doc = ""]
    #[doc = " All kernels launched must be identical with respect to the compiled code. Note that"]
    #[doc = " any __device__, __constant__ or __managed__ variables present in the module that owns"]
    #[doc = " the kernel launched on each device, are independently instantiated on every device."]
    #[doc = " It is the application's responsiblity to ensure these variables are initialized and"]
    #[doc = " used appropriately."]
    #[doc = ""]
    #[doc = " The size of the grids as specified in blocks, the size of the blocks themselves"]
    #[doc = " and the amount of shared memory used by each thread block must also match across"]
    #[doc = " all launched kernels."]
    #[doc = ""]
    #[doc = " The streams used to launch these kernels must have been created via either ::cuStreamCreate"]
    #[doc = " or ::cuStreamCreateWithPriority. The NULL stream or ::CU_STREAM_LEGACY or ::CU_STREAM_PER_THREAD"]
    #[doc = " cannot be used."]
    #[doc = ""]
    #[doc = " The total number of blocks launched per kernel cannot exceed the maximum number of blocks"]
    #[doc = " per multiprocessor as returned by ::cuOccupancyMaxActiveBlocksPerMultiprocessor (or"]
    #[doc = " ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) times the number of multiprocessors"]
    #[doc = " as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT. Since the"]
    #[doc = " total number of blocks launched per device has to match across all devices, the maximum"]
    #[doc = " number of blocks that can be launched per device will be limited by the device with the"]
    #[doc = " least number of multiprocessors."]
    #[doc = ""]
    #[doc = " The kernels cannot make use of CUDA dynamic parallelism."]
    #[doc = ""]
    #[doc = " The ::CUDA_LAUNCH_PARAMS structure is defined as:"]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_LAUNCH_PARAMS_st"]
    #[doc = "{"]
    #[doc = "CUfunction function;"]
    #[doc = "unsigned int gridDimX;"]
    #[doc = "unsigned int gridDimY;"]
    #[doc = "unsigned int gridDimZ;"]
    #[doc = "unsigned int blockDimX;"]
    #[doc = "unsigned int blockDimY;"]
    #[doc = "unsigned int blockDimZ;"]
    #[doc = "unsigned int sharedMemBytes;"]
    #[doc = "CUstream hStream;"]
    #[doc = "void **kernelParams;"]
    #[doc = "} CUDA_LAUNCH_PARAMS;"]
    #[doc = " \\endcode"]
    #[doc = " where:"]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::function specifies the kernel to be launched. All functions must"]
    #[doc = "   be identical with respect to the compiled code."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::gridDimX is the width of the grid in blocks. This must match across"]
    #[doc = "   all kernels launched."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::gridDimY is the height of the grid in blocks. This must match across"]
    #[doc = "   all kernels launched."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::gridDimZ is the depth of the grid in blocks. This must match across"]
    #[doc = "   all kernels launched."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::blockDimX is the X dimension of each thread block. This must match across"]
    #[doc = "   all kernels launched."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::blockDimX is the Y dimension of each thread block. This must match across"]
    #[doc = "   all kernels launched."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::blockDimZ is the Z dimension of each thread block. This must match across"]
    #[doc = "   all kernels launched."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::sharedMemBytes is the dynamic shared-memory size per thread block in bytes."]
    #[doc = "   This must match across all kernels launched."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::hStream is the handle to the stream to perform the launch in. This cannot"]
    #[doc = "   be the NULL stream or ::CU_STREAM_LEGACY or ::CU_STREAM_PER_THREAD. The CUDA context associated"]
    #[doc = "   with this stream must match that associated with ::CUDA_LAUNCH_PARAMS::function."]
    #[doc = " - ::CUDA_LAUNCH_PARAMS::kernelParams is an array of pointers to kernel parameters. If"]
    #[doc = "   ::CUDA_LAUNCH_PARAMS::function has N parameters, then ::CUDA_LAUNCH_PARAMS::kernelParams"]
    #[doc = "   needs to be an array of N pointers. Each of ::CUDA_LAUNCH_PARAMS::kernelParams[0] through"]
    #[doc = "   ::CUDA_LAUNCH_PARAMS::kernelParams[N-1] must point to a region of memory from which the actual"]
    #[doc = "   kernel parameter will be copied. The number of kernel parameters and their offsets and sizes"]
    #[doc = "   do not need to be specified as that information is retrieved directly from the kernel's image."]
    #[doc = ""]
    #[doc = " By default, the kernel won't begin execution on any GPU until all prior work in all the specified"]
    #[doc = " streams has completed. This behavior can be overridden by specifying the flag"]
    #[doc = " ::CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC. When this flag is specified, each kernel"]
    #[doc = " will only wait for prior work in the stream corresponding to that GPU to complete before it begins"]
    #[doc = " execution."]
    #[doc = ""]
    #[doc = " Similarly, by default, any subsequent work pushed in any of the specified streams will not begin"]
    #[doc = " execution until the kernels on all GPUs have completed. This behavior can be overridden by specifying"]
    #[doc = " the flag ::CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC. When this flag is specified,"]
    #[doc = " any subsequent work pushed in any of the specified streams will only wait for the kernel launched"]
    #[doc = " on the GPU corresponding to that stream to complete before it begins execution."]
    #[doc = ""]
    #[doc = " Calling ::cuLaunchCooperativeKernelMultiDevice() sets persistent function state that is"]
    #[doc = " the same as function state set through ::cuLaunchKernel API when called individually for each"]
    #[doc = " element in \\p launchParamsList."]
    #[doc = ""]
    #[doc = " When kernels are launched via ::cuLaunchCooperativeKernelMultiDevice(), the previous"]
    #[doc = " block shape, shared size and parameter info associated with each ::CUDA_LAUNCH_PARAMS::function"]
    #[doc = " in \\p launchParamsList is overwritten."]
    #[doc = ""]
    #[doc = " Note that to use ::cuLaunchCooperativeKernelMultiDevice(), the kernels must either have"]
    #[doc = " been compiled with toolchain version 3.2 or later so that it will"]
    #[doc = " contain kernel parameter information, or have no kernel parameters."]
    #[doc = " If either of these conditions is not met, then ::cuLaunchCooperativeKernelMultiDevice() will"]
    #[doc = " return ::CUDA_ERROR_INVALID_IMAGE."]
    #[doc = ""]
    #[doc = " \\param launchParamsList - List of launch parameters, one per device"]
    #[doc = " \\param numDevices       - Size of the \\p launchParamsList array"]
    #[doc = " \\param flags            - Flags to control launch behavior"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_IMAGE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_FAILED,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_TIMEOUT,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,"]
    #[doc = " ::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuCtxGetCacheConfig,"]
    #[doc = " ::cuCtxSetCacheConfig,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuLaunchCooperativeKernel,"]
    #[doc = " ::cudaLaunchCooperativeKernelMultiDevice"]
    pub fn cuLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut CUDA_LAUNCH_PARAMS,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Enqueues a host function call in a stream"]
    #[doc = ""]
    #[doc = " Enqueues a host function to run in a stream.  The function will be called"]
    #[doc = " after currently enqueued work and will block work added after it."]
    #[doc = ""]
    #[doc = " The host function must not make any CUDA API calls.  Attempting to use a"]
    #[doc = " CUDA API may result in ::CUDA_ERROR_NOT_PERMITTED, but this is not required."]
    #[doc = " The host function must not perform any synchronization that may depend on"]
    #[doc = " outstanding CUDA work not mandated to run earlier.  Host functions without a"]
    #[doc = " mandated order (such as in independent streams) execute in undefined order"]
    #[doc = " and may be serialized."]
    #[doc = ""]
    #[doc = " For the purposes of Unified Memory, execution makes a number of guarantees:"]
    #[doc = " <ul>"]
    #[doc = "   <li>The stream is considered idle for the duration of the function's"]
    #[doc = "   execution.  Thus, for example, the function may always use memory attached"]
    #[doc = "   to the stream it was enqueued in.</li>"]
    #[doc = "   <li>The start of execution of the function has the same effect as"]
    #[doc = "   synchronizing an event recorded in the same stream immediately prior to"]
    #[doc = "   the function.  It thus synchronizes streams which have been \"joined\""]
    #[doc = "   prior to the function.</li>"]
    #[doc = "   <li>Adding device work to any stream does not have the effect of making"]
    #[doc = "   the stream active until all preceding host functions and stream callbacks"]
    #[doc = "   have executed.  Thus, for"]
    #[doc = "   example, a function might use global attached memory even if work has"]
    #[doc = "   been added to another stream, if the work has been ordered behind the"]
    #[doc = "   function call with an event.</li>"]
    #[doc = "   <li>Completion of the function does not cause a stream to become"]
    #[doc = "   active except as described above.  The stream will remain idle"]
    #[doc = "   if no device work follows the function, and will remain idle across"]
    #[doc = "   consecutive host functions or stream callbacks without device work in"]
    #[doc = "   between.  Thus, for example,"]
    #[doc = "   stream synchronization can be done by signaling from a host function at the"]
    #[doc = "   end of the stream.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " Note that, in contrast to ::cuStreamAddCallback, the function will not be"]
    #[doc = " called in the event of an error in the CUDA context."]
    #[doc = ""]
    #[doc = " \\param hStream  - Stream to enqueue function call in"]
    #[doc = " \\param fn       - The function to call once preceding stream operations are complete"]
    #[doc = " \\param userData - User-specified data to be passed to the function"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuStreamCreate,"]
    #[doc = " ::cuStreamQuery,"]
    #[doc = " ::cuStreamSynchronize,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuStreamDestroy,"]
    #[doc = " ::cuMemAllocManaged,"]
    #[doc = " ::cuStreamAttachMemAsync,"]
    #[doc = " ::cuStreamAddCallback"]
    pub fn cuLaunchHostFunc(
        hStream: CUstream,
        fn_: CUhostFn,
        userData: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the block-dimensions for the function"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the \\p x, \\p y, and \\p z dimensions of the thread blocks that are"]
    #[doc = " created when the kernel given by \\p hfunc is launched."]
    #[doc = ""]
    #[doc = " \\param hfunc - Kernel to specify dimensions of"]
    #[doc = " \\param x     - X dimension"]
    #[doc = " \\param y     - Y dimension"]
    #[doc = " \\param z     - Z dimension"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuFuncSetBlockShape(
        hfunc: CUfunction,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the dynamic shared-memory size for the function"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Sets through \\p bytes the amount of dynamic shared memory that will be"]
    #[doc = " available to each thread block when the kernel given by \\p hfunc is launched."]
    #[doc = ""]
    #[doc = " \\param hfunc - Kernel to specify dynamic shared-memory size for"]
    #[doc = " \\param bytes - Dynamic shared-memory size per thread in bytes"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetCacheConfig,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuFuncSetSharedSize(hfunc: CUfunction, bytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameter size for the function"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Sets through \\p numbytes the total size in bytes needed by the function"]
    #[doc = " parameters of the kernel corresponding to \\p hfunc."]
    #[doc = ""]
    #[doc = " \\param hfunc    - Kernel to set parameter size for"]
    #[doc = " \\param numbytes - Size of parameter list in bytes"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuParamSetSize(hfunc: CUfunction, numbytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds an integer parameter to the function's argument list"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Sets an integer parameter that will be specified the next time the"]
    #[doc = " kernel corresponding to \\p hfunc will be invoked. \\p offset is a byte offset."]
    #[doc = ""]
    #[doc = " \\param hfunc  - Kernel to add parameter to"]
    #[doc = " \\param offset - Offset to add parameter to argument list"]
    #[doc = " \\param value  - Value of parameter"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuParamSeti(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds a floating-point parameter to the function's argument list"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Sets a floating-point parameter that will be specified the next time the"]
    #[doc = " kernel corresponding to \\p hfunc will be invoked. \\p offset is a byte offset."]
    #[doc = ""]
    #[doc = " \\param hfunc  - Kernel to add parameter to"]
    #[doc = " \\param offset - Offset to add parameter to argument list"]
    #[doc = " \\param value  - Value of parameter"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuParamSetf(hfunc: CUfunction, offset: ::std::os::raw::c_int, value: f32) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds arbitrary data to the function's argument list"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Copies an arbitrary amount of data (specified in \\p numbytes) from \\p ptr"]
    #[doc = " into the parameter space of the kernel corresponding to \\p hfunc. \\p offset"]
    #[doc = " is a byte offset."]
    #[doc = ""]
    #[doc = " \\param hfunc    - Kernel to add data to"]
    #[doc = " \\param offset   - Offset to add data to argument list"]
    #[doc = " \\param ptr      - Pointer to arbitrary data"]
    #[doc = " \\param numbytes - Size of data to copy in bytes"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuParamSetv(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
        numbytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Invokes the kernel \\p f on a 1 x 1 x 1 grid of blocks. The block"]
    #[doc = " contains the number of threads specified by a previous call to"]
    #[doc = " ::cuFuncSetBlockShape()."]
    #[doc = ""]
    #[doc = " The block shape, dynamic shared memory size, and parameter information"]
    #[doc = " must be set using"]
    #[doc = "  ::cuFuncSetBlockShape(),"]
    #[doc = "  ::cuFuncSetSharedSize(),"]
    #[doc = "  ::cuParamSetSize(),"]
    #[doc = "  ::cuParamSeti(),"]
    #[doc = "  ::cuParamSetf(), and"]
    #[doc = "  ::cuParamSetv()"]
    #[doc = " prior to calling this function."]
    #[doc = ""]
    #[doc = " Launching a function via ::cuLaunchKernel() invalidates the function's"]
    #[doc = " block shape, dynamic shared memory size, and parameter information. After"]
    #[doc = " launching via cuLaunchKernel, this state must be re-initialized prior to"]
    #[doc = " calling this function. Failure to do so results in undefined behavior."]
    #[doc = ""]
    #[doc = " \\param f - Kernel to launch"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_FAILED,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_TIMEOUT,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuLaunch(f: CUfunction) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Invokes the kernel \\p f on a \\p grid_width x \\p grid_height grid of"]
    #[doc = " blocks. Each block contains the number of threads specified by a previous"]
    #[doc = " call to ::cuFuncSetBlockShape()."]
    #[doc = ""]
    #[doc = " The block shape, dynamic shared memory size, and parameter information"]
    #[doc = " must be set using"]
    #[doc = "  ::cuFuncSetBlockShape(),"]
    #[doc = "  ::cuFuncSetSharedSize(),"]
    #[doc = "  ::cuParamSetSize(),"]
    #[doc = "  ::cuParamSeti(),"]
    #[doc = "  ::cuParamSetf(), and"]
    #[doc = "  ::cuParamSetv()"]
    #[doc = " prior to calling this function."]
    #[doc = ""]
    #[doc = " Launching a function via ::cuLaunchKernel() invalidates the function's"]
    #[doc = " block shape, dynamic shared memory size, and parameter information. After"]
    #[doc = " launching via cuLaunchKernel, this state must be re-initialized prior to"]
    #[doc = " calling this function. Failure to do so results in undefined behavior."]
    #[doc = ""]
    #[doc = " \\param f           - Kernel to launch"]
    #[doc = " \\param grid_width  - Width of grid in blocks"]
    #[doc = " \\param grid_height - Height of grid in blocks"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_FAILED,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_TIMEOUT,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGridAsync,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuLaunchGrid(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Invokes the kernel \\p f on a \\p grid_width x \\p grid_height grid of"]
    #[doc = " blocks. Each block contains the number of threads specified by a previous"]
    #[doc = " call to ::cuFuncSetBlockShape()."]
    #[doc = ""]
    #[doc = " The block shape, dynamic shared memory size, and parameter information"]
    #[doc = " must be set using"]
    #[doc = "  ::cuFuncSetBlockShape(),"]
    #[doc = "  ::cuFuncSetSharedSize(),"]
    #[doc = "  ::cuParamSetSize(),"]
    #[doc = "  ::cuParamSeti(),"]
    #[doc = "  ::cuParamSetf(), and"]
    #[doc = "  ::cuParamSetv()"]
    #[doc = " prior to calling this function."]
    #[doc = ""]
    #[doc = " Launching a function via ::cuLaunchKernel() invalidates the function's"]
    #[doc = " block shape, dynamic shared memory size, and parameter information. After"]
    #[doc = " launching via cuLaunchKernel, this state must be re-initialized prior to"]
    #[doc = " calling this function. Failure to do so results in undefined behavior."]
    #[doc = ""]
    #[doc = " \\param f           - Kernel to launch"]
    #[doc = " \\param grid_width  - Width of grid in blocks"]
    #[doc = " \\param grid_height - Height of grid in blocks"]
    #[doc = " \\param hStream     - Stream identifier"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_FAILED,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_TIMEOUT,"]
    #[doc = " ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,"]
    #[doc = " ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED"]
    #[doc = ""]
    #[doc = " \\note In certain cases where cubins are created with no ABI (i.e., using \\p ptxas \\p --abi-compile \\p no),"]
    #[doc = "       this function may serialize kernel launches. The CUDA driver retains asynchronous behavior by"]
    #[doc = "       growing the per-thread stack as needed per launch and not shrinking it afterwards."]
    #[doc = ""]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa ::cuFuncSetBlockShape,"]
    #[doc = " ::cuFuncSetSharedSize,"]
    #[doc = " ::cuFuncGetAttribute,"]
    #[doc = " ::cuParamSetSize,"]
    #[doc = " ::cuParamSetf,"]
    #[doc = " ::cuParamSeti,"]
    #[doc = " ::cuParamSetv,"]
    #[doc = " ::cuLaunch,"]
    #[doc = " ::cuLaunchGrid,"]
    #[doc = " ::cuLaunchKernel"]
    pub fn cuLaunchGridAsync(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds a texture-reference to the function's argument list"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Makes the CUDA array or linear memory bound to the texture reference"]
    #[doc = " \\p hTexRef available to a device program as a texture. In this version of"]
    #[doc = " CUDA, the texture-reference must be obtained via ::cuModuleGetTexRef() and"]
    #[doc = " the \\p texunit parameter must be set to ::CU_PARAM_TR_DEFAULT."]
    #[doc = ""]
    #[doc = " \\param hfunc   - Kernel to add texture-reference to"]
    #[doc = " \\param texunit - Texture unit (must be ::CU_PARAM_TR_DEFAULT)"]
    #[doc = " \\param hTexRef - Texture-reference to add to argument list"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    pub fn cuParamSetTexRef(
        hfunc: CUfunction,
        texunit: ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a graph"]
    #[doc = ""]
    #[doc = " Creates an empty graph, which is returned via \\p phGraph."]
    #[doc = ""]
    #[doc = " \\param phGraph - Returns newly created graph"]
    #[doc = " \\param flags   - Graph creation flags, must be 0"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    #[doc = " ::cuGraphInstantiate,"]
    #[doc = " ::cuGraphDestroy,"]
    #[doc = " ::cuGraphGetNodes,"]
    #[doc = " ::cuGraphGetRootNodes,"]
    #[doc = " ::cuGraphGetEdges,"]
    #[doc = " ::cuGraphClone"]
    pub fn cuGraphCreate(phGraph: *mut CUgraph, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a kernel execution node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new kernel execution node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies and arguments specified in \\p nodeParams."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " The CUDA_KERNEL_NODE_PARAMS structure is defined as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "  typedef struct CUDA_KERNEL_NODE_PARAMS_st {"]
    #[doc = "      CUfunction func;"]
    #[doc = "      unsigned int gridDimX;"]
    #[doc = "      unsigned int gridDimY;"]
    #[doc = "      unsigned int gridDimZ;"]
    #[doc = "      unsigned int blockDimX;"]
    #[doc = "      unsigned int blockDimY;"]
    #[doc = "      unsigned int blockDimZ;"]
    #[doc = "      unsigned int sharedMemBytes;"]
    #[doc = "      void **kernelParams;"]
    #[doc = "      void **extra;"]
    #[doc = "  } CUDA_KERNEL_NODE_PARAMS;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " When the graph is launched, the node will invoke kernel \\p func on a (\\p gridDimX x"]
    #[doc = " \\p gridDimY x \\p gridDimZ) grid of blocks. Each block contains"]
    #[doc = " (\\p blockDimX x \\p blockDimY x \\p blockDimZ) threads."]
    #[doc = ""]
    #[doc = " \\p sharedMemBytes sets the amount of dynamic shared memory that will be"]
    #[doc = " available to each thread block."]
    #[doc = ""]
    #[doc = " Kernel parameters to \\p func can be specified in one of two ways:"]
    #[doc = ""]
    #[doc = " 1) Kernel parameters can be specified via \\p kernelParams. If the kernel has N"]
    #[doc = " parameters, then \\p kernelParams needs to be an array of N pointers. Each pointer,"]
    #[doc = " from \\p kernelParams[0] to \\p kernelParams[N-1], points to the region of memory from which the actual"]
    #[doc = " parameter will be copied. The number of kernel parameters and their offsets and sizes do not need"]
    #[doc = " to be specified as that information is retrieved directly from the kernel's image."]
    #[doc = ""]
    #[doc = " 2) Kernel parameters for non-cooperative kernels can also be packaged by the application into a single"]
    #[doc = " buffer that is passed in via \\p extra. This places the burden on the application of knowing each"]
    #[doc = " kernel parameter's size and alignment/padding within the buffer. The \\p extra parameter exists"]
    #[doc = " to allow this function to take additional less commonly used arguments. \\p extra specifies"]
    #[doc = " a list of names of extra settings and their corresponding values. Each extra setting name is"]
    #[doc = " immediately followed by the corresponding value. The list must be terminated with either NULL or"]
    #[doc = " CU_LAUNCH_PARAM_END."]
    #[doc = ""]
    #[doc = " - ::CU_LAUNCH_PARAM_END, which indicates the end of the \\p extra"]
    #[doc = "   array;"]
    #[doc = " - ::CU_LAUNCH_PARAM_BUFFER_POINTER, which specifies that the next"]
    #[doc = "   value in \\p extra will be a pointer to a buffer"]
    #[doc = "   containing all the kernel parameters for launching kernel"]
    #[doc = "   \\p func;"]
    #[doc = " - ::CU_LAUNCH_PARAM_BUFFER_SIZE, which specifies that the next"]
    #[doc = "   value in \\p extra will be a pointer to a size_t"]
    #[doc = "   containing the size of the buffer specified with"]
    #[doc = "   ::CU_LAUNCH_PARAM_BUFFER_POINTER;"]
    #[doc = ""]
    #[doc = " The error ::CUDA_ERROR_INVALID_VALUE will be returned if kernel parameters are specified with both"]
    #[doc = " \\p kernelParams and \\p extra (i.e. both \\p kernelParams and \\p extra are non-NULL)."]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE will be returned if \\p extra is used for a cooperative kernel."]
    #[doc = ""]
    #[doc = " The \\p kernelParams or \\p extra array, as well as the argument values it points to,"]
    #[doc = " are copied during this call."]
    #[doc = ""]
    #[doc = " \\note Kernels launched using graphs must not use texture and surface references. Reading or"]
    #[doc = "       writing through any texture or surface reference is undefined behavior."]
    #[doc = "       This restriction does not apply to texture and surface objects."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param nodeParams      - Parameters for the GPU execution node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cuLaunchCooperativeKernel,"]
    #[doc = " ::cuGraphKernelNodeGetParams,"]
    #[doc = " ::cuGraphKernelNodeSetParams,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddKernelNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a kernel node's parameters"]
    #[doc = ""]
    #[doc = " Returns the parameters of kernel node \\p hNode in \\p nodeParams."]
    #[doc = " The \\p kernelParams or \\p extra array returned in \\p nodeParams,"]
    #[doc = " as well as the argument values it points to, are owned by the node."]
    #[doc = " This memory remains valid until the node is destroyed or its"]
    #[doc = " parameters are modified, and should not be modified"]
    #[doc = " directly. Use ::cuGraphKernelNodeSetParams to update the"]
    #[doc = " parameters of this node."]
    #[doc = ""]
    #[doc = " The params will contain either \\p kernelParams or \\p extra,"]
    #[doc = " according to which of these was most recently set on the node."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to get the parameters for"]
    #[doc = " \\param nodeParams - Pointer to return the parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphKernelNodeSetParams"]
    pub fn cuGraphKernelNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a kernel node's parameters"]
    #[doc = ""]
    #[doc = " Sets the parameters of kernel node \\p hNode to \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to set the parameters for"]
    #[doc = " \\param nodeParams - Parameters to copy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphKernelNodeGetParams"]
    pub fn cuGraphKernelNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memcpy node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new memcpy node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " When the graph is launched, the node will perform the memcpy described by \\p copyParams."]
    #[doc = " See ::cuMemcpy3D() for a description of the structure and its restrictions."]
    #[doc = ""]
    #[doc = " Memcpy nodes have some additional restrictions with regards to managed memory, if the"]
    #[doc = " system contains at least one device which has a zero value for the device attribute"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS. If one or more of the operands refer"]
    #[doc = " to managed memory, then using the memory type ::CU_MEMORYTYPE_UNIFIED is disallowed"]
    #[doc = " for those operand(s). The managed memory will be treated as residing on either the"]
    #[doc = " host or the device, depending on which memory type is specified."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param copyParams      - Parameters for the memory copy"]
    #[doc = " \\param ctx             - Context on which to run the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemcpy3D,"]
    #[doc = " ::cuGraphMemcpyNodeGetParams,"]
    #[doc = " ::cuGraphMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddMemcpyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memcpy node's parameters"]
    #[doc = ""]
    #[doc = " Returns the parameters of memcpy node \\p hNode in \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to get the parameters for"]
    #[doc = " \\param nodeParams - Pointer to return the parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemcpy3D,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphMemcpyNodeSetParams"]
    pub fn cuGraphMemcpyNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a memcpy node's parameters"]
    #[doc = ""]
    #[doc = " Sets the parameters of memcpy node \\p hNode to \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to set the parameters for"]
    #[doc = " \\param nodeParams - Parameters to copy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemcpy3D,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphMemcpyNodeGetParams"]
    pub fn cuGraphMemcpyNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memset node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new memset node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " The element size must be 1, 2, or 4 bytes."]
    #[doc = " When the graph is launched, the node will perform the memset described by \\p memsetParams."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param memsetParams    - Parameters for the memory set"]
    #[doc = " \\param ctx             - Context on which to run the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemsetD2D32,"]
    #[doc = " ::cuGraphMemsetNodeGetParams,"]
    #[doc = " ::cuGraphMemsetNodeSetParams,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphAddMemcpyNode"]
    pub fn cuGraphAddMemsetNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memset node's parameters"]
    #[doc = ""]
    #[doc = " Returns the parameters of memset node \\p hNode in \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to get the parameters for"]
    #[doc = " \\param nodeParams - Pointer to return the parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemsetD2D32,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    #[doc = " ::cuGraphMemsetNodeSetParams"]
    pub fn cuGraphMemsetNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a memset node's parameters"]
    #[doc = ""]
    #[doc = " Sets the parameters of memset node \\p hNode to \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to set the parameters for"]
    #[doc = " \\param nodeParams - Parameters to copy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuMemsetD2D32,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    #[doc = " ::cuGraphMemsetNodeGetParams"]
    pub fn cuGraphMemsetNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a host execution node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new CPU execution node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies and arguments specified in \\p nodeParams."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " When the graph is launched, the node will invoke the specified CPU function."]
    #[doc = " Host nodes are not supported under MPS with pre-Volta GPUs."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param nodeParams      - Parameters for the host node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchHostFunc,"]
    #[doc = " ::cuGraphHostNodeGetParams,"]
    #[doc = " ::cuGraphHostNodeSetParams,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddHostNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a host node's parameters"]
    #[doc = ""]
    #[doc = " Returns the parameters of host node \\p hNode in \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to get the parameters for"]
    #[doc = " \\param nodeParams - Pointer to return the parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchHostFunc,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphHostNodeSetParams"]
    pub fn cuGraphHostNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a host node's parameters"]
    #[doc = ""]
    #[doc = " Sets the parameters of host node \\p hNode to \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to set the parameters for"]
    #[doc = " \\param nodeParams - Parameters to copy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchHostFunc,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphHostNodeGetParams"]
    pub fn cuGraphHostNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a child graph node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new node which executes an embedded graph, and adds it to \\p hGraph with"]
    #[doc = " \\p numDependencies dependencies specified via \\p dependencies."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " If \\p hGraph contains allocation or free nodes, this call will return an error."]
    #[doc = ""]
    #[doc = " The node executes an embedded child graph. The child graph is cloned in this call."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param childGraph      - The graph to clone into this node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphChildGraphNodeGetGraph,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    #[doc = " ::cuGraphClone"]
    pub fn cuGraphAddChildGraphNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets a handle to the embedded graph of a child graph node"]
    #[doc = ""]
    #[doc = " Gets a handle to the embedded graph in a child graph node. This call"]
    #[doc = " does not clone the graph. Changes to the graph will be reflected in"]
    #[doc = " the node, and the node retains ownership of the graph."]
    #[doc = ""]
    #[doc = " Allocation and free nodes cannot be added to the returned graph."]
    #[doc = " Attempting to do so will return an error."]
    #[doc = ""]
    #[doc = " \\param hNode   - Node to get the embedded graph for"]
    #[doc = " \\param phGraph - Location to store a handle to the graph"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphNodeFindInClone"]
    pub fn cuGraphChildGraphNodeGetGraph(hNode: CUgraphNode, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an empty node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new node which performs no operation, and adds it to \\p hGraph with"]
    #[doc = " \\p numDependencies dependencies specified via \\p dependencies."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " An empty node performs no operation during execution, but can be used for"]
    #[doc = " transitive ordering. For example, a phased execution graph with 2 groups of n"]
    #[doc = " nodes with a barrier between them can be represented using an empty node and"]
    #[doc = " 2*n dependency edges, rather than no empty node and n^2 dependency edges."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddEmptyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an event record node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new event record node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies and event specified in \\p event."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " Each launch of the graph will record \\p event to capture execution of the"]
    #[doc = " node's dependencies."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param event           - Event for the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    pub fn cuGraphAddEventRecordNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the event associated with an event record node"]
    #[doc = ""]
    #[doc = " Returns the event of event record node \\p hNode in \\p event_out."]
    #[doc = ""]
    #[doc = " \\param hNode     - Node to get the event for"]
    #[doc = " \\param event_out - Pointer to return the event"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuGraphEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphEventWaitNodeGetEvent,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent"]
    pub fn cuGraphEventRecordNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an event record node's event"]
    #[doc = ""]
    #[doc = " Sets the event of event record node \\p hNode to \\p event."]
    #[doc = ""]
    #[doc = " \\param hNode - Node to set the event for"]
    #[doc = " \\param event - Event to use"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuGraphEventRecordNodeGetEvent,"]
    #[doc = " ::cuGraphEventWaitNodeSetEvent,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent"]
    pub fn cuGraphEventRecordNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an event wait node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new event wait node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies and event specified in \\p event."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries."]
    #[doc = " A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " The graph node will wait for all work captured in \\p event.  See ::cuEventRecord()"]
    #[doc = " for details on what is captured by an event. \\p event may be from a different context"]
    #[doc = " or device than the launch stream."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param event           - Event for the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    pub fn cuGraphAddEventWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the event associated with an event wait node"]
    #[doc = ""]
    #[doc = " Returns the event of event wait node \\p hNode in \\p event_out."]
    #[doc = ""]
    #[doc = " \\param hNode     - Node to get the event for"]
    #[doc = " \\param event_out - Pointer to return the event"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuGraphEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphEventRecordNodeGetEvent,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent"]
    pub fn cuGraphEventWaitNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an event wait node's event"]
    #[doc = ""]
    #[doc = " Sets the event of event wait node \\p hNode to \\p event."]
    #[doc = ""]
    #[doc = " \\param hNode - Node to set the event for"]
    #[doc = " \\param event - Event to use"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuGraphEventWaitNodeGetEvent,"]
    #[doc = " ::cuGraphEventRecordNodeSetEvent,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent"]
    pub fn cuGraphEventWaitNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an external semaphore signal node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new external semaphore signal node and adds it to \\p hGraph with \\p"]
    #[doc = " numDependencies dependencies specified via \\p dependencies and arguments specified"]
    #[doc = " in \\p nodeParams. It is possible for \\p numDependencies to be 0, in which case the"]
    #[doc = " node will be placed at the root of the graph. \\p dependencies may not have any"]
    #[doc = " duplicate entries. A handle to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " Performs a signal operation on a set of externally allocated semaphore objects"]
    #[doc = " when the node is launched.  The operation(s) will occur after all of the node's"]
    #[doc = " dependencies have completed."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param nodeParams      - Parameters for the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphExternalSemaphoresSignalNodeGetParams,"]
    #[doc = " ::cuGraphExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuImportExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    pub fn cuGraphAddExternalSemaphoresSignalNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns an external semaphore signal node's parameters"]
    #[doc = ""]
    #[doc = " Returns the parameters of an external semaphore signal node \\p hNode in \\p params_out."]
    #[doc = " The \\p extSemArray and \\p paramsArray returned in \\p params_out,"]
    #[doc = " are owned by the node.  This memory remains valid until the node is destroyed or its"]
    #[doc = " parameters are modified, and should not be modified"]
    #[doc = " directly. Use ::cuGraphExternalSemaphoresSignalNodeSetParams to update the"]
    #[doc = " parameters of this node."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to get the parameters for"]
    #[doc = " \\param params_out - Pointer to return the parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cuGraphAddExternalSemaphoresSignalNode,"]
    #[doc = " ::cuGraphExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresSignalNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an external semaphore signal node's parameters"]
    #[doc = ""]
    #[doc = " Sets the parameters of an external semaphore signal node \\p hNode to \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to set the parameters for"]
    #[doc = " \\param nodeParams - Parameters to copy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddExternalSemaphoresSignalNode,"]
    #[doc = " ::cuGraphExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresSignalNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an external semaphore wait node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new external semaphore wait node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies and arguments specified in \\p nodeParams."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries. A handle"]
    #[doc = " to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " Performs a wait operation on a set of externally allocated semaphore objects"]
    #[doc = " when the node is launched.  The node's dependencies will not be launched until"]
    #[doc = " the wait operation has completed."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param nodeParams      - Parameters for the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphExternalSemaphoresWaitNodeGetParams,"]
    #[doc = " ::cuGraphExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphAddExternalSemaphoresSignalNode,"]
    #[doc = " ::cuImportExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    pub fn cuGraphAddExternalSemaphoresWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns an external semaphore wait node's parameters"]
    #[doc = ""]
    #[doc = " Returns the parameters of an external semaphore wait node \\p hNode in \\p params_out."]
    #[doc = " The \\p extSemArray and \\p paramsArray returned in \\p params_out,"]
    #[doc = " are owned by the node.  This memory remains valid until the node is destroyed or its"]
    #[doc = " parameters are modified, and should not be modified"]
    #[doc = " directly. Use ::cuGraphExternalSemaphoresSignalNodeSetParams to update the"]
    #[doc = " parameters of this node."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to get the parameters for"]
    #[doc = " \\param params_out - Pointer to return the parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuLaunchKernel,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuGraphExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresWaitNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an external semaphore wait node's parameters"]
    #[doc = ""]
    #[doc = " Sets the parameters of an external semaphore wait node \\p hNode to \\p nodeParams."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to set the parameters for"]
    #[doc = " \\param nodeParams - Parameters to copy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuGraphExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresWaitNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an allocation node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new allocation node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies and arguments specified in \\p nodeParams."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries. A handle"]
    #[doc = " to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param nodeParams      - Parameters for the node"]
    #[doc = ""]
    #[doc = " When ::cuGraphAddMemAllocNode creates an allocation node, it returns the address of the allocation in"]
    #[doc = " \\param nodeParams.dptr.  The allocation's address remains fixed across instantiations and launches."]
    #[doc = ""]
    #[doc = " If the allocation is freed in the same graph, by creating a free node using ::cuGraphAddMemFreeNode,"]
    #[doc = " the allocation can be accessed by nodes ordered after the allocation node but before the free node."]
    #[doc = " These allocations cannot be freed outside the owning graph, and they can only be freed once in the"]
    #[doc = " owning graph."]
    #[doc = ""]
    #[doc = " If the allocation is not freed in the same graph, then it can be accessed not only by nodes in the"]
    #[doc = " graph which are ordered after the allocation node, but also by stream operations ordered after the"]
    #[doc = " graph's execution but before the allocation is freed."]
    #[doc = ""]
    #[doc = " Allocations which are not freed in the same graph can be freed by:"]
    #[doc = " - passing the allocation to ::cuMemFreeAsync or ::cuMemFree;"]
    #[doc = " - launching a graph with a free node for that allocation; or"]
    #[doc = " - specifying ::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH during instantiation, which makes"]
    #[doc = " each launch behave as though it called ::cuMemFreeAsync for every unfreed allocation."]
    #[doc = ""]
    #[doc = " It is not possible to free an allocation in both the owning graph and another graph.  If the allocation"]
    #[doc = " is freed in the same graph, a free node cannot be added to another graph.  If the allocation is freed"]
    #[doc = " in another graph, a free node can no longer be added to the owning graph."]
    #[doc = ""]
    #[doc = " The following restrictions apply to graphs which contain allocation and/or memory free nodes:"]
    #[doc = " - Nodes and edges of the graph cannot be deleted."]
    #[doc = " - The graph cannot be used in a child node."]
    #[doc = " - Only one instantiation of the graph may exist at any point in time."]
    #[doc = " - The graph cannot be cloned."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemFreeNode,"]
    #[doc = " ::cuGraphMemAllocNodeGetParams,"]
    #[doc = " ::cuDeviceGraphMemTrim,"]
    #[doc = " ::cuDeviceGetGraphMemAttribute,"]
    #[doc = " ::cuDeviceSetGraphMemAttribute,"]
    #[doc = " ::cuMemAllocAsync,"]
    #[doc = " ::cuMemFreeAsync,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuGraphAddExternalSemaphoresSignalNode,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddMemAllocNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memory alloc node's parameters"]
    #[doc = ""]
    #[doc = " Returns the parameters of a memory alloc node \\p hNode in \\p params_out."]
    #[doc = " The \\p poolProps and \\p accessDescs returned in \\p params_out, are owned by the"]
    #[doc = " node.  This memory remains valid until the node is destroyed.  The returned"]
    #[doc = " parameters must not be modified."]
    #[doc = ""]
    #[doc = " \\param hNode      - Node to get the parameters for"]
    #[doc = " \\param params_out - Pointer to return the parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemAllocNode,"]
    #[doc = " ::cuGraphMemFreeNodeGetParams"]
    pub fn cuGraphMemAllocNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memory free node and adds it to a graph"]
    #[doc = ""]
    #[doc = " Creates a new memory free node and adds it to \\p hGraph with \\p numDependencies"]
    #[doc = " dependencies specified via \\p dependencies and arguments specified in \\p nodeParams."]
    #[doc = " It is possible for \\p numDependencies to be 0, in which case the node will be placed"]
    #[doc = " at the root of the graph. \\p dependencies may not have any duplicate entries. A handle"]
    #[doc = " to the new node will be returned in \\p phGraphNode."]
    #[doc = ""]
    #[doc = " \\param phGraphNode     - Returns newly created node"]
    #[doc = " \\param hGraph          - Graph to which to add the node"]
    #[doc = " \\param dependencies    - Dependencies of the node"]
    #[doc = " \\param numDependencies - Number of dependencies"]
    #[doc = " \\param dptr            - Address of memory to free"]
    #[doc = ""]
    #[doc = " ::cuGraphAddMemFreeNode will return ::CUDA_ERROR_INVALID_VALUE if the user attempts to free:"]
    #[doc = " - an allocation twice in the same graph."]
    #[doc = " - an address that was not returned by an allocation node."]
    #[doc = " - an invalid address."]
    #[doc = ""]
    #[doc = " The following restrictions apply to graphs which contain allocation and/or memory free nodes:"]
    #[doc = " - Nodes and edges of the graph cannot be deleted."]
    #[doc = " - The graph cannot be used in a child node."]
    #[doc = " - Only one instantiation of the graph may exist at any point in time."]
    #[doc = " - The graph cannot be cloned."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemAllocNode,"]
    #[doc = " ::cuGraphMemFreeNodeGetParams,"]
    #[doc = " ::cuDeviceGraphMemTrim,"]
    #[doc = " ::cuDeviceGetGraphMemAttribute,"]
    #[doc = " ::cuDeviceSetGraphMemAttribute,"]
    #[doc = " ::cuMemAllocAsync,"]
    #[doc = " ::cuMemFreeAsync,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphDestroyNode,"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuGraphAddExternalSemaphoresSignalNode,"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddMemFreeNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memory free node's parameters"]
    #[doc = ""]
    #[doc = " Returns the address of a memory free node \\p hNode in \\p dptr_out."]
    #[doc = ""]
    #[doc = " \\param hNode    - Node to get the parameters for"]
    #[doc = " \\param dptr_out - Pointer to return the device address"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemFreeNode,"]
    #[doc = " ::cuGraphMemAllocNodeGetParams"]
    pub fn cuGraphMemFreeNodeGetParams(hNode: CUgraphNode, dptr_out: *mut CUdeviceptr) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Free unused memory that was cached on the specified device for use with graphs back to the OS."]
    #[doc = ""]
    #[doc = " Blocks which are not in use by a graph that is either currently executing or scheduled to execute are"]
    #[doc = " freed back to the operating system."]
    #[doc = ""]
    #[doc = " \\param device - The device for which cached memory should be freed."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemAllocNode,"]
    #[doc = " ::cuGraphAddMemFreeNode"]
    pub fn cuDeviceGraphMemTrim(device: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query asynchronous allocation attributes related to graphs"]
    #[doc = ""]
    #[doc = " Valid attributes are:"]
    #[doc = ""]
    #[doc = " - ::CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT: Amount of memory, in bytes, currently associated with graphs"]
    #[doc = " - ::CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: High watermark of memory, in bytes, associated with graphs since the"]
    #[doc = "   last time it was reset.  High watermark can only be reset to zero."]
    #[doc = " - ::CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT: Amount of memory, in bytes, currently allocated for use by"]
    #[doc = "   the CUDA graphs asynchronous allocator."]
    #[doc = " - ::CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: High watermark of memory, in bytes, currently allocated for use by"]
    #[doc = "   the CUDA graphs asynchronous allocator."]
    #[doc = ""]
    #[doc = " \\param device - Specifies the scope of the query"]
    #[doc = " \\param attr - attribute to get"]
    #[doc = " \\param value - retrieved value"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemAllocNode,"]
    #[doc = " ::cuGraphAddMemFreeNode"]
    pub fn cuDeviceGetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set asynchronous allocation attributes related to graphs"]
    #[doc = ""]
    #[doc = " Valid attributes are:"]
    #[doc = ""]
    #[doc = " - ::CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: High watermark of memory, in bytes, associated with graphs since the"]
    #[doc = "   last time it was reset.  High watermark can only be reset to zero."]
    #[doc = " - ::CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: High watermark of memory, in bytes, currently allocated for use by"]
    #[doc = "   the CUDA graphs asynchronous allocator."]
    #[doc = ""]
    #[doc = " \\param device - Specifies the scope of the query"]
    #[doc = " \\param attr - attribute to get"]
    #[doc = " \\param value - pointer to value to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemAllocNode,"]
    #[doc = " ::cuGraphAddMemFreeNode"]
    pub fn cuDeviceSetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Clones a graph"]
    #[doc = ""]
    #[doc = " This function creates a copy of \\p originalGraph and returns it in \\p phGraphClone."]
    #[doc = " All parameters are copied into the cloned graph. The original graph may be modified"]
    #[doc = " after this call without affecting the clone."]
    #[doc = ""]
    #[doc = " Child graph nodes in the original graph are recursively copied into the clone."]
    #[doc = ""]
    #[doc = " \\param phGraphClone  - Returns newly created cloned graph"]
    #[doc = " \\param originalGraph - Graph to clone"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphNodeFindInClone"]
    pub fn cuGraphClone(phGraphClone: *mut CUgraph, originalGraph: CUgraph) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Finds a cloned version of a node"]
    #[doc = ""]
    #[doc = " This function returns the node in \\p hClonedGraph corresponding to \\p hOriginalNode"]
    #[doc = " in the original graph."]
    #[doc = ""]
    #[doc = " \\p hClonedGraph must have been cloned from \\p hOriginalGraph via ::cuGraphClone."]
    #[doc = " \\p hOriginalNode must have been in \\p hOriginalGraph at the time of the call to"]
    #[doc = " ::cuGraphClone, and the corresponding cloned node in \\p hClonedGraph must not have"]
    #[doc = " been removed. The cloned node is then returned via \\p phClonedNode."]
    #[doc = ""]
    #[doc = " \\param phNode  - Returns handle to the cloned node"]
    #[doc = " \\param hOriginalNode - Handle to the original node"]
    #[doc = " \\param hClonedGraph - Cloned graph to query"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphClone"]
    pub fn cuGraphNodeFindInClone(
        phNode: *mut CUgraphNode,
        hOriginalNode: CUgraphNode,
        hClonedGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a node's type"]
    #[doc = ""]
    #[doc = " Returns the node type of \\p hNode in \\p type."]
    #[doc = ""]
    #[doc = " \\param hNode - Node to query"]
    #[doc = " \\param type  - Pointer to return the node type"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphGetNodes,"]
    #[doc = " ::cuGraphGetRootNodes,"]
    #[doc = " ::cuGraphChildGraphNodeGetGraph,"]
    #[doc = " ::cuGraphKernelNodeGetParams,"]
    #[doc = " ::cuGraphKernelNodeSetParams,"]
    #[doc = " ::cuGraphHostNodeGetParams,"]
    #[doc = " ::cuGraphHostNodeSetParams,"]
    #[doc = " ::cuGraphMemcpyNodeGetParams,"]
    #[doc = " ::cuGraphMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphMemsetNodeGetParams,"]
    #[doc = " ::cuGraphMemsetNodeSetParams"]
    pub fn cuGraphNodeGetType(hNode: CUgraphNode, type_: *mut CUgraphNodeType) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a graph's nodes"]
    #[doc = ""]
    #[doc = " Returns a list of \\p hGraph's nodes. \\p nodes may be NULL, in which case this"]
    #[doc = " function will return the number of nodes in \\p numNodes. Otherwise,"]
    #[doc = " \\p numNodes entries will be filled in. If \\p numNodes is higher than the actual"]
    #[doc = " number of nodes, the remaining entries in \\p nodes will be set to NULL, and the"]
    #[doc = " number of nodes actually obtained will be returned in \\p numNodes."]
    #[doc = ""]
    #[doc = " \\param hGraph   - Graph to query"]
    #[doc = " \\param nodes    - Pointer to return the nodes"]
    #[doc = " \\param numNodes - See description"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphGetRootNodes,"]
    #[doc = " ::cuGraphGetEdges,"]
    #[doc = " ::cuGraphNodeGetType,"]
    #[doc = " ::cuGraphNodeGetDependencies,"]
    #[doc = " ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphGetNodes(
        hGraph: CUgraph,
        nodes: *mut CUgraphNode,
        numNodes: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a graph's root nodes"]
    #[doc = ""]
    #[doc = " Returns a list of \\p hGraph's root nodes. \\p rootNodes may be NULL, in which case this"]
    #[doc = " function will return the number of root nodes in \\p numRootNodes. Otherwise,"]
    #[doc = " \\p numRootNodes entries will be filled in. If \\p numRootNodes is higher than the actual"]
    #[doc = " number of root nodes, the remaining entries in \\p rootNodes will be set to NULL, and the"]
    #[doc = " number of nodes actually obtained will be returned in \\p numRootNodes."]
    #[doc = ""]
    #[doc = " \\param hGraph       - Graph to query"]
    #[doc = " \\param rootNodes    - Pointer to return the root nodes"]
    #[doc = " \\param numRootNodes - See description"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphGetNodes,"]
    #[doc = " ::cuGraphGetEdges,"]
    #[doc = " ::cuGraphNodeGetType,"]
    #[doc = " ::cuGraphNodeGetDependencies,"]
    #[doc = " ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphGetRootNodes(
        hGraph: CUgraph,
        rootNodes: *mut CUgraphNode,
        numRootNodes: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a graph's dependency edges"]
    #[doc = ""]
    #[doc = " Returns a list of \\p hGraph's dependency edges. Edges are returned via corresponding"]
    #[doc = " indices in \\p from and \\p to; that is, the node in \\p to[i] has a dependency on the"]
    #[doc = " node in \\p from[i]. \\p from and \\p to may both be NULL, in which"]
    #[doc = " case this function only returns the number of edges in \\p numEdges. Otherwise,"]
    #[doc = " \\p numEdges entries will be filled in. If \\p numEdges is higher than the actual"]
    #[doc = " number of edges, the remaining entries in \\p from and \\p to will be set to NULL, and"]
    #[doc = " the number of edges actually returned will be written to \\p numEdges."]
    #[doc = ""]
    #[doc = " \\param hGraph   - Graph to get the edges from"]
    #[doc = " \\param from     - Location to return edge endpoints"]
    #[doc = " \\param to       - Location to return edge endpoints"]
    #[doc = " \\param numEdges - See description"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphGetNodes,"]
    #[doc = " ::cuGraphGetRootNodes,"]
    #[doc = " ::cuGraphAddDependencies,"]
    #[doc = " ::cuGraphRemoveDependencies,"]
    #[doc = " ::cuGraphNodeGetDependencies,"]
    #[doc = " ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphGetEdges(
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        numEdges: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a node's dependencies"]
    #[doc = ""]
    #[doc = " Returns a list of \\p node's dependencies. \\p dependencies may be NULL, in which case this"]
    #[doc = " function will return the number of dependencies in \\p numDependencies. Otherwise,"]
    #[doc = " \\p numDependencies entries will be filled in. If \\p numDependencies is higher than the actual"]
    #[doc = " number of dependencies, the remaining entries in \\p dependencies will be set to NULL, and the"]
    #[doc = " number of nodes actually obtained will be returned in \\p numDependencies."]
    #[doc = ""]
    #[doc = " \\param hNode           - Node to query"]
    #[doc = " \\param dependencies    - Pointer to return the dependencies"]
    #[doc = " \\param numDependencies - See description"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphNodeGetDependentNodes,"]
    #[doc = " ::cuGraphGetNodes,"]
    #[doc = " ::cuGraphGetRootNodes,"]
    #[doc = " ::cuGraphGetEdges,"]
    #[doc = " ::cuGraphAddDependencies,"]
    #[doc = " ::cuGraphRemoveDependencies"]
    pub fn cuGraphNodeGetDependencies(
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        numDependencies: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a node's dependent nodes"]
    #[doc = ""]
    #[doc = " Returns a list of \\p node's dependent nodes. \\p dependentNodes may be NULL, in which"]
    #[doc = " case this function will return the number of dependent nodes in \\p numDependentNodes."]
    #[doc = " Otherwise, \\p numDependentNodes entries will be filled in. If \\p numDependentNodes is"]
    #[doc = " higher than the actual number of dependent nodes, the remaining entries in"]
    #[doc = " \\p dependentNodes will be set to NULL, and the number of nodes actually obtained will"]
    #[doc = " be returned in \\p numDependentNodes."]
    #[doc = ""]
    #[doc = " \\param hNode             - Node to query"]
    #[doc = " \\param dependentNodes    - Pointer to return the dependent nodes"]
    #[doc = " \\param numDependentNodes - See description"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphNodeGetDependencies,"]
    #[doc = " ::cuGraphGetNodes,"]
    #[doc = " ::cuGraphGetRootNodes,"]
    #[doc = " ::cuGraphGetEdges,"]
    #[doc = " ::cuGraphAddDependencies,"]
    #[doc = " ::cuGraphRemoveDependencies"]
    pub fn cuGraphNodeGetDependentNodes(
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        numDependentNodes: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds dependency edges to a graph"]
    #[doc = ""]
    #[doc = " The number of dependencies to be added is defined by \\p numDependencies"]
    #[doc = " Elements in \\p from and \\p to at corresponding indices define a dependency."]
    #[doc = " Each node in \\p from and \\p to must belong to \\p hGraph."]
    #[doc = ""]
    #[doc = " If \\p numDependencies is 0, elements in \\p from and \\p to will be ignored."]
    #[doc = " Specifying an existing dependency will return an error."]
    #[doc = ""]
    #[doc = " \\param hGraph - Graph to which dependencies are added"]
    #[doc = " \\param from - Array of nodes that provide the dependencies"]
    #[doc = " \\param to - Array of dependent nodes"]
    #[doc = " \\param numDependencies - Number of dependencies to be added"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphRemoveDependencies,"]
    #[doc = " ::cuGraphGetEdges,"]
    #[doc = " ::cuGraphNodeGetDependencies,"]
    #[doc = " ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphAddDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Removes dependency edges from a graph"]
    #[doc = ""]
    #[doc = " The number of \\p dependencies to be removed is defined by \\p numDependencies."]
    #[doc = " Elements in \\p from and \\p to at corresponding indices define a dependency."]
    #[doc = " Each node in \\p from and \\p to must belong to \\p hGraph."]
    #[doc = ""]
    #[doc = " If \\p numDependencies is 0, elements in \\p from and \\p to will be ignored."]
    #[doc = " Specifying a non-existing dependency will return an error."]
    #[doc = ""]
    #[doc = " Dependencies cannot be removed from graphs which contain allocation or free nodes."]
    #[doc = " Any attempt to do so will return an error."]
    #[doc = ""]
    #[doc = " \\param hGraph - Graph from which to remove dependencies"]
    #[doc = " \\param from - Array of nodes that provide the dependencies"]
    #[doc = " \\param to - Array of dependent nodes"]
    #[doc = " \\param numDependencies - Number of dependencies to be removed"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddDependencies,"]
    #[doc = " ::cuGraphGetEdges,"]
    #[doc = " ::cuGraphNodeGetDependencies,"]
    #[doc = " ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphRemoveDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Remove a node from the graph"]
    #[doc = ""]
    #[doc = " Removes \\p hNode from its graph. This operation also severs any dependencies of other nodes"]
    #[doc = " on \\p hNode and vice versa."]
    #[doc = ""]
    #[doc = " Nodes which belong to a graph which contains allocation or free nodes cannot be destroyed."]
    #[doc = " Any attempt to do so will return an error."]
    #[doc = ""]
    #[doc = " \\param hNode  - Node to remove"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphAddEmptyNode,"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphAddMemsetNode"]
    pub fn cuGraphDestroyNode(hNode: CUgraphNode) -> CUresult;
}
extern "C" {
    pub fn cuGraphInstantiate_v2(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        phErrorNode: *mut CUgraphNode,
        logBuffer: *mut ::std::os::raw::c_char,
        bufferSize: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an executable graph from a graph"]
    #[doc = ""]
    #[doc = " Instantiates \\p hGraph as an executable graph. The graph is validated for any"]
    #[doc = " structural constraints or intra-node constraints which were not previously"]
    #[doc = " validated. If instantiation is successful, a handle to the instantiated graph"]
    #[doc = " is returned in \\p phGraphExec."]
    #[doc = ""]
    #[doc = " The \\p flags parameter controls the behavior of instantiation and subsequent"]
    #[doc = " graph launches.  Valid flags are:"]
    #[doc = ""]
    #[doc = " - ::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH, which configures a"]
    #[doc = " graph containing memory allocation nodes to automatically free any"]
    #[doc = " unfreed memory allocations before the graph is relaunched."]
    #[doc = ""]
    #[doc = " If \\p hGraph contains any allocation or free nodes, there can be at most one"]
    #[doc = " executable graph in existence for that graph at a time."]
    #[doc = ""]
    #[doc = " An attempt to instantiate a second executable graph before destroying the first"]
    #[doc = " with ::cuGraphExecDestroy will result in an error."]
    #[doc = ""]
    #[doc = " \\param phGraphExec - Returns instantiated graph"]
    #[doc = " \\param hGraph      - Graph to instantiate"]
    #[doc = " \\param flags       - Flags to control instantiation.  See ::CUgraphInstantiate_flags."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphInstantiate,"]
    #[doc = " ::cuGraphCreate,"]
    #[doc = " ::cuGraphUpload,"]
    #[doc = " ::cuGraphLaunch,"]
    #[doc = " ::cuGraphExecDestroy"]
    pub fn cuGraphInstantiateWithFlags(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a kernel node in the given graphExec"]
    #[doc = ""]
    #[doc = " Sets the parameters of a kernel node in an executable graph \\p hGraphExec."]
    #[doc = " The node is identified by the corresponding node \\p hNode in the"]
    #[doc = " non-executable graph, from which the executable graph was instantiated."]
    #[doc = ""]
    #[doc = " \\p hNode must not have been removed from the original graph. The \\p func field"]
    #[doc = " of \\p nodeParams cannot be modified and must match the original value."]
    #[doc = " All other values can be modified."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec. Already"]
    #[doc = " enqueued or running launches of \\p hGraphExec are not affected by this call."]
    #[doc = " \\p hNode is also not modified by this call."]
    #[doc = ""]
    #[doc = " \\param hGraphExec  - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode       - kernel node from the graph from which graphExec was instantiated"]
    #[doc = " \\param nodeParams  - Updated Parameters to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddKernelNode,"]
    #[doc = " ::cuGraphKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecKernelNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a memcpy node in the given graphExec."]
    #[doc = ""]
    #[doc = " Updates the work represented by \\p hNode in \\p hGraphExec as though \\p hNode had"]
    #[doc = " contained \\p copyParams at instantiation.  hNode must remain in the graph which was"]
    #[doc = " used to instantiate \\p hGraphExec.  Changed edges to and from hNode are ignored."]
    #[doc = ""]
    #[doc = " The source and destination memory in \\p copyParams must be allocated from the same"]
    #[doc = " contexts as the original source and destination memory.  Both the instantiation-time"]
    #[doc = " memory operands and the memory operands in \\p copyParams must be 1-dimensional."]
    #[doc = " Zero-length operations are not supported."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec.  Already enqueued"]
    #[doc = " or running launches of \\p hGraphExec are not affected by this call.  hNode is also"]
    #[doc = " not modified by this call."]
    #[doc = ""]
    #[doc = " Returns CUDA_ERROR_INVALID_VALUE if the memory operands' mappings changed or"]
    #[doc = " either the original or new memory operands are multidimensional."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode      - Memcpy node from the graph which was used to instantiate graphExec"]
    #[doc = " \\param copyParams - The updated parameters to set"]
    #[doc = " \\param ctx        - Context on which to run the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemcpyNode,"]
    #[doc = " ::cuGraphMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecMemcpyNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a memset node in the given graphExec."]
    #[doc = ""]
    #[doc = " Updates the work represented by \\p hNode in \\p hGraphExec as though \\p hNode had"]
    #[doc = " contained \\p memsetParams at instantiation.  hNode must remain in the graph which was"]
    #[doc = " used to instantiate \\p hGraphExec.  Changed edges to and from hNode are ignored."]
    #[doc = ""]
    #[doc = " The destination memory in \\p memsetParams must be allocated from the same"]
    #[doc = " contexts as the original destination memory.  Both the instantiation-time"]
    #[doc = " memory operand and the memory operand in \\p memsetParams must be 1-dimensional."]
    #[doc = " Zero-length operations are not supported."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec.  Already enqueued"]
    #[doc = " or running launches of \\p hGraphExec are not affected by this call.  hNode is also"]
    #[doc = " not modified by this call."]
    #[doc = ""]
    #[doc = " Returns CUDA_ERROR_INVALID_VALUE if the memory operand's mappings changed or"]
    #[doc = " either the original or new memory operand are multidimensional."]
    #[doc = ""]
    #[doc = " \\param hGraphExec   - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode        - Memset node from the graph which was used to instantiate graphExec"]
    #[doc = " \\param memsetParams - The updated parameters to set"]
    #[doc = " \\param ctx          - Context on which to run the node"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddMemsetNode,"]
    #[doc = " ::cuGraphMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecMemsetNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a host node in the given graphExec."]
    #[doc = ""]
    #[doc = " Updates the work represented by \\p hNode in \\p hGraphExec as though \\p hNode had"]
    #[doc = " contained \\p nodeParams at instantiation.  hNode must remain in the graph which was"]
    #[doc = " used to instantiate \\p hGraphExec.  Changed edges to and from hNode are ignored."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec.  Already enqueued"]
    #[doc = " or running launches of \\p hGraphExec are not affected by this call.  hNode is also"]
    #[doc = " not modified by this call."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode      - Host node from the graph which was used to instantiate graphExec"]
    #[doc = " \\param nodeParams - The updated parameters to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddHostNode,"]
    #[doc = " ::cuGraphHostNodeSetParams,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecHostNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Updates node parameters in the child graph node in the given graphExec."]
    #[doc = ""]
    #[doc = " Updates the work represented by \\p hNode in \\p hGraphExec as though the nodes contained"]
    #[doc = " in \\p hNode's graph had the parameters contained in \\p childGraph's nodes at instantiation."]
    #[doc = " \\p hNode must remain in the graph which was used to instantiate \\p hGraphExec."]
    #[doc = " Changed edges to and from \\p hNode are ignored."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec.  Already enqueued"]
    #[doc = " or running launches of \\p hGraphExec are not affected by this call.  \\p hNode is also"]
    #[doc = " not modified by this call."]
    #[doc = ""]
    #[doc = " The topology of \\p childGraph, as well as the node insertion order,  must match that"]
    #[doc = " of the graph contained in \\p hNode.  See ::cuGraphExecUpdate() for a list of restrictions"]
    #[doc = " on what can be updated in an instantiated graph.  The update is recursive, so child graph"]
    #[doc = " nodes contained within the top level child graph will also be updated."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode      - Host node from the graph which was used to instantiate graphExec"]
    #[doc = " \\param childGraph - The graph supplying the updated parameters"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddChildGraphNode,"]
    #[doc = " ::cuGraphChildGraphNodeGetGraph,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecChildGraphNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the event for an event record node in the given graphExec"]
    #[doc = ""]
    #[doc = " Sets the event of an event record node in an executable graph \\p hGraphExec."]
    #[doc = " The node is identified by the corresponding node \\p hNode in the"]
    #[doc = " non-executable graph, from which the executable graph was instantiated."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec. Already"]
    #[doc = " enqueued or running launches of \\p hGraphExec are not affected by this call."]
    #[doc = " \\p hNode is also not modified by this call."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode      - event record node from the graph from which graphExec was instantiated"]
    #[doc = " \\param event      - Updated event to use"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventRecordNode,"]
    #[doc = " ::cuGraphEventRecordNodeGetEvent,"]
    #[doc = " ::cuGraphEventWaitNodeSetEvent,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecEventRecordNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the event for an event wait node in the given graphExec"]
    #[doc = ""]
    #[doc = " Sets the event of an event wait node in an executable graph \\p hGraphExec."]
    #[doc = " The node is identified by the corresponding node \\p hNode in the"]
    #[doc = " non-executable graph, from which the executable graph was instantiated."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec. Already"]
    #[doc = " enqueued or running launches of \\p hGraphExec are not affected by this call."]
    #[doc = " \\p hNode is also not modified by this call."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode      - event wait node from the graph from which graphExec was instantiated"]
    #[doc = " \\param event      - Updated event to use"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddEventWaitNode,"]
    #[doc = " ::cuGraphEventWaitNodeGetEvent,"]
    #[doc = " ::cuGraphEventRecordNodeSetEvent,"]
    #[doc = " ::cuEventRecordWithFlags,"]
    #[doc = " ::cuStreamWaitEvent,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecEventWaitNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for an external semaphore signal node in the given graphExec"]
    #[doc = ""]
    #[doc = " Sets the parameters of an external semaphore signal node in an executable graph \\p hGraphExec."]
    #[doc = " The node is identified by the corresponding node \\p hNode in the"]
    #[doc = " non-executable graph, from which the executable graph was instantiated."]
    #[doc = ""]
    #[doc = " \\p hNode must not have been removed from the original graph."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec. Already"]
    #[doc = " enqueued or running launches of \\p hGraphExec are not affected by this call."]
    #[doc = " \\p hNode is also not modified by this call."]
    #[doc = ""]
    #[doc = " Changing \\p nodeParams->numExtSems is not supported."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode      - semaphore signal node from the graph from which graphExec was instantiated"]
    #[doc = " \\param nodeParams - Updated Parameters to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddExternalSemaphoresSignalNode,"]
    #[doc = " ::cuImportExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresWaitNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for an external semaphore wait node in the given graphExec"]
    #[doc = ""]
    #[doc = " Sets the parameters of an external semaphore wait node in an executable graph \\p hGraphExec."]
    #[doc = " The node is identified by the corresponding node \\p hNode in the"]
    #[doc = " non-executable graph, from which the executable graph was instantiated."]
    #[doc = ""]
    #[doc = " \\p hNode must not have been removed from the original graph."]
    #[doc = ""]
    #[doc = " The modifications only affect future launches of \\p hGraphExec. Already"]
    #[doc = " enqueued or running launches of \\p hGraphExec are not affected by this call."]
    #[doc = " \\p hNode is also not modified by this call."]
    #[doc = ""]
    #[doc = " Changing \\p nodeParams->numExtSems is not supported."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - The executable graph in which to set the specified node"]
    #[doc = " \\param hNode      - semaphore wait node from the graph from which graphExec was instantiated"]
    #[doc = " \\param nodeParams - Updated Parameters to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphAddExternalSemaphoresWaitNode,"]
    #[doc = " ::cuImportExternalSemaphore,"]
    #[doc = " ::cuSignalExternalSemaphoresAsync,"]
    #[doc = " ::cuWaitExternalSemaphoresAsync,"]
    #[doc = " ::cuGraphExecKernelNodeSetParams,"]
    #[doc = " ::cuGraphExecMemcpyNodeSetParams,"]
    #[doc = " ::cuGraphExecMemsetNodeSetParams,"]
    #[doc = " ::cuGraphExecHostNodeSetParams,"]
    #[doc = " ::cuGraphExecChildGraphNodeSetParams,"]
    #[doc = " ::cuGraphExecEventRecordNodeSetEvent,"]
    #[doc = " ::cuGraphExecEventWaitNodeSetEvent,"]
    #[doc = " ::cuGraphExecExternalSemaphoresSignalNodeSetParams,"]
    #[doc = " ::cuGraphExecUpdate,"]
    #[doc = " ::cuGraphInstantiate"]
    pub fn cuGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Uploads an executable graph in a stream"]
    #[doc = ""]
    #[doc = " Uploads \\p hGraphExec to the device in \\p hStream without executing it. Uploads of"]
    #[doc = " the same \\p hGraphExec will be serialized. Each upload is ordered behind both any"]
    #[doc = " previous work in \\p hStream and any previous launches of \\p hGraphExec."]
    #[doc = " Uses memory cached by \\p stream to back the allocations owned by \\p hGraphExec."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - Executable graph to upload"]
    #[doc = " \\param hStream    - Stream in which to upload the graph"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphInstantiate,"]
    #[doc = " ::cuGraphLaunch,"]
    #[doc = " ::cuGraphExecDestroy"]
    pub fn cuGraphUpload(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches an executable graph in a stream"]
    #[doc = ""]
    #[doc = " Executes \\p hGraphExec in \\p hStream. Only one instance of \\p hGraphExec may be executing"]
    #[doc = " at a time. Each launch is ordered behind both any previous work in \\p hStream"]
    #[doc = " and any previous launches of \\p hGraphExec. To execute a graph concurrently, it must be"]
    #[doc = " instantiated multiple times into multiple executable graphs."]
    #[doc = ""]
    #[doc = " If any allocations created by \\p hGraphExec remain unfreed (from a previous launch) and"]
    #[doc = " \\p hGraphExec was not instantiated with ::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH,"]
    #[doc = " the launch will fail with ::CUDA_ERROR_INVALID_VALUE."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - Executable graph to launch"]
    #[doc = " \\param hStream    - Stream in which to launch the graph"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphInstantiate,"]
    #[doc = " ::cuGraphUpload,"]
    #[doc = " ::cuGraphExecDestroy"]
    pub fn cuGraphLaunch(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys an executable graph"]
    #[doc = ""]
    #[doc = " Destroys the executable graph specified by \\p hGraphExec, as well"]
    #[doc = " as all of its executable nodes. If the executable graph is"]
    #[doc = " in-flight, it will not be terminated, but rather freed"]
    #[doc = " asynchronously on completion."]
    #[doc = ""]
    #[doc = " \\param hGraphExec - Executable graph to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphInstantiate,"]
    #[doc = " ::cuGraphUpload,"]
    #[doc = " ::cuGraphLaunch"]
    pub fn cuGraphExecDestroy(hGraphExec: CUgraphExec) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a graph"]
    #[doc = ""]
    #[doc = " Destroys the graph specified by \\p hGraph, as well as all of its nodes."]
    #[doc = ""]
    #[doc = " \\param hGraph - Graph to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphCreate"]
    pub fn cuGraphDestroy(hGraph: CUgraph) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Check whether an executable graph can be updated with a graph and perform the update if possible"]
    #[doc = ""]
    #[doc = " Updates the node parameters in the instantiated graph specified by \\p hGraphExec with the"]
    #[doc = " node parameters in a topologically identical graph specified by \\p hGraph."]
    #[doc = ""]
    #[doc = " Limitations:"]
    #[doc = ""]
    #[doc = " - Kernel nodes:"]
    #[doc = "   - The owning context of the function cannot change."]
    #[doc = "   - A node whose function originally did not use CUDA dynamic parallelism cannot be updated"]
    #[doc = "     to a function which uses CDP"]
    #[doc = " - Memset and memcpy nodes:"]
    #[doc = "   - The CUDA device(s) to which the operand(s) was allocated/mapped cannot change."]
    #[doc = "   - The source/destination memory must be allocated from the same contexts as the original"]
    #[doc = "     source/destination memory."]
    #[doc = "   - Only 1D memsets can be changed."]
    #[doc = " - Additional memcpy node restrictions:"]
    #[doc = "   - Changing either the source or destination memory type(i.e. CU_MEMORYTYPE_DEVICE,"]
    #[doc = "     CU_MEMORYTYPE_ARRAY, etc.) is not supported."]
    #[doc = " - External semaphore wait nodes and record nodes:"]
    #[doc = "   - Changing the number of semaphores is not supported."]
    #[doc = ""]
    #[doc = " Note:  The API may add further restrictions in future releases.  The return code should always be checked."]
    #[doc = ""]
    #[doc = " cuGraphExecUpdate sets \\p updateResult_out to CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED under"]
    #[doc = " the following conditions:"]
    #[doc = ""]
    #[doc = " - The count of nodes directly in \\p hGraphExec and \\p hGraph differ, in which case \\p hErrorNode_out"]
    #[doc = "   is NULL."]
    #[doc = " - A node is deleted in \\p hGraph but not not its pair from \\p hGraphExec, in which case \\p hErrorNode_out"]
    #[doc = "   is NULL."]
    #[doc = " - A node is deleted in \\p hGraphExec but not its pair from \\p hGraph, in which case \\p hErrorNode_out is"]
    #[doc = "   the pairless node from \\p hGraph."]
    #[doc = " - The dependent nodes of a pair differ, in which case \\p hErrorNode_out is the node from \\p hGraph."]
    #[doc = ""]
    #[doc = " cuGraphExecUpdate sets \\p updateResult_out to:"]
    #[doc = " - CU_GRAPH_EXEC_UPDATE_ERROR if passed an invalid value."]
    #[doc = " - CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED if the graph topology changed"]
    #[doc = " - CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED if the type of a node changed, in which case"]
    #[doc = "   \\p hErrorNode_out is set to the node from \\p hGraph."]
    #[doc = " - CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE if the function changed in an unsupported"]
    #[doc = "   way(see note above), in which case \\p hErrorNode_out is set to the node from \\p hGraph"]
    #[doc = " - CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED if any parameters to a node changed in a way"]
    #[doc = "   that is not supported, in which case \\p hErrorNode_out is set to the node from \\p hGraph."]
    #[doc = " - CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED if something about a node is unsupported, like"]
    #[doc = "   the node's type or configuration, in which case \\p hErrorNode_out is set to the node from \\p hGraph"]
    #[doc = ""]
    #[doc = " If \\p updateResult_out isn't set in one of the situations described above, the update check passes"]
    #[doc = " and cuGraphExecUpdate updates \\p hGraphExec to match the contents of \\p hGraph.  If an error happens"]
    #[doc = " during the update, \\p updateResult_out will be set to CU_GRAPH_EXEC_UPDATE_ERROR; otherwise,"]
    #[doc = " \\p updateResult_out is set to CU_GRAPH_EXEC_UPDATE_SUCCESS."]
    #[doc = ""]
    #[doc = " cuGraphExecUpdate returns CUDA_SUCCESS when the updated was performed successfully.  It returns"]
    #[doc = " CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE if the graph update was not performed because it included"]
    #[doc = " changes which violated constraints specific to instantiated graph update."]
    #[doc = ""]
    #[doc = " \\param hGraphExec The instantiated graph to be updated"]
    #[doc = " \\param hGraph The graph containing the updated parameters"]
    #[doc = " \\param hErrorNode_out The node which caused the permissibility check to forbid the update, if any"]
    #[doc = " \\param updateResult_out Whether the graph update was permitted.  If was forbidden, the reason why"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE,"]
    #[doc = " \\note_graph_thread_safety"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphInstantiate,"]
    pub fn cuGraphExecUpdate(
        hGraphExec: CUgraphExec,
        hGraph: CUgraph,
        hErrorNode_out: *mut CUgraphNode,
        updateResult_out: *mut CUgraphExecUpdateResult,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies attributes from source node to destination node."]
    #[doc = ""]
    #[doc = " Copies attributes from source node \\p src to destination node \\p dst."]
    #[doc = " Both node must have the same context."]
    #[doc = ""]
    #[doc = " \\param[out] dst Destination node"]
    #[doc = " \\param[in] src Source node"]
    #[doc = " For list of attributes see ::CUkernelNodeAttrID"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUaccessPolicyWindow"]
    pub fn cuGraphKernelNodeCopyAttributes(dst: CUgraphNode, src: CUgraphNode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries node attribute."]
    #[doc = ""]
    #[doc = " Queries attribute \\p attr from node \\p hNode and stores it in corresponding"]
    #[doc = " member of \\p value_out."]
    #[doc = ""]
    #[doc = " \\param[in] hNode"]
    #[doc = " \\param[in] attr"]
    #[doc = " \\param[out] value_out"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUaccessPolicyWindow"]
    pub fn cuGraphKernelNodeGetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value_out: *mut CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets node attribute."]
    #[doc = ""]
    #[doc = " Sets attribute \\p attr on node \\p hNode from corresponding attribute of"]
    #[doc = " \\p value."]
    #[doc = ""]
    #[doc = " \\param[out] hNode"]
    #[doc = " \\param[in] attr"]
    #[doc = " \\param[out] value"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::CUaccessPolicyWindow"]
    pub fn cuGraphKernelNodeSetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value: *const CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Write a DOT file describing graph structure"]
    #[doc = ""]
    #[doc = " Using the provided \\p hGraph, write to \\p path a DOT formatted description of the graph."]
    #[doc = " By default this includes the graph topology, node types, node id, kernel names and memcpy direction."]
    #[doc = " \\p flags can be specified to write more detailed information about each node type such as"]
    #[doc = " parameter values, kernel attributes, node and function handles."]
    #[doc = ""]
    #[doc = " \\param hGraph - The graph to create a DOT file from"]
    #[doc = " \\param path   - The path to write the DOT file to"]
    #[doc = " \\param flags  - Flags from CUgraphDebugDot_flags for specifying which additional node information to write"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_OPERATING_SYSTEM"]
    pub fn cuGraphDebugDotPrint(
        hGraph: CUgraph,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a user object"]
    #[doc = ""]
    #[doc = " Create a user object with the specified destructor callback and initial reference count. The"]
    #[doc = " initial references are owned by the caller."]
    #[doc = ""]
    #[doc = " Destructor callbacks cannot make CUDA API calls and should avoid blocking behavior, as they"]
    #[doc = " are executed by a shared internal thread. Another thread may be signaled to perform such"]
    #[doc = " actions, if it does not block forward progress of tasks scheduled through CUDA."]
    #[doc = ""]
    #[doc = " See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects."]
    #[doc = ""]
    #[doc = " \\param object_out      - Location to return the user object handle"]
    #[doc = " \\param ptr             - The pointer to pass to the destroy function"]
    #[doc = " \\param destroy         - Callback to free the user object when it is no longer in use"]
    #[doc = " \\param initialRefcount - The initial refcount to create the object with, typically 1. The"]
    #[doc = "                          initial references are owned by the calling thread."]
    #[doc = " \\param flags           - Currently it is required to pass ::CU_USER_OBJECT_NO_DESTRUCTOR_SYNC,"]
    #[doc = "                          which is the only defined flag. This indicates that the destroy"]
    #[doc = "                          callback cannot be waited on by any CUDA API. Users requiring"]
    #[doc = "                          synchronization of the callback should signal its completion"]
    #[doc = "                          manually."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuUserObjectRetain,"]
    #[doc = " ::cuUserObjectRelease,"]
    #[doc = " ::cuGraphRetainUserObject,"]
    #[doc = " ::cuGraphReleaseUserObject,"]
    #[doc = " ::cuGraphCreate"]
    pub fn cuUserObjectCreate(
        object_out: *mut CUuserObject,
        ptr: *mut ::std::os::raw::c_void,
        destroy: CUhostFn,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retain a reference to a user object"]
    #[doc = ""]
    #[doc = " Retains new references to a user object. The new references are owned by the caller."]
    #[doc = ""]
    #[doc = " See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects."]
    #[doc = ""]
    #[doc = " \\param object - The object to retain"]
    #[doc = " \\param count  - The number of references to retain, typically 1. Must be nonzero"]
    #[doc = "                 and not larger than INT_MAX."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuUserObjectCreate,"]
    #[doc = " ::cuUserObjectRelease,"]
    #[doc = " ::cuGraphRetainUserObject,"]
    #[doc = " ::cuGraphReleaseUserObject,"]
    #[doc = " ::cuGraphCreate"]
    pub fn cuUserObjectRetain(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Release a reference to a user object"]
    #[doc = ""]
    #[doc = " Releases user object references owned by the caller. The object's destructor is invoked if"]
    #[doc = " the reference count reaches zero."]
    #[doc = ""]
    #[doc = " It is undefined behavior to release references not owned by the caller, or to use a user"]
    #[doc = " object handle after all references are released."]
    #[doc = ""]
    #[doc = " See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects."]
    #[doc = ""]
    #[doc = " \\param object - The object to release"]
    #[doc = " \\param count  - The number of references to release, typically 1. Must be nonzero"]
    #[doc = "                 and not larger than INT_MAX."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuUserObjectCreate,"]
    #[doc = " ::cuUserObjectRetain,"]
    #[doc = " ::cuGraphRetainUserObject,"]
    #[doc = " ::cuGraphReleaseUserObject,"]
    #[doc = " ::cuGraphCreate"]
    pub fn cuUserObjectRelease(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retain a reference to a user object from a graph"]
    #[doc = ""]
    #[doc = " Creates or moves user object references that will be owned by a CUDA graph."]
    #[doc = ""]
    #[doc = " See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects."]
    #[doc = ""]
    #[doc = " \\param graph  - The graph to associate the reference with"]
    #[doc = " \\param object - The user object to retain a reference for"]
    #[doc = " \\param count  - The number of references to add to the graph, typically 1. Must be"]
    #[doc = "                 nonzero and not larger than INT_MAX."]
    #[doc = " \\param flags  - The optional flag ::CU_GRAPH_USER_OBJECT_MOVE transfers references"]
    #[doc = "                 from the calling thread, rather than create new references. Pass 0"]
    #[doc = "                 to create new references."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuUserObjectCreate,"]
    #[doc = " ::cuUserObjectRetain,"]
    #[doc = " ::cuUserObjectRelease,"]
    #[doc = " ::cuGraphReleaseUserObject,"]
    #[doc = " ::cuGraphCreate"]
    pub fn cuGraphRetainUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Release a user object reference from a graph"]
    #[doc = ""]
    #[doc = " Releases user object references owned by a graph."]
    #[doc = ""]
    #[doc = " See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects."]
    #[doc = ""]
    #[doc = " \\param graph  - The graph that will release the reference"]
    #[doc = " \\param object - The user object to release a reference for"]
    #[doc = " \\param count  - The number of references to release, typically 1. Must be nonzero"]
    #[doc = "                 and not larger than INT_MAX."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuUserObjectCreate,"]
    #[doc = " ::cuUserObjectRetain,"]
    #[doc = " ::cuUserObjectRelease,"]
    #[doc = " ::cuGraphRetainUserObject,"]
    #[doc = " ::cuGraphCreate"]
    pub fn cuGraphReleaseUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns occupancy of a function"]
    #[doc = ""]
    #[doc = " Returns in \\p *numBlocks the number of the maximum active blocks per"]
    #[doc = " streaming multiprocessor."]
    #[doc = ""]
    #[doc = " \\param numBlocks       - Returned occupancy"]
    #[doc = " \\param func            - Kernel for which occupancy is calculated"]
    #[doc = " \\param blockSize       - Block size the kernel is intended to be launched with"]
    #[doc = " \\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cudaOccupancyMaxActiveBlocksPerMultiprocessor"]
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns occupancy of a function"]
    #[doc = ""]
    #[doc = " Returns in \\p *numBlocks the number of the maximum active blocks per"]
    #[doc = " streaming multiprocessor."]
    #[doc = ""]
    #[doc = " The \\p Flags parameter controls how special cases are handled. The"]
    #[doc = " valid flags are:"]
    #[doc = ""]
    #[doc = " - ::CU_OCCUPANCY_DEFAULT, which maintains the default behavior as"]
    #[doc = "   ::cuOccupancyMaxActiveBlocksPerMultiprocessor;"]
    #[doc = ""]
    #[doc = " - ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE, which suppresses the"]
    #[doc = "   default behavior on platform where global caching affects"]
    #[doc = "   occupancy. On such platforms, if caching is enabled, but"]
    #[doc = "   per-block SM resource usage would result in zero occupancy, the"]
    #[doc = "   occupancy calculator will calculate the occupancy as if caching"]
    #[doc = "   is disabled. Setting ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE makes"]
    #[doc = "   the occupancy calculator to return 0 in such cases. More information"]
    #[doc = "   can be found about this feature in the \"Unified L1/Texture Cache\""]
    #[doc = "   section of the Maxwell tuning guide."]
    #[doc = ""]
    #[doc = " \\param numBlocks       - Returned occupancy"]
    #[doc = " \\param func            - Kernel for which occupancy is calculated"]
    #[doc = " \\param blockSize       - Block size the kernel is intended to be launched with"]
    #[doc = " \\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes"]
    #[doc = " \\param flags           - Requested behavior for the occupancy calculator"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags"]
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Suggest a launch configuration with reasonable occupancy"]
    #[doc = ""]
    #[doc = " Returns in \\p *blockSize a reasonable block size that can achieve"]
    #[doc = " the maximum occupancy (or, the maximum number of active warps with"]
    #[doc = " the fewest blocks per multiprocessor), and in \\p *minGridSize the"]
    #[doc = " minimum grid size to achieve the maximum occupancy."]
    #[doc = ""]
    #[doc = " If \\p blockSizeLimit is 0, the configurator will use the maximum"]
    #[doc = " block size permitted by the device / function instead."]
    #[doc = ""]
    #[doc = " If per-block dynamic shared memory allocation is not needed, the"]
    #[doc = " user should leave both \\p blockSizeToDynamicSMemSize and \\p"]
    #[doc = " dynamicSMemSize as 0."]
    #[doc = ""]
    #[doc = " If per-block dynamic shared memory allocation is needed, then if"]
    #[doc = " the dynamic shared memory size is constant regardless of block"]
    #[doc = " size, the size should be passed through \\p dynamicSMemSize, and \\p"]
    #[doc = " blockSizeToDynamicSMemSize should be NULL."]
    #[doc = ""]
    #[doc = " Otherwise, if the per-block dynamic shared memory size varies with"]
    #[doc = " different block sizes, the user needs to provide a unary function"]
    #[doc = " through \\p blockSizeToDynamicSMemSize that computes the dynamic"]
    #[doc = " shared memory needed by \\p func for any given block size. \\p"]
    #[doc = " dynamicSMemSize is ignored. An example signature is:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "    // Take block size, returns dynamic shared memory needed"]
    #[doc = "    size_t blockToSmem(int blockSize);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " \\param minGridSize - Returned minimum grid size needed to achieve the maximum occupancy"]
    #[doc = " \\param blockSize   - Returned maximum block size that can achieve the maximum occupancy"]
    #[doc = " \\param func        - Kernel for which launch configuration is calculated"]
    #[doc = " \\param blockSizeToDynamicSMemSize - A function that calculates how much per-block dynamic shared memory \\p func uses based on the block size"]
    #[doc = " \\param dynamicSMemSize - Dynamic shared memory usage intended, in bytes"]
    #[doc = " \\param blockSizeLimit  - The maximum block size \\p func is designed to handle"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cudaOccupancyMaxPotentialBlockSize"]
    pub fn cuOccupancyMaxPotentialBlockSize(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: size_t,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Suggest a launch configuration with reasonable occupancy"]
    #[doc = ""]
    #[doc = " An extended version of ::cuOccupancyMaxPotentialBlockSize. In"]
    #[doc = " addition to arguments passed to ::cuOccupancyMaxPotentialBlockSize,"]
    #[doc = " ::cuOccupancyMaxPotentialBlockSizeWithFlags also takes a \\p Flags"]
    #[doc = " parameter."]
    #[doc = ""]
    #[doc = " The \\p Flags parameter controls how special cases are handled. The"]
    #[doc = " valid flags are:"]
    #[doc = ""]
    #[doc = " - ::CU_OCCUPANCY_DEFAULT, which maintains the default behavior as"]
    #[doc = "   ::cuOccupancyMaxPotentialBlockSize;"]
    #[doc = ""]
    #[doc = " - ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE, which suppresses the"]
    #[doc = "   default behavior on platform where global caching affects"]
    #[doc = "   occupancy. On such platforms, the launch configurations that"]
    #[doc = "   produces maximal occupancy might not support global"]
    #[doc = "   caching. Setting ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE"]
    #[doc = "   guarantees that the the produced launch configuration is global"]
    #[doc = "   caching compatible at a potential cost of occupancy. More information"]
    #[doc = "   can be found about this feature in the \"Unified L1/Texture Cache\""]
    #[doc = "   section of the Maxwell tuning guide."]
    #[doc = ""]
    #[doc = " \\param minGridSize - Returned minimum grid size needed to achieve the maximum occupancy"]
    #[doc = " \\param blockSize   - Returned maximum block size that can achieve the maximum occupancy"]
    #[doc = " \\param func        - Kernel for which launch configuration is calculated"]
    #[doc = " \\param blockSizeToDynamicSMemSize - A function that calculates how much per-block dynamic shared memory \\p func uses based on the block size"]
    #[doc = " \\param dynamicSMemSize - Dynamic shared memory usage intended, in bytes"]
    #[doc = " \\param blockSizeLimit  - The maximum block size \\p func is designed to handle"]
    #[doc = " \\param flags       - Options"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cudaOccupancyMaxPotentialBlockSizeWithFlags"]
    pub fn cuOccupancyMaxPotentialBlockSizeWithFlags(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: size_t,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns dynamic shared memory available per block when launching \\p numBlocks blocks on SM"]
    #[doc = ""]
    #[doc = " Returns in \\p *dynamicSmemSize the maximum size of dynamic shared memory to allow \\p numBlocks blocks per SM."]
    #[doc = ""]
    #[doc = " \\param dynamicSmemSize - Returned maximum dynamic shared memory"]
    #[doc = " \\param func            - Kernel function for which occupancy is calculated"]
    #[doc = " \\param numBlocks       - Number of blocks to fit on SM"]
    #[doc = " \\param blockSize       - Size of the blocks"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    pub fn cuOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut size_t,
        func: CUfunction,
        numBlocks: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Binds an array as a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Binds the CUDA array \\p hArray to the texture reference \\p hTexRef. Any"]
    #[doc = " previous address or CUDA array state associated with the texture reference"]
    #[doc = " is superseded by this function. \\p Flags must be set to"]
    #[doc = " ::CU_TRSA_OVERRIDE_FORMAT. Any CUDA array previously bound to \\p hTexRef is"]
    #[doc = " unbound."]
    #[doc = ""]
    #[doc = " \\param hTexRef - Texture reference to bind"]
    #[doc = " \\param hArray  - Array to bind"]
    #[doc = " \\param Flags   - Options (must be ::CU_TRSA_OVERRIDE_FORMAT)"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTextureToArray"]
    pub fn cuTexRefSetArray(
        hTexRef: CUtexref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Binds a mipmapped array to a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Binds the CUDA mipmapped array \\p hMipmappedArray to the texture reference \\p hTexRef."]
    #[doc = " Any previous address or CUDA array state associated with the texture reference"]
    #[doc = " is superseded by this function. \\p Flags must be set to ::CU_TRSA_OVERRIDE_FORMAT."]
    #[doc = " Any CUDA array previously bound to \\p hTexRef is unbound."]
    #[doc = ""]
    #[doc = " \\param hTexRef         - Texture reference to bind"]
    #[doc = " \\param hMipmappedArray - Mipmapped array to bind"]
    #[doc = " \\param Flags           - Options (must be ::CU_TRSA_OVERRIDE_FORMAT)"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetMipmappedArray(
        hTexRef: CUtexref,
        hMipmappedArray: CUmipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress_v2(
        ByteOffset: *mut size_t,
        hTexRef: CUtexref,
        dptr: CUdeviceptr,
        bytes: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress2D_v3(
        hTexRef: CUtexref,
        desc: *const CUDA_ARRAY_DESCRIPTOR,
        dptr: CUdeviceptr,
        Pitch: size_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the format for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the format of the data to be read by the texture reference"]
    #[doc = " \\p hTexRef. \\p fmt and \\p NumPackedComponents are exactly analogous to the"]
    #[doc = " ::Format and ::NumChannels members of the ::CUDA_ARRAY_DESCRIPTOR structure:"]
    #[doc = " They specify the format of each component and the number of components per"]
    #[doc = " array element."]
    #[doc = ""]
    #[doc = " \\param hTexRef             - Texture reference"]
    #[doc = " \\param fmt                 - Format to set"]
    #[doc = " \\param NumPackedComponents - Number of components per array element"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaCreateChannelDesc,"]
    #[doc = " ::cudaBindTexture,"]
    #[doc = " ::cudaBindTexture2D,"]
    #[doc = " ::cudaBindTextureToArray,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetFormat(
        hTexRef: CUtexref,
        fmt: CUarray_format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the addressing mode for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the addressing mode \\p am for the given dimension \\p dim of the"]
    #[doc = " texture reference \\p hTexRef. If \\p dim is zero, the addressing mode is"]
    #[doc = " applied to the first parameter of the functions used to fetch from the"]
    #[doc = " texture; if \\p dim is 1, the second, and so on. ::CUaddress_mode is defined"]
    #[doc = " as:"]
    #[doc = " \\code"]
    #[doc = "typedef enum CUaddress_mode_enum {"]
    #[doc = "CU_TR_ADDRESS_MODE_WRAP = 0,"]
    #[doc = "CU_TR_ADDRESS_MODE_CLAMP = 1,"]
    #[doc = "CU_TR_ADDRESS_MODE_MIRROR = 2,"]
    #[doc = "CU_TR_ADDRESS_MODE_BORDER = 3"]
    #[doc = "} CUaddress_mode;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " Note that this call has no effect if \\p hTexRef is bound to linear memory."]
    #[doc = " Also, if the flag, ::CU_TRSF_NORMALIZED_COORDINATES, is not set, the only"]
    #[doc = " supported address mode is ::CU_TR_ADDRESS_MODE_CLAMP."]
    #[doc = ""]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = " \\param dim     - Dimension"]
    #[doc = " \\param am      - Addressing mode to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTexture,"]
    #[doc = " ::cudaBindTexture2D,"]
    #[doc = " ::cudaBindTextureToArray,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetAddressMode(
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
        am: CUaddress_mode,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the filtering mode for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the filtering mode \\p fm to be used when reading memory through"]
    #[doc = " the texture reference \\p hTexRef. ::CUfilter_mode_enum is defined as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef enum CUfilter_mode_enum {"]
    #[doc = "CU_TR_FILTER_MODE_POINT = 0,"]
    #[doc = "CU_TR_FILTER_MODE_LINEAR = 1"]
    #[doc = "} CUfilter_mode;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " Note that this call has no effect if \\p hTexRef is bound to linear memory."]
    #[doc = ""]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = " \\param fm      - Filtering mode to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTextureToArray"]
    pub fn cuTexRefSetFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the mipmap filtering mode for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the mipmap filtering mode \\p fm to be used when reading memory through"]
    #[doc = " the texture reference \\p hTexRef. ::CUfilter_mode_enum is defined as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "typedef enum CUfilter_mode_enum {"]
    #[doc = "CU_TR_FILTER_MODE_POINT = 0,"]
    #[doc = "CU_TR_FILTER_MODE_LINEAR = 1"]
    #[doc = "} CUfilter_mode;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " Note that this call has no effect if \\p hTexRef is not bound to a mipmapped array."]
    #[doc = ""]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = " \\param fm      - Filtering mode to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetMipmapFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the mipmap level bias for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the mipmap level bias \\p bias to be added to the specified mipmap level when"]
    #[doc = " reading memory through the texture reference \\p hTexRef."]
    #[doc = ""]
    #[doc = " Note that this call has no effect if \\p hTexRef is not bound to a mipmapped array."]
    #[doc = ""]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = " \\param bias    - Mipmap level bias"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetMipmapLevelBias(hTexRef: CUtexref, bias: f32) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the mipmap min/max mipmap level clamps for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the min/max mipmap level clamps, \\p minMipmapLevelClamp and \\p maxMipmapLevelClamp"]
    #[doc = " respectively, to be used when reading memory through the texture reference"]
    #[doc = " \\p hTexRef."]
    #[doc = ""]
    #[doc = " Note that this call has no effect if \\p hTexRef is not bound to a mipmapped array."]
    #[doc = ""]
    #[doc = " \\param hTexRef        - Texture reference"]
    #[doc = " \\param minMipmapLevelClamp - Mipmap min level clamp"]
    #[doc = " \\param maxMipmapLevelClamp - Mipmap max level clamp"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetMipmapLevelClamp(
        hTexRef: CUtexref,
        minMipmapLevelClamp: f32,
        maxMipmapLevelClamp: f32,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the maximum anisotropy for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the maximum anisotropy \\p maxAniso to be used when reading memory through"]
    #[doc = " the texture reference \\p hTexRef."]
    #[doc = ""]
    #[doc = " Note that this call has no effect if \\p hTexRef is bound to linear memory."]
    #[doc = ""]
    #[doc = " \\param hTexRef  - Texture reference"]
    #[doc = " \\param maxAniso - Maximum anisotropy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTextureToArray,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetMaxAnisotropy(
        hTexRef: CUtexref,
        maxAniso: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the border color for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies the value of the RGBA color via the \\p pBorderColor to the texture reference"]
    #[doc = " \\p hTexRef. The color value supports only float type and holds color components in"]
    #[doc = " the following sequence:"]
    #[doc = " pBorderColor[0] holds 'R' component"]
    #[doc = " pBorderColor[1] holds 'G' component"]
    #[doc = " pBorderColor[2] holds 'B' component"]
    #[doc = " pBorderColor[3] holds 'A' component"]
    #[doc = ""]
    #[doc = " Note that the color values can be set only when the Address mode is set to"]
    #[doc = " CU_TR_ADDRESS_MODE_BORDER using ::cuTexRefSetAddressMode."]
    #[doc = " Applications using integer border color values have to \"reinterpret_cast\" their values to float."]
    #[doc = ""]
    #[doc = " \\param hTexRef       - Texture reference"]
    #[doc = " \\param pBorderColor  - RGBA color"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddressMode,"]
    #[doc = " ::cuTexRefGetAddressMode, ::cuTexRefGetBorderColor,"]
    #[doc = " ::cudaBindTexture,"]
    #[doc = " ::cudaBindTexture2D,"]
    #[doc = " ::cudaBindTextureToArray,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetBorderColor(hTexRef: CUtexref, pBorderColor: *mut f32) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the flags for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Specifies optional flags via \\p Flags to specify the behavior of data"]
    #[doc = " returned through the texture reference \\p hTexRef. The valid flags are:"]
    #[doc = ""]
    #[doc = " - ::CU_TRSF_READ_AS_INTEGER, which suppresses the default behavior of"]
    #[doc = "   having the texture promote integer data to floating point data in the"]
    #[doc = "   range [0, 1]. Note that texture with 32-bit integer format"]
    #[doc = "   would not be promoted, regardless of whether or not this"]
    #[doc = "   flag is specified;"]
    #[doc = " - ::CU_TRSF_NORMALIZED_COORDINATES, which suppresses the"]
    #[doc = "   default behavior of having the texture coordinates range"]
    #[doc = "   from [0, Dim) where Dim is the width or height of the CUDA"]
    #[doc = "   array. Instead, the texture coordinates [0, 1.0) reference"]
    #[doc = "   the entire breadth of the array dimension;"]
    #[doc = " - ::CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION, which disables any trilinear"]
    #[doc = "   filtering optimizations. Trilinear optimizations improve texture filtering"]
    #[doc = "   performance by allowing bilinear filtering on textures in scenarios where"]
    #[doc = "   it can closely approximate the expected results."]
    #[doc = ""]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = " \\param Flags   - Optional flags to set"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,"]
    #[doc = " ::cudaBindTexture,"]
    #[doc = " ::cudaBindTexture2D,"]
    #[doc = " ::cudaBindTextureToArray,"]
    #[doc = " ::cudaBindTextureToMipmappedArray"]
    pub fn cuTexRefSetFlags(hTexRef: CUtexref, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetAddress_v2(pdptr: *mut CUdeviceptr, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the array bound to a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p *phArray the CUDA array bound to the texture reference"]
    #[doc = " \\p hTexRef, or returns ::CUDA_ERROR_INVALID_VALUE if the texture reference"]
    #[doc = " is not bound to any CUDA array."]
    #[doc = ""]
    #[doc = " \\param phArray - Returned array"]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetArray(phArray: *mut CUarray, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the mipmapped array bound to a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p *phMipmappedArray the CUDA mipmapped array bound to the texture"]
    #[doc = " reference \\p hTexRef, or returns ::CUDA_ERROR_INVALID_VALUE if the texture reference"]
    #[doc = " is not bound to any CUDA mipmapped array."]
    #[doc = ""]
    #[doc = " \\param phMipmappedArray - Returned mipmapped array"]
    #[doc = " \\param hTexRef          - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmappedArray(
        phMipmappedArray: *mut CUmipmappedArray,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the addressing mode used by a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p *pam the addressing mode corresponding to the"]
    #[doc = " dimension \\p dim of the texture reference \\p hTexRef. Currently, the only"]
    #[doc = " valid value for \\p dim are 0 and 1."]
    #[doc = ""]
    #[doc = " \\param pam     - Returned addressing mode"]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = " \\param dim     - Dimension"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetAddressMode(
        pam: *mut CUaddress_mode,
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the filter-mode used by a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p *pfm the filtering mode of the texture reference"]
    #[doc = " \\p hTexRef."]
    #[doc = ""]
    #[doc = " \\param pfm     - Returned filtering mode"]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the format used by a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p *pFormat and \\p *pNumChannels the format and number"]
    #[doc = " of components of the CUDA array bound to the texture reference \\p hTexRef."]
    #[doc = " If \\p pFormat or \\p pNumChannels is NULL, it will be ignored."]
    #[doc = ""]
    #[doc = " \\param pFormat      - Returned format"]
    #[doc = " \\param pNumChannels - Returned number of components"]
    #[doc = " \\param hTexRef      - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags"]
    pub fn cuTexRefGetFormat(
        pFormat: *mut CUarray_format,
        pNumChannels: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the mipmap filtering mode for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns the mipmap filtering mode in \\p pfm that's used when reading memory through"]
    #[doc = " the texture reference \\p hTexRef."]
    #[doc = ""]
    #[doc = " \\param pfm     - Returned mipmap filtering mode"]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmapFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the mipmap level bias for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns the mipmap level bias in \\p pBias that's added to the specified mipmap"]
    #[doc = " level when reading memory through the texture reference \\p hTexRef."]
    #[doc = ""]
    #[doc = " \\param pbias   - Returned mipmap level bias"]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmapLevelBias(pbias: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the min/max mipmap level clamps for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns the min/max mipmap level clamps in \\p pminMipmapLevelClamp and \\p pmaxMipmapLevelClamp"]
    #[doc = " that's used when reading memory through the texture reference \\p hTexRef."]
    #[doc = ""]
    #[doc = " \\param pminMipmapLevelClamp - Returned mipmap min level clamp"]
    #[doc = " \\param pmaxMipmapLevelClamp - Returned mipmap max level clamp"]
    #[doc = " \\param hTexRef              - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the maximum anisotropy for a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns the maximum anisotropy in \\p pmaxAniso that's used when reading memory through"]
    #[doc = " the texture reference \\p hTexRef."]
    #[doc = ""]
    #[doc = " \\param pmaxAniso - Returned maximum anisotropy"]
    #[doc = " \\param hTexRef   - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMaxAnisotropy(
        pmaxAniso: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the border color used by a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p pBorderColor, values of the RGBA color used by"]
    #[doc = " the texture reference \\p hTexRef."]
    #[doc = " The color value is of type float and holds color components in"]
    #[doc = " the following sequence:"]
    #[doc = " pBorderColor[0] holds 'R' component"]
    #[doc = " pBorderColor[1] holds 'G' component"]
    #[doc = " pBorderColor[2] holds 'B' component"]
    #[doc = " pBorderColor[3] holds 'A' component"]
    #[doc = ""]
    #[doc = " \\param hTexRef  - Texture reference"]
    #[doc = " \\param pBorderColor   - Returned Type and Value of RGBA color"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddressMode,"]
    #[doc = " ::cuTexRefSetAddressMode, ::cuTexRefSetBorderColor"]
    pub fn cuTexRefGetBorderColor(pBorderColor: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the flags used by a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p *pFlags the flags of the texture reference \\p hTexRef."]
    #[doc = ""]
    #[doc = " \\param pFlags  - Returned flags"]
    #[doc = " \\param hTexRef - Texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefSetAddress,"]
    #[doc = " ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,"]
    #[doc = " ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,"]
    #[doc = " ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,"]
    #[doc = " ::cuTexRefGetFilterMode, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetFlags(pFlags: *mut ::std::os::raw::c_uint, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Creates a texture reference and returns its handle in \\p *pTexRef. Once"]
    #[doc = " created, the application must call ::cuTexRefSetArray() or"]
    #[doc = " ::cuTexRefSetAddress() to associate the reference with allocated memory."]
    #[doc = " Other texture reference functions are used to specify the format and"]
    #[doc = " interpretation (addressing, filtering, etc.) to be used when the memory is"]
    #[doc = " read through this texture reference."]
    #[doc = ""]
    #[doc = " \\param pTexRef - Returned texture reference"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefDestroy"]
    pub fn cuTexRefCreate(pTexRef: *mut CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a texture reference"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Destroys the texture reference specified by \\p hTexRef."]
    #[doc = ""]
    #[doc = " \\param hTexRef - Texture reference to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuTexRefCreate"]
    pub fn cuTexRefDestroy(hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the CUDA array for a surface reference."]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Sets the CUDA array \\p hArray to be read and written by the surface reference"]
    #[doc = " \\p hSurfRef.  Any previous CUDA array state associated with the surface"]
    #[doc = " reference is superseded by this function.  \\p Flags must be set to 0."]
    #[doc = " The ::CUDA_ARRAY3D_SURFACE_LDST flag must have been set for the CUDA array."]
    #[doc = " Any CUDA array previously bound to \\p hSurfRef is unbound."]
    #[doc = ""]
    #[doc = " \\param hSurfRef - Surface reference handle"]
    #[doc = " \\param hArray - CUDA array handle"]
    #[doc = " \\param Flags - set to 0"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuModuleGetSurfRef,"]
    #[doc = " ::cuSurfRefGetArray,"]
    #[doc = " ::cudaBindSurfaceToArray"]
    pub fn cuSurfRefSetArray(
        hSurfRef: CUsurfref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Passes back the CUDA array bound to a surface reference."]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = ""]
    #[doc = " Returns in \\p *phArray the CUDA array bound to the surface reference"]
    #[doc = " \\p hSurfRef, or returns ::CUDA_ERROR_INVALID_VALUE if the surface reference"]
    #[doc = " is not bound to any CUDA array."]
    #[doc = ""]
    #[doc = " \\param phArray - Surface reference handle"]
    #[doc = " \\param hSurfRef - Surface reference handle"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa ::cuModuleGetSurfRef, ::cuSurfRefSetArray"]
    pub fn cuSurfRefGetArray(phArray: *mut CUarray, hSurfRef: CUsurfref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a texture object"]
    #[doc = ""]
    #[doc = " Creates a texture object and returns it in \\p pTexObject. \\p pResDesc describes"]
    #[doc = " the data to texture from. \\p pTexDesc describes how the data should be sampled."]
    #[doc = " \\p pResViewDesc is an optional argument that specifies an alternate format for"]
    #[doc = " the data described by \\p pResDesc, and also describes the subresource region"]
    #[doc = " to restrict access to when texturing. \\p pResViewDesc can only be specified if"]
    #[doc = " the type of resource is a CUDA array or a CUDA mipmapped array."]
    #[doc = ""]
    #[doc = " Texture objects are only supported on devices of compute capability 3.0 or higher."]
    #[doc = " Additionally, a texture object is an opaque value, and, as such, should only be"]
    #[doc = " accessed through CUDA API calls."]
    #[doc = ""]
    #[doc = " The ::CUDA_RESOURCE_DESC structure is defined as:"]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_RESOURCE_DESC_st"]
    #[doc = "{"]
    #[doc = "CUresourcetype resType;"]
    #[doc = ""]
    #[doc = "union {"]
    #[doc = "struct {"]
    #[doc = "CUarray hArray;"]
    #[doc = "} array;"]
    #[doc = "struct {"]
    #[doc = "CUmipmappedArray hMipmappedArray;"]
    #[doc = "} mipmap;"]
    #[doc = "struct {"]
    #[doc = "CUdeviceptr devPtr;"]
    #[doc = "CUarray_format format;"]
    #[doc = "unsigned int numChannels;"]
    #[doc = "size_t sizeInBytes;"]
    #[doc = "} linear;"]
    #[doc = "struct {"]
    #[doc = "CUdeviceptr devPtr;"]
    #[doc = "CUarray_format format;"]
    #[doc = "unsigned int numChannels;"]
    #[doc = "size_t width;"]
    #[doc = "size_t height;"]
    #[doc = "size_t pitchInBytes;"]
    #[doc = "} pitch2D;"]
    #[doc = "} res;"]
    #[doc = ""]
    #[doc = "unsigned int flags;"]
    #[doc = "} CUDA_RESOURCE_DESC;"]
    #[doc = ""]
    #[doc = " \\endcode"]
    #[doc = " where:"]
    #[doc = " - ::CUDA_RESOURCE_DESC::resType specifies the type of resource to texture from."]
    #[doc = " CUresourceType is defined as:"]
    #[doc = " \\code"]
    #[doc = "typedef enum CUresourcetype_enum {"]
    #[doc = "CU_RESOURCE_TYPE_ARRAY           = 0x00,"]
    #[doc = "CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01,"]
    #[doc = "CU_RESOURCE_TYPE_LINEAR          = 0x02,"]
    #[doc = "CU_RESOURCE_TYPE_PITCH2D         = 0x03"]
    #[doc = "} CUresourcetype;"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = " If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_ARRAY, ::CUDA_RESOURCE_DESC::res::array::hArray"]
    #[doc = " must be set to a valid CUDA array handle."]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = " If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY, ::CUDA_RESOURCE_DESC::res::mipmap::hMipmappedArray"]
    #[doc = " must be set to a valid CUDA mipmapped array handle."]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = " If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_LINEAR, ::CUDA_RESOURCE_DESC::res::linear::devPtr"]
    #[doc = " must be set to a valid device pointer, that is aligned to ::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT."]
    #[doc = " ::CUDA_RESOURCE_DESC::res::linear::format and ::CUDA_RESOURCE_DESC::res::linear::numChannels"]
    #[doc = " describe the format of each component and the number of components per array element. ::CUDA_RESOURCE_DESC::res::linear::sizeInBytes"]
    #[doc = " specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH. The number of elements is computed as (sizeInBytes / (sizeof(format) * numChannels))."]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = " If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_PITCH2D, ::CUDA_RESOURCE_DESC::res::pitch2D::devPtr"]
    #[doc = " must be set to a valid device pointer, that is aligned to ::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT."]
    #[doc = " ::CUDA_RESOURCE_DESC::res::pitch2D::format and ::CUDA_RESOURCE_DESC::res::pitch2D::numChannels"]
    #[doc = " describe the format of each component and the number of components per array element. ::CUDA_RESOURCE_DESC::res::pitch2D::width"]
    #[doc = " and ::CUDA_RESOURCE_DESC::res::pitch2D::height specify the width and height of the array in elements, and cannot exceed"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH and ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT respectively."]
    #[doc = " ::CUDA_RESOURCE_DESC::res::pitch2D::pitchInBytes specifies the pitch between two rows in bytes and has to be aligned to"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT. Pitch cannot exceed ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH."]
    #[doc = ""]
    #[doc = " - ::flags must be set to zero."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " The ::CUDA_TEXTURE_DESC struct is defined as"]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_TEXTURE_DESC_st {"]
    #[doc = "CUaddress_mode addressMode[3];"]
    #[doc = "CUfilter_mode filterMode;"]
    #[doc = "unsigned int flags;"]
    #[doc = "unsigned int maxAnisotropy;"]
    #[doc = "CUfilter_mode mipmapFilterMode;"]
    #[doc = "float mipmapLevelBias;"]
    #[doc = "float minMipmapLevelClamp;"]
    #[doc = "float maxMipmapLevelClamp;"]
    #[doc = "} CUDA_TEXTURE_DESC;"]
    #[doc = " \\endcode"]
    #[doc = " where"]
    #[doc = " - ::CUDA_TEXTURE_DESC::addressMode specifies the addressing mode for each dimension of the texture data. ::CUaddress_mode is defined as:"]
    #[doc = "   \\code"]
    #[doc = "typedef enum CUaddress_mode_enum {"]
    #[doc = "CU_TR_ADDRESS_MODE_WRAP = 0,"]
    #[doc = "CU_TR_ADDRESS_MODE_CLAMP = 1,"]
    #[doc = "CU_TR_ADDRESS_MODE_MIRROR = 2,"]
    #[doc = "CU_TR_ADDRESS_MODE_BORDER = 3"]
    #[doc = "} CUaddress_mode;"]
    #[doc = "   \\endcode"]
    #[doc = "   This is ignored if ::CUDA_RESOURCE_DESC::resType is ::CU_RESOURCE_TYPE_LINEAR. Also, if the flag, ::CU_TRSF_NORMALIZED_COORDINATES"]
    #[doc = "   is not set, the only supported address mode is ::CU_TR_ADDRESS_MODE_CLAMP."]
    #[doc = ""]
    #[doc = " - ::CUDA_TEXTURE_DESC::filterMode specifies the filtering mode to be used when fetching from the texture. CUfilter_mode is defined as:"]
    #[doc = "   \\code"]
    #[doc = "typedef enum CUfilter_mode_enum {"]
    #[doc = "CU_TR_FILTER_MODE_POINT = 0,"]
    #[doc = "CU_TR_FILTER_MODE_LINEAR = 1"]
    #[doc = "} CUfilter_mode;"]
    #[doc = "   \\endcode"]
    #[doc = "   This is ignored if ::CUDA_RESOURCE_DESC::resType is ::CU_RESOURCE_TYPE_LINEAR."]
    #[doc = ""]
    #[doc = " - ::CUDA_TEXTURE_DESC::flags can be any combination of the following:"]
    #[doc = "   - ::CU_TRSF_READ_AS_INTEGER, which suppresses the default behavior of"]
    #[doc = "   having the texture promote integer data to floating point data in the"]
    #[doc = "   range [0, 1]. Note that texture with 32-bit integer format would not be"]
    #[doc = "   promoted, regardless of whether or not this flag is specified."]
    #[doc = "   - ::CU_TRSF_NORMALIZED_COORDINATES, which suppresses the default behavior"]
    #[doc = "   of having the texture coordinates range from [0, Dim) where Dim is the"]
    #[doc = "   width or height of the CUDA array. Instead, the texture coordinates"]
    #[doc = "   [0, 1.0) reference the entire breadth of the array dimension; Note that"]
    #[doc = "   for CUDA mipmapped arrays, this flag has to be set."]
    #[doc = "   - ::CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION, which disables any trilinear"]
    #[doc = "   filtering optimizations. Trilinear optimizations improve texture filtering"]
    #[doc = "   performance by allowing bilinear filtering on textures in scenarios where"]
    #[doc = "   it can closely approximate the expected results."]
    #[doc = ""]
    #[doc = " - ::CUDA_TEXTURE_DESC::maxAnisotropy specifies the maximum anisotropy ratio to be used when doing anisotropic filtering. This value will be"]
    #[doc = "   clamped to the range [1,16]."]
    #[doc = ""]
    #[doc = " - ::CUDA_TEXTURE_DESC::mipmapFilterMode specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels."]
    #[doc = ""]
    #[doc = " - ::CUDA_TEXTURE_DESC::mipmapLevelBias specifies the offset to be applied to the calculated mipmap level."]
    #[doc = ""]
    #[doc = " - ::CUDA_TEXTURE_DESC::minMipmapLevelClamp specifies the lower end of the mipmap level range to clamp access to."]
    #[doc = ""]
    #[doc = " - ::CUDA_TEXTURE_DESC::maxMipmapLevelClamp specifies the upper end of the mipmap level range to clamp access to."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " The ::CUDA_RESOURCE_VIEW_DESC struct is defined as"]
    #[doc = " \\code"]
    #[doc = "typedef struct CUDA_RESOURCE_VIEW_DESC_st"]
    #[doc = "{"]
    #[doc = "CUresourceViewFormat format;"]
    #[doc = "size_t width;"]
    #[doc = "size_t height;"]
    #[doc = "size_t depth;"]
    #[doc = "unsigned int firstMipmapLevel;"]
    #[doc = "unsigned int lastMipmapLevel;"]
    #[doc = "unsigned int firstLayer;"]
    #[doc = "unsigned int lastLayer;"]
    #[doc = "} CUDA_RESOURCE_VIEW_DESC;"]
    #[doc = " \\endcode"]
    #[doc = " where:"]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::format specifies how the data contained in the CUDA array or CUDA mipmapped array should"]
    #[doc = "   be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block"]
    #[doc = "   compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a base of format ::CU_AD_FORMAT_UNSIGNED_INT32."]
    #[doc = "   with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have"]
    #[doc = "   a format of ::CU_AD_FORMAT_UNSIGNED_INT32 with 2 channels. The other BC formats require the underlying resource to have the same base"]
    #[doc = "   format but with 4 channels."]
    #[doc = ""]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::width specifies the new width of the texture data. If the resource view format is a block"]
    #[doc = "   compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats,"]
    #[doc = "   this value has to be equal to that of the original resource."]
    #[doc = ""]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::height specifies the new height of the texture data. If the resource view format is a block"]
    #[doc = "   compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats,"]
    #[doc = "   this value has to be equal to that of the original resource."]
    #[doc = ""]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::depth specifies the new depth of the texture data. This value has to be equal to that of the"]
    #[doc = "   original resource."]
    #[doc = ""]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::firstMipmapLevel specifies the most detailed mipmap level. This will be the new mipmap level zero."]
    #[doc = "   For non-mipmapped resources, this value has to be zero.::CUDA_TEXTURE_DESC::minMipmapLevelClamp and ::CUDA_TEXTURE_DESC::maxMipmapLevelClamp"]
    #[doc = "   will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified,"]
    #[doc = "   then the actual minimum mipmap level clamp will be 3.2."]
    #[doc = ""]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::lastMipmapLevel specifies the least detailed mipmap level. For non-mipmapped resources, this value"]
    #[doc = "   has to be zero."]
    #[doc = ""]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::firstLayer specifies the first layer index for layered textures. This will be the new layer zero."]
    #[doc = "   For non-layered resources, this value has to be zero."]
    #[doc = ""]
    #[doc = " - ::CUDA_RESOURCE_VIEW_DESC::lastLayer specifies the last layer index for layered textures. For non-layered resources,"]
    #[doc = "   this value has to be zero."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param pTexObject   - Texture object to create"]
    #[doc = " \\param pResDesc     - Resource descriptor"]
    #[doc = " \\param pTexDesc     - Texture descriptor"]
    #[doc = " \\param pResViewDesc - Resource view descriptor"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuTexObjectDestroy,"]
    #[doc = " ::cudaCreateTextureObject"]
    pub fn cuTexObjectCreate(
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a texture object"]
    #[doc = ""]
    #[doc = " Destroys the texture object specified by \\p texObject."]
    #[doc = ""]
    #[doc = " \\param texObject - Texture object to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuTexObjectCreate,"]
    #[doc = " ::cudaDestroyTextureObject"]
    pub fn cuTexObjectDestroy(texObject: CUtexObject) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a texture object's resource descriptor"]
    #[doc = ""]
    #[doc = " Returns the resource descriptor for the texture object specified by \\p texObject."]
    #[doc = ""]
    #[doc = " \\param pResDesc  - Resource descriptor"]
    #[doc = " \\param texObject - Texture object"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuTexObjectCreate,"]
    #[doc = " ::cudaGetTextureObjectResourceDesc,"]
    pub fn cuTexObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a texture object's texture descriptor"]
    #[doc = ""]
    #[doc = " Returns the texture descriptor for the texture object specified by \\p texObject."]
    #[doc = ""]
    #[doc = " \\param pTexDesc  - Texture descriptor"]
    #[doc = " \\param texObject - Texture object"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuTexObjectCreate,"]
    #[doc = " ::cudaGetTextureObjectTextureDesc"]
    pub fn cuTexObjectGetTextureDesc(
        pTexDesc: *mut CUDA_TEXTURE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a texture object's resource view descriptor"]
    #[doc = ""]
    #[doc = " Returns the resource view descriptor for the texture object specified by \\p texObject."]
    #[doc = " If no resource view was set for \\p texObject, the ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = ""]
    #[doc = " \\param pResViewDesc - Resource view descriptor"]
    #[doc = " \\param texObject    - Texture object"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuTexObjectCreate,"]
    #[doc = " ::cudaGetTextureObjectResourceViewDesc"]
    pub fn cuTexObjectGetResourceViewDesc(
        pResViewDesc: *mut CUDA_RESOURCE_VIEW_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a surface object"]
    #[doc = ""]
    #[doc = " Creates a surface object and returns it in \\p pSurfObject. \\p pResDesc describes"]
    #[doc = " the data to perform surface load/stores on. ::CUDA_RESOURCE_DESC::resType must be"]
    #[doc = " ::CU_RESOURCE_TYPE_ARRAY and  ::CUDA_RESOURCE_DESC::res::array::hArray"]
    #[doc = " must be set to a valid CUDA array handle. ::CUDA_RESOURCE_DESC::flags must be set to zero."]
    #[doc = ""]
    #[doc = " Surface objects are only supported on devices of compute capability 3.0 or higher."]
    #[doc = " Additionally, a surface object is an opaque value, and, as such, should only be"]
    #[doc = " accessed through CUDA API calls."]
    #[doc = ""]
    #[doc = " \\param pSurfObject - Surface object to create"]
    #[doc = " \\param pResDesc    - Resource descriptor"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuSurfObjectDestroy,"]
    #[doc = " ::cudaCreateSurfaceObject"]
    pub fn cuSurfObjectCreate(
        pSurfObject: *mut CUsurfObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a surface object"]
    #[doc = ""]
    #[doc = " Destroys the surface object specified by \\p surfObject."]
    #[doc = ""]
    #[doc = " \\param surfObject - Surface object to destroy"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuSurfObjectCreate,"]
    #[doc = " ::cudaDestroySurfaceObject"]
    pub fn cuSurfObjectDestroy(surfObject: CUsurfObject) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a surface object's resource descriptor"]
    #[doc = ""]
    #[doc = " Returns the resource descriptor for the surface object specified by \\p surfObject."]
    #[doc = ""]
    #[doc = " \\param pResDesc   - Resource descriptor"]
    #[doc = " \\param surfObject - Surface object"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuSurfObjectCreate,"]
    #[doc = " ::cudaGetSurfaceObjectResourceDesc"]
    pub fn cuSurfObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        surfObject: CUsurfObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries if a device may directly access a peer device's memory."]
    #[doc = ""]
    #[doc = " Returns in \\p *canAccessPeer a value of 1 if contexts on \\p dev are capable of"]
    #[doc = " directly accessing memory from contexts on \\p peerDev and 0 otherwise."]
    #[doc = " If direct access of \\p peerDev from \\p dev is possible, then access may be"]
    #[doc = " enabled on two specific contexts by calling ::cuCtxEnablePeerAccess()."]
    #[doc = ""]
    #[doc = " \\param canAccessPeer - Returned access capability"]
    #[doc = " \\param dev           - Device from which allocations on \\p peerDev are to"]
    #[doc = "                        be directly accessed."]
    #[doc = " \\param peerDev       - Device on which the allocations to be directly accessed"]
    #[doc = "                        by \\p dev reside."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuCtxEnablePeerAccess,"]
    #[doc = " ::cuCtxDisablePeerAccess,"]
    #[doc = " ::cudaDeviceCanAccessPeer"]
    pub fn cuDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        dev: CUdevice,
        peerDev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Enables direct access to memory allocations in a peer context."]
    #[doc = ""]
    #[doc = " If both the current context and \\p peerContext are on devices which support unified"]
    #[doc = " addressing (as may be queried using ::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING) and same"]
    #[doc = " major compute capability, then on success all allocations from \\p peerContext will"]
    #[doc = " immediately be accessible by the current context.  See \\ref CUDA_UNIFIED for additional"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " Note that access granted by this call is unidirectional and that in order to access"]
    #[doc = " memory from the current context in \\p peerContext, a separate symmetric call"]
    #[doc = " to ::cuCtxEnablePeerAccess() is required."]
    #[doc = ""]
    #[doc = " Note that there are both device-wide and system-wide limitations per system"]
    #[doc = " configuration, as noted in the CUDA Programming Guide under the section"]
    #[doc = " \"Peer-to-Peer Memory Access\"."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED if ::cuDeviceCanAccessPeer() indicates"]
    #[doc = " that the ::CUdevice of the current context cannot directly access memory"]
    #[doc = " from the ::CUdevice of \\p peerContext."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED if direct access of"]
    #[doc = " \\p peerContext from the current context has already been enabled."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_TOO_MANY_PEERS if direct peer access is not possible"]
    #[doc = " because hardware resources required for peer access have been exhausted."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_INVALID_CONTEXT if there is no current context, \\p peerContext"]
    #[doc = " is not a valid context, or if the current context is \\p peerContext."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_INVALID_VALUE if \\p Flags is not 0."]
    #[doc = ""]
    #[doc = " \\param peerContext - Peer context to enable direct access to from the current context"]
    #[doc = " \\param Flags       - Reserved for future use and must be set to 0"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED,"]
    #[doc = " ::CUDA_ERROR_TOO_MANY_PEERS,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceCanAccessPeer,"]
    #[doc = " ::cuCtxDisablePeerAccess,"]
    #[doc = " ::cudaDeviceEnablePeerAccess"]
    pub fn cuCtxEnablePeerAccess(peerContext: CUcontext, Flags: ::std::os::raw::c_uint)
        -> CUresult;
}
extern "C" {
    #[doc = " \\brief Disables direct access to memory allocations in a peer context and"]
    #[doc = " unregisters any registered allocations."]
    #[doc = ""]
    #[doc = "Returns ::CUDA_ERROR_PEER_ACCESS_NOT_ENABLED if direct peer access has"]
    #[doc = " not yet been enabled from \\p peerContext to the current context."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_INVALID_CONTEXT if there is no current context, or if"]
    #[doc = " \\p peerContext is not a valid context."]
    #[doc = ""]
    #[doc = " \\param peerContext - Peer context to disable direct access to"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_PEER_ACCESS_NOT_ENABLED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuDeviceCanAccessPeer,"]
    #[doc = " ::cuCtxEnablePeerAccess,"]
    #[doc = " ::cudaDeviceDisablePeerAccess"]
    pub fn cuCtxDisablePeerAccess(peerContext: CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries attributes of the link between two devices."]
    #[doc = ""]
    #[doc = " Returns in \\p *value the value of the requested attribute \\p attrib of the"]
    #[doc = " link between \\p srcDevice and \\p dstDevice. The supported attributes are:"]
    #[doc = " - ::CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK: A relative value indicating the"]
    #[doc = "   performance of the link between two devices."]
    #[doc = " - ::CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED P2P: 1 if P2P Access is enable."]
    #[doc = " - ::CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED: 1 if Atomic operations over"]
    #[doc = "   the link are supported."]
    #[doc = " - ::CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED: 1 if cudaArray can"]
    #[doc = "   be accessed over the link."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_INVALID_DEVICE if \\p srcDevice or \\p dstDevice are not valid"]
    #[doc = " or if they represent the same device."]
    #[doc = ""]
    #[doc = " Returns ::CUDA_ERROR_INVALID_VALUE if \\p attrib is not valid or if \\p value is"]
    #[doc = " a null pointer."]
    #[doc = ""]
    #[doc = " \\param value         - Returned value of the requested attribute"]
    #[doc = " \\param attrib        - The requested attribute of the link between \\p srcDevice and \\p dstDevice."]
    #[doc = " \\param srcDevice     - The source device of the target link."]
    #[doc = " \\param dstDevice     - The destination device of the target link."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_DEVICE,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuCtxEnablePeerAccess,"]
    #[doc = " ::cuCtxDisablePeerAccess,"]
    #[doc = " ::cuDeviceCanAccessPeer,"]
    #[doc = " ::cudaDeviceGetP2PAttribute"]
    pub fn cuDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attrib: CUdevice_P2PAttribute,
        srcDevice: CUdevice,
        dstDevice: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unregisters a graphics resource for access by CUDA"]
    #[doc = ""]
    #[doc = " Unregisters the graphics resource \\p resource so it is not accessible by"]
    #[doc = " CUDA unless registered again."]
    #[doc = ""]
    #[doc = " If \\p resource is invalid then ::CUDA_ERROR_INVALID_HANDLE is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " \\param resource - Resource to unregister"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphicsD3D9RegisterResource,"]
    #[doc = " ::cuGraphicsD3D10RegisterResource,"]
    #[doc = " ::cuGraphicsD3D11RegisterResource,"]
    #[doc = " ::cuGraphicsGLRegisterBuffer,"]
    #[doc = " ::cuGraphicsGLRegisterImage,"]
    #[doc = " ::cudaGraphicsUnregisterResource"]
    pub fn cuGraphicsUnregisterResource(resource: CUgraphicsResource) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get an array through which to access a subresource of a mapped graphics resource."]
    #[doc = ""]
    #[doc = " Returns in \\p *pArray an array through which the subresource of the mapped"]
    #[doc = " graphics resource \\p resource which corresponds to array index \\p arrayIndex"]
    #[doc = " and mipmap level \\p mipLevel may be accessed.  The value set in \\p *pArray may"]
    #[doc = " change every time that \\p resource is mapped."]
    #[doc = ""]
    #[doc = " If \\p resource is not a texture then it cannot be accessed via an array and"]
    #[doc = " ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY is returned."]
    #[doc = " If \\p arrayIndex is not a valid array index for \\p resource then"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = " If \\p mipLevel is not a valid mipmap level for \\p resource then"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE is returned."]
    #[doc = " If \\p resource is not mapped then ::CUDA_ERROR_NOT_MAPPED is returned."]
    #[doc = ""]
    #[doc = " \\param pArray      - Returned array through which a subresource of \\p resource may be accessed"]
    #[doc = " \\param resource    - Mapped resource to access"]
    #[doc = " \\param arrayIndex  - Array index for array textures or cubemap face"]
    #[doc = "                      index as defined by ::CUarray_cubemap_face for"]
    #[doc = "                      cubemap textures for the subresource to access"]
    #[doc = " \\param mipLevel    - Mipmap level for the subresource to access"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_MAPPED,"]
    #[doc = " ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphicsResourceGetMappedPointer,"]
    #[doc = " ::cudaGraphicsSubResourceGetMappedArray"]
    pub fn cuGraphicsSubResourceGetMappedArray(
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get a mipmapped array through which to access a mapped graphics resource."]
    #[doc = ""]
    #[doc = " Returns in \\p *pMipmappedArray a mipmapped array through which the mapped graphics"]
    #[doc = " resource \\p resource. The value set in \\p *pMipmappedArray may change every time"]
    #[doc = " that \\p resource is mapped."]
    #[doc = ""]
    #[doc = " If \\p resource is not a texture then it cannot be accessed via a mipmapped array and"]
    #[doc = " ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY is returned."]
    #[doc = " If \\p resource is not mapped then ::CUDA_ERROR_NOT_MAPPED is returned."]
    #[doc = ""]
    #[doc = " \\param pMipmappedArray - Returned mipmapped array through which \\p resource may be accessed"]
    #[doc = " \\param resource        - Mapped resource to access"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_MAPPED,"]
    #[doc = " ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphicsResourceGetMappedPointer,"]
    #[doc = " ::cudaGraphicsResourceGetMappedMipmappedArray"]
    pub fn cuGraphicsResourceGetMappedMipmappedArray(
        pMipmappedArray: *mut CUmipmappedArray,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceGetMappedPointer_v2(
        pDevPtr: *mut CUdeviceptr,
        pSize: *mut size_t,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceSetMapFlags_v2(
        resource: CUgraphicsResource,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Map graphics resources for access by CUDA"]
    #[doc = ""]
    #[doc = " Maps the \\p count graphics resources in \\p resources for access by CUDA."]
    #[doc = ""]
    #[doc = " The resources in \\p resources may be accessed by CUDA until they"]
    #[doc = " are unmapped. The graphics API from which \\p resources were registered"]
    #[doc = " should not access any resources while they are mapped by CUDA. If an"]
    #[doc = " application does so, the results are undefined."]
    #[doc = ""]
    #[doc = " This function provides the synchronization guarantee that any graphics calls"]
    #[doc = " issued before ::cuGraphicsMapResources() will complete before any subsequent CUDA"]
    #[doc = " work issued in \\p stream begins."]
    #[doc = ""]
    #[doc = " If \\p resources includes any duplicate entries then ::CUDA_ERROR_INVALID_HANDLE is returned."]
    #[doc = " If any of \\p resources are presently mapped for access by CUDA then ::CUDA_ERROR_ALREADY_MAPPED is returned."]
    #[doc = ""]
    #[doc = " \\param count      - Number of resources to map"]
    #[doc = " \\param resources  - Resources to map for CUDA usage"]
    #[doc = " \\param hStream    - Stream with which to synchronize"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_ALREADY_MAPPED,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphicsResourceGetMappedPointer,"]
    #[doc = " ::cuGraphicsSubResourceGetMappedArray,"]
    #[doc = " ::cuGraphicsUnmapResources,"]
    #[doc = " ::cudaGraphicsMapResources"]
    pub fn cuGraphicsMapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unmap graphics resources."]
    #[doc = ""]
    #[doc = " Unmaps the \\p count graphics resources in \\p resources."]
    #[doc = ""]
    #[doc = " Once unmapped, the resources in \\p resources may not be accessed by CUDA"]
    #[doc = " until they are mapped again."]
    #[doc = ""]
    #[doc = " This function provides the synchronization guarantee that any CUDA work issued"]
    #[doc = " in \\p stream before ::cuGraphicsUnmapResources() will complete before any"]
    #[doc = " subsequently issued graphics work begins."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " If \\p resources includes any duplicate entries then ::CUDA_ERROR_INVALID_HANDLE is returned."]
    #[doc = " If any of \\p resources are not presently mapped for access by CUDA then ::CUDA_ERROR_NOT_MAPPED is returned."]
    #[doc = ""]
    #[doc = " \\param count      - Number of resources to unmap"]
    #[doc = " \\param resources  - Resources to unmap"]
    #[doc = " \\param hStream    - Stream with which to synchronize"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_HANDLE,"]
    #[doc = " ::CUDA_ERROR_NOT_MAPPED,"]
    #[doc = " ::CUDA_ERROR_UNKNOWN"]
    #[doc = " \\note_null_stream"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cuGraphicsMapResources,"]
    #[doc = " ::cudaGraphicsUnmapResources"]
    pub fn cuGraphicsUnmapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the requested driver API function pointer"]
    #[doc = ""]
    #[doc = " Returns in \\p **pfn the address of the CUDA driver function for the requested"]
    #[doc = " CUDA version and flags."]
    #[doc = ""]
    #[doc = " The CUDA version is specified as (1000 * major + 10 * minor), so CUDA 11.2"]
    #[doc = " should be specified as 11020. For a requested driver symbol, if the specified"]
    #[doc = " CUDA version is greater than or equal to the CUDA version in which the driver symbol"]
    #[doc = " was introduced, this API will return the function pointer to the corresponding"]
    #[doc = " versioned function."]
    #[doc = ""]
    #[doc = " The pointer returned by the API should be cast to a function pointer matching the"]
    #[doc = " requested driver function's definition in the API header file. The function pointer"]
    #[doc = " typedef can be picked up from the corresponding typedefs header file. For example,"]
    #[doc = " cudaTypedefs.h consists of function pointer typedefs for driver APIs defined in cuda.h."]
    #[doc = ""]
    #[doc = " The API will return ::CUDA_ERROR_NOT_FOUND if the requested driver function is not"]
    #[doc = " supported on the platform, no ABI compatible driver function exists for the specified"]
    #[doc = " \\p cudaVersion or if the driver symbol is invalid."]
    #[doc = ""]
    #[doc = " The requested flags can be:"]
    #[doc = " - ::CU_GET_PROC_ADDRESS_DEFAULT: This is the default mode. This is equivalent to"]
    #[doc = "   ::CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM if the code is compiled with"]
    #[doc = "   --default-stream per-thread compilation flag or the macro CUDA_API_PER_THREAD_DEFAULT_STREAM"]
    #[doc = "   is defined; ::CU_GET_PROC_ADDRESS_LEGACY_STREAM otherwise."]
    #[doc = " - ::CU_GET_PROC_ADDRESS_LEGACY_STREAM: This will enable the search for all driver symbols"]
    #[doc = "   that match the requested driver symbol name except the corresponding per-thread versions."]
    #[doc = " - ::CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM: This will enable the search for all"]
    #[doc = "   driver symbols that match the requested driver symbol name including the per-thread"]
    #[doc = "   versions. If a per-thread version is not found, the API will return the legacy version"]
    #[doc = "   of the driver function."]
    #[doc = ""]
    #[doc = " \\param symbol - The base name of the driver API function to look for. As an example,"]
    #[doc = "                 for the driver API ::cuMemAlloc_v2, \\p symbol would be cuMemAlloc and"]
    #[doc = "                 \\p cudaVersion would be the ABI compatible CUDA version for the _v2 variant."]
    #[doc = " \\param pfn - Location to return the function pointer to the requested driver function"]
    #[doc = " \\param cudaVersion - The CUDA version to look for the requested driver symbol"]
    #[doc = " \\param flags -  Flags to specify search options."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " ::CUDA_ERROR_NOT_SUPPORTED,"]
    #[doc = " ::CUDA_ERROR_NOT_FOUND"]
    #[doc = " \\note_version_mixing"]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " ::cudaGetDriverEntryPoint"]
    pub fn cuGetProcAddress(
        symbol: *const ::std::os::raw::c_char,
        pfn: *mut *mut ::std::os::raw::c_void,
        cudaVersion: ::std::os::raw::c_int,
        flags: cuuint64_t,
    ) -> CUresult;
}
extern "C" {
    #[doc = " @}"]
    pub fn cuGetExportTable(
        ppExportTable: *mut *const ::std::os::raw::c_void,
        pExportTableId: *const CUuuid,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Blocks until remote writes are visible to the specified scope"]
    #[doc = ""]
    #[doc = " Blocks until GPUDirect RDMA writes to the target context via mappings"]
    #[doc = " created through APIs like nvidia_p2p_get_pages (see"]
    #[doc = " https://docs.nvidia.com/cuda/gpudirect-rdma for more information), are"]
    #[doc = " visible to the specified scope."]
    #[doc = ""]
    #[doc = " If the scope equals or lies within the scope indicated by"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING, the call"]
    #[doc = " will be a no-op and can be safely omitted for performance. This can be"]
    #[doc = " determined by comparing the numerical values between the two enums, with"]
    #[doc = " smaller scopes having smaller values."]
    #[doc = ""]
    #[doc = " Users may query support for this API via"]
    #[doc = " ::CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS."]
    #[doc = ""]
    #[doc = " \\param target - The target of the operation, see ::CUflushGPUDirectRDMAWritesTarget"]
    #[doc = " \\param scope  - The scope of the operation, see ::CUflushGPUDirectRDMAWritesScope"]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " ::CUDA_SUCCESS,"]
    #[doc = " ::CUDA_ERROR_DEINITIALIZED,"]
    #[doc = " ::CUDA_ERROR_NOT_INITIALIZED,"]
    #[doc = " ::CUDA_ERROR_INVALID_CONTEXT,"]
    #[doc = " ::CUDA_ERROR_INVALID_VALUE,"]
    #[doc = " \\notefnerr"]
    #[doc = ""]
    pub fn cuFlushGPUDirectRDMAWrites(
        target: CUflushGPUDirectRDMAWritesTarget,
        scope: CUflushGPUDirectRDMAWritesScope,
    ) -> CUresult;
}
